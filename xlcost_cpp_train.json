{"text": "Minimum number of coins having value equal to powers of 2 required to obtain N | C program for above approach ; Function to count of set bit in N ; Stores count of set bit in N ; Iterate over the range [ 0 , 31 ] ; If current bit is set ; Update result ; Driver Code", "code": "#include <stdio.h> NEW_LINE void count_setbit ( int N ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( 1 << i ) & N ) { result ++ ; } } printf ( \" % d STRNEWLINE \" , result ) ; } int main ( ) { int N = 43 ; count_setbit ( N ) ; return 0 ; }"}
{"text": "Logarithm tricks for Competitive Programming | C implementation to check that a integer is a power of Two ; Function to check if the number is a power of two ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE _Bool isPowerOfTwo ( int n ) { return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } int main ( ) { int N = 8 ; if ( isPowerOfTwo ( N ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } }"}
{"text": "Ternary representation of Cantor set | C implementation to find the cantor set for n levels and for a given start_num and end_num ; The Linked List Structure for the Cantor Set ; Function to initialize the Cantor Set List ; Function to propogate the list by adding new nodes for the next levels ; Modifying the start and end values for the next level ; Changing the pointers to the next node ; Recursively call the function to generate the Cantor Set for the entire level ; Function to print a level of the Set ; Function to build and display the Cantor Set for each level ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE typedef struct cantor { double start , end ; struct cantor * next ; } Cantor ; Cantor * startList ( Cantor * head , double start_num , double end_num ) { if ( head == NULL ) { head = ( Cantor * ) malloc ( sizeof ( Cantor ) ) ; head -> start = start_num ; head -> end = end_num ; head -> next = NULL ; } return head ; } Cantor * propagate ( Cantor * head ) { Cantor * temp = head ; if ( temp != NULL ) { Cantor * newNode = ( Cantor * ) malloc ( sizeof ( Cantor ) ) ; double diff = ( ( ( temp -> end ) - ( temp -> start ) ) / 3 ) ; newNode -> end = temp -> end ; temp -> end = ( ( temp -> start ) + diff ) ; newNode -> start = ( newNode -> end ) - diff ; newNode -> next = temp -> next ; temp -> next = newNode ; propagate ( temp -> next -> next ) ; } return head ; } void print ( Cantor * temp ) { while ( temp != NULL ) { printf ( \" [ % lf ] \u2581 - - \u2581 [ % lf ] TABSYMBOL \" , temp -> start , temp -> end ) ; temp = temp -> next ; } printf ( \" STRNEWLINE \" ) ; } void buildCantorSet ( int A , int B , int L ) { Cantor * head = NULL ; head = startList ( head , A , B ) ; for ( int i = 0 ; i < L ; i ++ ) { printf ( \" Level _ % d \u2581 : \u2581 \" , i ) ; print ( head ) ; propagate ( head ) ; } printf ( \" Level _ % d \u2581 : \u2581 \" , L ) ; print ( head ) ; } int main ( ) { int A = 0 ; int B = 9 ; int L = 2 ; buildCantorSet ( A , B , L ) ; return 0 ; }"}
{"text": "Optimized Naive Algorithm for Pattern Searching | C program for A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different ; A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different ; For current index i , check for pattern match ; if ( j == M ) if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; slide the pattern by j ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void search ( char pat [ ] , char txt [ ] ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; { printf ( \" Pattern \u2581 found \u2581 at \u2581 index \u2581 % d \u2581 STRNEWLINE \" , i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } int main ( ) { char txt [ ] = \" ABCEABCDABCEABCD \" ; char pat [ ] = \" ABCD \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Program to Encrypt a String using ! and @ | C program to Encrypt the String using ! and @ ; Function to encrypt the string ; evenPos is for storing encrypting char at evenPosition oddPos is for storing encrypting char at oddPosition ; Get the number of times the character is to be repeated ; if i is odd , print ' ! ' else print ' @ ' ; Driver code ; Encrypt the String", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void encrypt ( char input [ 100 ] ) { char evenPos = ' @ ' , oddPos = ' ! ' ; int repeat , ascii ; for ( int i = 0 ; i <= strlen ( input ) ; i ++ ) { ascii = input [ i ] ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( int j = 0 ; j < repeat ; j ++ ) { if ( i % 2 == 0 ) printf ( \" % c \" , oddPos ) ; else printf ( \" % c \" , evenPos ) ; } } } void main ( ) { char input [ 100 ] = { ' A ' , ' b ' , ' C ' , ' d ' } ; encrypt ( input ) ; }"}
{"text": "Recursive function to check if a string is palindrome | A recursive C program to check whether a given number is palindrome or not ; A recursive function that check a str [ s . . e ] is palindrome or not . ; If there is only one character ; If first and last characters do not match ; If there are more than two characters , check if middle substring is also palindrome or not . ; An empty string is considered as palindrome ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #include <stdbool.h> NEW_LINE bool isPalRec ( char str [ ] , int s , int e ) { if ( s == e ) return true ; if ( str [ s ] != str [ e ] ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; } bool isPalindrome ( char str [ ] ) { int n = strlen ( str ) ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; } int main ( ) { char str [ ] = \" geeg \" ; if ( isPalindrome ( str ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Write your own atoi ( ) | A simple C ++ program for implementation of atoi ; if whitespaces then ignore . ; sign of number ; checking for valid input ; handling overflow test case ; Driver Code ; Functional Code", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int myAtoi ( const char * str ) { int sign = 1 , base = 0 , i = 0 ; while ( str [ i ] == ' \u2581 ' ) { i ++ ; } if ( str [ i ] == ' - ' str [ i ] == ' + ' ) { sign = 1 - 2 * ( str [ i ++ ] == ' - ' ) ; } while ( str [ i ] >= '0' && str [ i ] <= '9' ) { if ( base > INT_MAX / 10 || ( base == INT_MAX / 10 && str [ i ] - '0' > 7 ) ) { if ( sign == 1 ) return INT_MAX ; else return INT_MIN ; } base = 10 * base + ( str [ i ++ ] - '0' ) ; } return base * sign ; } int main ( ) { char str [ ] = \" \u2581 - 123\" ; int val = myAtoi ( str ) ; printf ( \" % d \u2581 \" , val ) ; return 0 ; }"}
{"text": "Fill two instances of all numbers from 1 to n in a specific way | A backtracking based C Program to fill two instances of all numbers from 1 to n in a specific way ; A recursive utility function to fill two instances of numbers from 1 to n in res [ 0. .2 n - 1 ] . ' curr ' is current value of n . ; If current number becomes 0 , then all numbers are filled ; Try placing two instances of ' curr ' at all possible locations till solution is found ; Two ' curr ' should be placed at ' curr + 1' distance ; Plave two instances of ' curr ' ; Recur to check if the above placement leads to a solution ; If solution is not possible , then backtrack ; This function prints the result for input number ' n ' using fillUtil ( ) ; Create an array of size 2 n and initialize all elements in it as 0 ; If solution is possible , then print it . ; Driver program", "code": "#include <stdio.h> NEW_LINE #include <stdbool.h> NEW_LINE bool fillUtil ( int res [ ] , int curr , int n ) { if ( curr == 0 ) return true ; int i ; for ( i = 0 ; i < 2 * n - curr - 1 ; i ++ ) { if ( res [ i ] == 0 && res [ i + curr + 1 ] == 0 ) { res [ i ] = res [ i + curr + 1 ] = curr ; if ( fillUtil ( res , curr - 1 , n ) ) return true ; res [ i ] = res [ i + curr + 1 ] = 0 ; } } return false ; } void fill ( int n ) { int res [ 2 * n ] , i ; for ( i = 0 ; i < 2 * n ; i ++ ) res [ i ] = 0 ; if ( fillUtil ( res , n , n ) ) { for ( i = 0 ; i < 2 * n ; i ++ ) printf ( \" % d \u2581 \" , res [ i ] ) ; } else puts ( \" Not \u2581 Possible \" ) ; } int main ( ) { fill ( 7 ) ; return 0 ; }"}
{"text": "Check if N contains all digits as K in base B | C implementation of the approach ; Function to print the number of digits ; Calculate log using base change property and then take its floor and then add 1 ; Return the output ; Function that returns true if n contains all one 's in base b ; Calculate the sum ; Driver code ; Given number N ; Given base B ; Given digit K ; Function call", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE int findNumberOfDigits ( int n , int base ) { int dig = ( floor ( log ( n ) / log ( base ) ) + 1 ) ; return ( dig ) ; } int isAllKs ( int n , int b , int k ) { int len = findNumberOfDigits ( n , b ) ; int sum = k * ( 1 - pow ( b , len ) ) / ( 1 - b ) ; if ( sum == n ) { return ( sum ) ; } } int main ( void ) { int N = 13 ; int B = 3 ; int K = 1 ; if ( isAllKs ( N , B , K ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } return 0 ; }"}
{"text": "Program to Calculate the Perimeter of a Decagon | C program to Calculate the Perimeter of a Decagon ; Function for finding the perimeter ; Driver code", "code": "#include <stdio.h> NEW_LINE void CalPeri ( ) { int s = 5 , Perimeter ; Perimeter = 10 * s ; printf ( \" The \u2581 Perimeter \u2581 of \u2581 Decagon \u2581 is \u2581 : \u2581 % d \" , Perimeter ) ; } int main ( ) { CalPeri ( ) ; return 0 ; }"}
{"text": "Angle between two Planes in 3D | C program to find the Angle between two Planes in 3 D . ; Function to find Angle ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = 3.14159 ; float A = ( 180 / pi ) * ( acos ( d ) ) ; printf ( \" Angle \u2581 is \u2581 % .2f \u2581 degree \" , A ) ; } int main ( ) { float a1 = 1 ; float b1 = 1 ; float c1 = 2 ; float d1 = 1 ; float a2 = 2 ; float b2 = -1 ; float c2 = 1 ; float d2 = -4 ; distance ( a1 , b1 , c1 , a2 , b2 , c2 ) ; return 0 ; }"}
{"text": "Mirror of a point through a 3 D plane | C program to find Mirror of a point through a 3 D plane ; Function to mirror image ; Driver Code ; function call", "code": "#include <stdio.h> NEW_LINE void mirror_point ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; printf ( \" x3 \u2581 = \u2581 % .1f \u2581 \" , x3 ) ; printf ( \" y3 \u2581 = \u2581 % .1f \u2581 \" , y3 ) ; printf ( \" z3 \u2581 = \u2581 % .1f \u2581 \" , z3 ) ; } int main ( ) { float a = 1 ; float b = -2 ; float c = 0 ; float d = 0 ; float x1 = -1 ; float y1 = 3 ; float z1 = 4 ; mirror_point ( a , b , c , d , x1 , y1 , z1 ) ; }"}
{"text": "Change a Binary Tree so that every node stores sum of all nodes in left subtree | C program to store sum of nodes in left subtree in every node ; A tree node ; Function to modify a Binary Tree so that every node stores sum of values in its left child including its own value ; Base cases ; Update left and right subtrees ; Add leftsum to current node ; Return sum of values under root ; Utility function to do inorder traversal ; Utility function to create a new node ; Driver program ; Let us construct below tree 1 / \\ 2 3 / \\ \\ 4 5 6", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; int updatetree ( node * root ) { if ( ! root ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return root -> data ; int leftsum = updatetree ( root -> left ) ; int rightsum = updatetree ( root -> right ) ; root -> data += leftsum ; return root -> data + rightsum ; } void inorder ( struct node * node ) { if ( node == NULL ) return ; inorder ( node -> left ) ; printf ( \" % d \u2581 \" , node -> data ) ; inorder ( node -> right ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; updatetree ( root ) ; cout << \" Inorder \u2581 traversal \u2581 of \u2581 the \u2581 modified \u2581 tree \u2581 is \u2581 STRNEWLINE \" ; inorder ( root ) ; return 0 ; }"}
{"text": "The Stock Span Problem | C program for brute force method to calculate stock span values ; Fills array S [ ] with span values ; Span value of first day is always 1 ; Calculate span value of remaining days by linearly checking previous days ; Initialize span value ; Traverse left while the next element on left is smaller than price [ i ] ; A utility function to print elements of array ; Driver program to test above function ; Fill the span values in array S [ ] ; print the calculated span values", "code": "#include <stdio.h> NEW_LINE void calculateSpan ( int price [ ] , int n , int S [ ] ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; } int main ( ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int S [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S , n ) ; return 0 ; }"}
{"text": "Next Greater Element | Simple C program to print next greater elements in a given array ; prints element and NGE pair for all elements of arr [ ] of size n ; Driver Code", "code": "#include <stdio.h> NEW_LINE void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } printf ( \" % d \u2581 - - \u2581 % dn \" , arr [ i ] , next ) ; } } int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNGE ( arr , n ) ; return 0 ; }"}
{"text": "Convert a Binary Tree into its Mirror Tree | C program to convert a binary tree to its mirror ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Change a tree so that the roles of the left and right pointers are swapped at every node . So the tree ... 4 / \\ 2 5 / \\ 1 3 is changed to ... 4 / \\ 5 2 / \\ 3 1 ; do the subtrees ; swap the pointers in this node ; Helper function to print Inorder traversal . ; Driver program to test mirror ( ) ; Print inorder traversal of the input tree ; Convert tree to its mirror ; Print inorder traversal of the mirror tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void mirror ( struct Node * node ) { if ( node == NULL ) return ; else { struct Node * temp ; mirror ( node -> left ) ; mirror ( node -> right ) ; temp = node -> left ; node -> left = node -> right ; node -> right = temp ; } } void inOrder ( struct Node * node ) { if ( node == NULL ) return ; inOrder ( node -> left ) ; printf ( \" % d \u2581 \" , node -> data ) ; inOrder ( node -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Inorder \u2581 traversal \u2581 of \u2581 the \u2581 constructed \" \" \u2581 tree \u2581 is \u2581 STRNEWLINE \" ) ; inOrder ( root ) ; mirror ( root ) ; printf ( \" Inorder traversal of the mirror tree \" \u2581 \" is \" inOrder ( root ) ; return 0 ; }"}
{"text": "Foldable Binary Trees |  ; A binary tree node has data , pointer to left child and a pointer to right child ; A utility function that checks if trees with roots as n1 and n2 are mirror of each other ; Returns true if the given tree can be folded ; A utility function that checks if trees with roots as n1 and n2 are mirror of each other ; If both left and right subtrees are NULL , then return true ; If one of the trees is NULL and other is not , then return false ; Otherwise check if left and right subtrees are mirrors of their counterparts ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test mirror ( ) ; The constructed binary tree is 1 / \\ 2 3 \\ / 4 5", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define bool  int NEW_LINE #define true  1 NEW_LINE #define false  0 NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; bool IsFoldableUtil ( struct node * n1 , struct node * n2 ) ; bool IsFoldable ( struct node * root ) { if ( root == NULL ) { return true ; } return IsFoldableUtil ( root -> left , root -> right ) ; } bool IsFoldableUtil ( struct node * n1 , struct node * n2 ) { if ( n1 == NULL && n2 == NULL ) { return true ; } if ( n1 == NULL n2 == NULL ) { return false ; } return IsFoldableUtil ( n1 -> left , n2 -> right ) && IsFoldableUtil ( n1 -> right , n2 -> left ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( void ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; if ( IsFoldable ( root ) == true ) { printf ( \" tree is foldable \" } else { printf ( \" tree is not foldable \" } getchar ( ) ; return 0 ; }"}
{"text": "Check for Children Sum Property in a Binary Tree | Program to check children sum property ; A binary tree node has data , left child and right child ; returns 1 if children sum property holds for the given node and both of its children ; left_data is left child data and right_data is for right child data ; If node is NULL or it 's a leaf node then  return true  ; If left child is not present then 0 is used as data of left child ; If right child is not present then 0 is used as data of right child ; if the node and both of its children satisfy the property return 1 else 0 ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int isSumProperty ( struct node * node ) { int left_data = 0 , right_data = 0 ; if ( node == NULL || ( node -> left == NULL && node -> right == NULL ) ) return 1 ; else { if ( node -> left != NULL ) left_data = node -> left -> data ; if ( node -> right != NULL ) right_data = node -> right -> data ; if ( ( node -> data == left_data + right_data ) && isSumProperty ( node -> left ) && isSumProperty ( node -> right ) ) return 1 ; else return 0 ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 10 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 2 ) ; if ( isSumProperty ( root ) ) printf ( \" The \u2581 given \u2581 tree \u2581 satisfies \u2581 the \u2581 children \u2581 sum \u2581 property \u2581 \" ) ; else printf ( \" The \u2581 given \u2581 tree \u2581 does \u2581 not \u2581 satisfy \u2581 the \u2581 children \u2581 sum \u2581 property \u2581 \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program to find HCF ( Highest Common Factor ) of 2 Numbers | C program to find GCD of two numbers ; Recursive function to return gcd of a and b ; Everything divides 0 ; base case ; a is greater ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } int main ( ) { int a = 0 , b = 56 ; printf ( \" GCD \u2581 of \u2581 % d \u2581 and \u2581 % d \u2581 is \u2581 % d \u2581 \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "Josephus Problem Using Bit Magic | C program for josephus problem ; function to find the position of the Most Significant Bit ; keeps shifting bits to the right until we are left with 0 ; function to return at which place Josephus should sit to avoid being killed ; Getting the position of the Most Significant Bit ( MSB ) . The leftmost '1' . If the number is '41' then its binary is '101001' . So msbPos ( 41 ) = 6 ; ' j ' stores the number with which to XOR the number ' n ' . Since we need '100000' We will do 1 << 6 - 1 to get '100000' ; Toggling the Most Significant Bit . Changing the leftmost '1' to '0' . 101001 ^ 100000 = 001001 ( 9 ) ; Left - shifting once to add an extra '0' to the right end of the binary number 001001 = 010010 ( 18 ) ; Toggling the '0' at the end to '1' which is essentially the same as putting the MSB at the rightmost place . 010010 | 1 = 010011 ( 19 ) ; hard coded driver main function to run the program", "code": "#include <stdio.h> NEW_LINE int msbPos ( int n ) { int pos = 0 ; while ( n != 0 ) { pos ++ ; n = n >> 1 ; } return pos ; } int josephify ( int n ) { int position = msbPos ( n ) ; int j = 1 << ( position - 1 ) ; n = n ^ j ; n = n << 1 ; n = n | 1 ; return n ; } int main ( ) { int n = 41 ; printf ( \" % d STRNEWLINE \" , josephify ( n ) ) ; return 0 ; }"}
{"text": "Sum of Bitwise And of all pairs in a given array | An efficient C ++ program to compute sum of bitwise AND of all pairs ; Returns value of \" arr [ 0 ] \u2581 & \u2581 arr [ 1 ] \u2581 + \u2581 arr [ 0 ] \u2581 & \u2581 arr [ 2 ] \u2581 + \u2581 . . . \u2581 arr [ i ] \u2581 & \u2581 arr [ j ] \u2581 + \u2581 . . . . . \u2581 arr [ n - 2 ] \u2581 & \u2581 arr [ n - 1 ] \" ; Traverse over all bits ; Count number of elements with i 'th bit set  int k = 0; Initialize the count ; There are k set bits , means k ( k - 1 ) / 2 pairs . Every pair adds 2 ^ i to the answer . Therefore , we add \"2 ^ i \u2581 * \u2581 [ k * ( k - 1 ) / 2 ] \" to the answer . ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int pairAndSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) k ++ ; ans += ( 1 << i ) * ( k * ( k - 1 ) / 2 ) ; } return ans ; } int main ( ) { int arr [ ] = { 5 , 10 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << pairAndSum ( arr , n ) << endl ; return 0 ; }"}
{"text": "Puzzle | Program to find number of squares in a chessboard | Function to return count of squares ; ; A better way to write n * ( n + 1 ) * ( 2 n + 1 ) / 6 ; Driver Code", "code": "function countSquares ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } let n = 4 ; document . write ( \" Count \u2581 of \u2581 squares \u2581 is \u2581 \" + countSquares ( n ) ) ;"}
{"text": "Program to find GCD or HCF of two numbers | C program to find GCD of two numbers ; Recursive function to return gcd of a and b ; Everything divides 0 ; base case ; a is greater ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } int main ( ) { int a = 98 , b = 56 ; printf ( \" GCD \u2581 of \u2581 % d \u2581 and \u2581 % d \u2581 is \u2581 % d \u2581 \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "Construct XOR tree by Given leaf nodes of Perfect Binary Tree | C program to build xor tree by leaf nodes of perfect binary tree and root node value of tree ; maximum size for xor tree ; Allocating space to xor tree ; A recursive function that constructs xor tree for array [ start ... . . end ] . x is index of current node in xor tree st ; If there is one element in array , store it in current node of xor tree and return ; printf ( \" % d \u2581 \" , xortree [ x ] ) ; ; for left subtree ; for right subtree ; for getting the middle index from corner indexes . ; Build the left and the right subtrees by xor operation ; merge the left and right subtrees by XOR operation ; Function to construct XOR tree from given array . This function calls construct_Xor_Tree_Util ( ) to fill the allocated memory of xort array ; Driver Code ; leaf nodes of Binary Tree ; Build the xor tree ; Height of xor tree ; Maximum size of xor tree ; Root node is at index 0 considering 0 - based indexing in XOR Tree ; print value at root node", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #define maxsize  10005 NEW_LINE int xortree [ maxsize ] ; void construct_Xor_Tree_Util ( int current [ ] , int start , int end , int x ) { if ( start == end ) { xortree [ x ] = current [ start ] ; return ; } int left = x * 2 + 1 ; int right = x * 2 + 2 ; int mid = start + ( end - start ) / 2 ; construct_Xor_Tree_Util ( current , start , mid , left ) ; construct_Xor_Tree_Util ( current , mid + 1 , end , right ) ; xortree [ x ] = ( xortree [ left ] ^ xortree [ right ] ) ; } void construct_Xor_Tree ( int arr [ ] , int n ) { int i = 0 ; for ( i = 0 ; i < maxsize ; i ++ ) xortree [ i ] = 0 ; construct_Xor_Tree_Util ( arr , 0 , n - 1 , 0 ) ; } int main ( ) { int leaf_nodes [ ] = { 40 , 32 , 12 , 1 , 4 , 3 , 2 , 7 } , i = 0 ; int n = sizeof ( leaf_nodes ) / sizeof ( leaf_nodes [ 0 ] ) ; construct_Xor_Tree ( leaf_nodes , n ) ; int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; printf ( \" Nodes \u2581 of \u2581 the \u2581 XOR \u2581 tree STRNEWLINE \" ) ; for ( i = 0 ; i < max_size ; i ++ ) { printf ( \" % d \u2581 \" , xortree [ i ] ) ; } int root = 0 ; printf ( \" Root : % d \" , xortree [ root ] ) ; }"}
{"text": "How to swap two bits in a given integer ? | C code for swapping given bits of a number ; left - shift 1 p1 and p2 times and using XOR ; Driver Code", "code": "#include <stdio.h> NEW_LINE int swapBits ( int n , int p1 , int p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; } int main ( ) { printf ( \" Result \u2581 = \u2581 % d \" , swapBits ( 28 , 0 , 3 ) ) ; return 0 ; }"}
{"text": "Check if two nodes are cousins in a Binary Tree | C program to check if two Nodes in a binary tree are cousins ; A Binary Tree Node ; A utility function to create a new Binary Tree Node ; Recursive function to check if two Nodes are siblings ; Base case ; Recursive function to find level of Node ' ptr ' in a binary tree ; base cases ; Return level if Node is present in left subtree ; Else search in right subtree ; Returns 1 if a and b are cousins , otherwise 0 ; 1. The two Nodes should be on the same level in the binary tree . 2. The two Nodes should not be siblings ( means that they should not have the same parent Node ) . ; Driver Program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int item ) { struct Node * temp = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; } int isSibling ( struct Node * root , struct Node * a , struct Node * b ) { if ( root == NULL ) return 0 ; return ( ( root -> left == a && root -> right == b ) || ( root -> left == b && root -> right == a ) || isSibling ( root -> left , a , b ) || isSibling ( root -> right , a , b ) ) ; } int level ( struct Node * root , struct Node * ptr , int lev ) { if ( root == NULL ) return 0 ; if ( root == ptr ) return lev ; int l = level ( root -> left , ptr , lev + 1 ) ; if ( l != 0 ) return l ; return level ( root -> right , ptr , lev + 1 ) ; } int isCousin ( struct Node * root , struct Node * a , struct Node * b ) { if ( ( level ( root , a , 1 ) == level ( root , b , 1 ) ) && ! ( isSibling ( root , a , b ) ) ) return 1 ; else return 0 ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> right -> right = newNode ( 15 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; struct Node * Node1 , * Node2 ; Node1 = root -> left -> left ; Node2 = root -> right -> right ; isCousin ( root , Node1 , Node2 ) ? puts ( \" Yes \" ) : puts ( \" No \" ) ; return 0 ; }"}
{"text": "Check if all leaves are at same level | C program to check if all leaves are at same level ; A binary tree node ; A utility function to allocate a new tree node ; Recursive function which checks whether all leaves are at same level ; Base case ; If a leaf node is encountered ; When a leaf node is found first time ; Set first found leaf 's level ; If this is not first leaf node , compare its level with first leaf 's level ; If this node is not leaf , recursively check left and right subtrees ; The main function to check if all leafs are at same level . It mainly uses checkUtil ( ) ; Driver program to test above function ; Let us create tree shown in thirdt example", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } bool checkUtil ( struct Node * root , int level , int * leafLevel ) { if ( root == NULL ) return true ; if ( root -> left == NULL && root -> right == NULL ) { if ( * leafLevel == 0 ) { * leafLevel = level ; return true ; } return ( level == * leafLevel ) ; } return checkUtil ( root -> left , level + 1 , leafLevel ) && checkUtil ( root -> right , level + 1 , leafLevel ) ; } bool check ( struct Node * root ) { int level = 0 , leafLevel = 0 ; return checkUtil ( root , level , & leafLevel ) ; } int main ( ) { struct Node * root = newNode ( 12 ) ; root -> left = newNode ( 5 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 9 ) ; root -> left -> left -> left = newNode ( 1 ) ; root -> left -> right -> left = newNode ( 1 ) ; if ( check ( root ) ) printf ( \" Leaves \u2581 are \u2581 at \u2581 same \u2581 level STRNEWLINE \" ) ; else printf ( \" Leaves \u2581 are \u2581 not \u2581 at \u2581 same \u2581 level STRNEWLINE \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Check whether a binary tree is a full binary tree or not | C program to check whether a given Binary Tree is full or not ; Tree node structure ; Helper function that allocates a new node with the given key and NULL left and right pointer . ; This function tests if a binary tree is a full binary tree . ; If empty tree ; If leaf node ; If both left and right are not NULL , and left & right subtrees are full ; We reach here when none of the above if conditions work ; Driver Program", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE struct Node { int key ; struct Node * left , * right ; } ; struct Node * newNode ( char k ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> key = k ; node -> right = node -> left = NULL ; return node ; } bool isFullTree ( struct Node * root ) { if ( root == NULL ) return true ; if ( root -> left == NULL && root -> right == NULL ) return true ; if ( ( root -> left ) && ( root -> right ) ) return ( isFullTree ( root -> left ) && isFullTree ( root -> right ) ) ; return false ; } int main ( ) { struct Node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( 20 ) ; root -> right = newNode ( 30 ) ; root -> left -> right = newNode ( 40 ) ; root -> left -> left = newNode ( 50 ) ; root -> right -> left = newNode ( 60 ) ; root -> right -> right = newNode ( 70 ) ; root -> left -> left -> left = newNode ( 80 ) ; root -> left -> left -> right = newNode ( 90 ) ; root -> left -> right -> left = newNode ( 80 ) ; root -> left -> right -> right = newNode ( 90 ) ; root -> right -> left -> left = newNode ( 80 ) ; root -> right -> left -> right = newNode ( 90 ) ; root -> right -> right -> left = newNode ( 80 ) ; root -> right -> right -> right = newNode ( 90 ) ; if ( isFullTree ( root ) ) printf ( \" The \u2581 Binary \u2581 Tree \u2581 is \u2581 full STRNEWLINE \" ) ; else printf ( \" The \u2581 Binary \u2581 Tree \u2581 is \u2581 not \u2581 full STRNEWLINE \" ) ; return ( 0 ) ; }"}
{"text": "Print alternate elements of an array | C program to implement the above approach ; Function to print Alternate elements of the given array ; Print elements at odd positions ; Print elements of array ; Driver Code", "code": "#include <stdio.h> NEW_LINE void printAlter ( int arr [ ] , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex += 2 ) { printf ( \" % d \u2581 \" , arr [ currIndex ] ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAlter ( arr , N ) ; }"}
{"text": "Write Code to Determine if Two Trees are Identical |  ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Given two trees , return true if they are structurally identical ; 1. both empty ; 2. both non - empty -> compare them ; 3. one empty , one not -> false ; Driver program to test identicalTrees function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int identicalTrees ( struct node * a , struct node * b ) { if ( a == NULL && b == NULL ) return 1 ; if ( a != NULL && b != NULL ) { return ( a -> data == b -> data && identicalTrees ( a -> left , b -> left ) && identicalTrees ( a -> right , b -> right ) ) ; } return 0 ; } int main ( ) { struct node * root1 = newNode ( 1 ) ; struct node * root2 = newNode ( 1 ) ; root1 -> left = newNode ( 2 ) ; root1 -> right = newNode ( 3 ) ; root1 -> left -> left = newNode ( 4 ) ; root1 -> left -> right = newNode ( 5 ) ; root2 -> left = newNode ( 2 ) ; root2 -> right = newNode ( 3 ) ; root2 -> left -> left = newNode ( 4 ) ; root2 -> left -> right = newNode ( 5 ) ; if ( identicalTrees ( root1 , root2 ) ) printf ( \" Both \u2581 tree \u2581 are \u2581 identical . \" ) ; else printf ( \" Trees \u2581 are \u2581 not \u2581 identical . \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Print cousins of a given node in Binary Tree | C program to print cousins of a node ; A Binary Tree Node ; A utility function to create a new Binary Tree Node ; It returns level of the node if it is present in tree , otherwise returns 0. ; base cases ; If node is present in left subtree ; If node is not present in left subtree ; Print nodes at a given level such that sibling of node is not printed if it exists ; Base cases ; If current node is parent of a node with given level ; Recur for left and right subtrees ; This function prints cousins of a given node ; Get level of given node ; Print nodes of given level . ; Driver Program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; } int getLevel ( Node * root , Node * node , int level ) { if ( root == NULL ) return 0 ; if ( root == node ) return level ; int downlevel = getLevel ( root -> left , node , level + 1 ) ; if ( downlevel != 0 ) return downlevel ; return getLevel ( root -> right , node , level + 1 ) ; } void printGivenLevel ( Node * root , Node * node , int level ) { if ( root == NULL level < 2 ) return ; if ( level == 2 ) { if ( root -> left == node root -> right == node ) return ; if ( root -> left ) printf ( \" % d \u2581 \" , root -> left -> data ) ; if ( root -> right ) printf ( \" % d \u2581 \" , root -> right -> data ) ; } else if ( level > 2 ) { printGivenLevel ( root -> left , node , level - 1 ) ; printGivenLevel ( root -> right , node , level - 1 ) ; } } void printCousins ( Node * root , Node * node ) { int level = getLevel ( root , node , 1 ) ; printGivenLevel ( root , node , level ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> right -> right = newNode ( 15 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; printCousins ( root , root -> left -> right ) ; return 0 ; }"}
{"text": "Given a binary tree , print out all of its root | program to print all of its root - to - leaf paths for a tree ; A binary tree node has data , pointer to left child and a pointer to right child ; Function prototypes ; Given a binary tree , print out all of its root - to - leaf paths , one per line . Uses a recursive helper to do the work . ; Recursive helper function -- given a node , and an array containing the path from the root node up to but not including this node , print out all the root - leaf paths . ; append this node to the path array ; it 's a leaf, so print the path that led to here  ; otherwise try both subtrees ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Utility that prints out an array on a line ; Driver program to test mirror ( ) ; Print all root - to - leaf paths of the input tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; void printArray ( int [ ] , int ) ; void printPathsRecur ( struct node * , int [ ] , int ) ; struct node * newNode ( int ) ; void printPaths ( struct node * ) ; void printPaths ( struct node * node ) { int path [ 1000 ] ; printPathsRecur ( node , path , 0 ) ; } void printPathsRecur ( struct node * node , int path [ ] , int pathLen ) { if ( node == NULL ) return ; path [ pathLen ] = node -> data ; pathLen ++ ; if ( node -> left == NULL && node -> right == NULL ) { printArray ( path , pathLen ) ; } else { printPathsRecur ( node -> left , path , pathLen ) ; printPathsRecur ( node -> right , path , pathLen ) ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void printArray ( int ints [ ] , int len ) { int i ; for ( i = 0 ; i < len ; i ++ ) { printf ( \" % d \u2581 \" , ints [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printPaths ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Introduction to Arrays |  ; Creating an integer array named arr of size 10. ; accessing element at 0 index and setting its value to 5. ; access and print value at 0 index we get the output as 5.", "code": "#include <stdio.h> NEW_LINE int main ( ) { int arr [ 10 ] ; arr [ 0 ] = 5 ; printf ( \" % d \" , arr [ 0 ] ) ; return 0 ; }"}
{"text": "Block swap algorithm for array rotation |  ; Prototype for utility functions ; Return If number of elements to be rotated is zero or equal to array size ; If number of elements to be rotated is exactly half of array size ; If A is shorter ; If B is shorter ; function to print an array ; This function swaps d elements starting at index fi with d elements starting at index si ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE void printArray ( int arr [ ] , int size ) ; void swap ( int arr [ ] , int fi , int si , int d ) ; void leftRotate ( int arr [ ] , int d , int n ) { if ( d == 0 d == n ) return ; if ( n - d == d ) { swap ( arr , 0 , n - d , d ) ; return ; } if ( d < n - d ) { swap ( arr , 0 , n - d , d ) ; leftRotate ( arr , d , n - d ) ; } else { swap ( arr , 0 , d , n - d ) ; leftRotate ( arr + n - d , 2 * d - n , d ) ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; printf ( \" STRNEWLINE \u2581 \" ) ; } void swap ( int arr [ ] , int fi , int si , int d ) { int i , temp ; for ( i = 0 ; i < d ; i ++ ) { temp = arr [ fi + i ] ; arr [ fi + i ] = arr [ si + i ] ; arr [ si + i ] = temp ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; leftRotate ( arr , 2 , 7 ) ; printArray ( arr , 7 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Block swap algorithm for array rotation | C code for above implementation ; A is shorter ; B is shorter ; Finally , block swap A and B", "code": "void leftRotate ( int arr [ ] , int d , int n ) { int i , j ; if ( d == 0 d == n ) return ; i = d ; j = n - d ; while ( i != j ) { if ( i < j ) { swap ( arr , d - i , d + j - i , i ) ; j -= i ; } else { swap ( arr , d - i , d , j ) ; i -= j ; } } swap ( arr , d - i , d , i ) ; }"}
{"text": "Program to cyclically rotate an array by one |  ; swap ; i and j pointing to first and last element respectively ; Driver code", "code": "#include <stdio.h> NEW_LINE void swap ( int * x , int * y ) { int temp = * x ; * x = * y ; * y = temp ; } void rotate ( int arr [ ] , int n ) { int i = 0 , j = n - 1 ; while ( i != j ) { swap ( & arr [ i ] , & arr [ j ] ) ; i ++ ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } , i ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given \u2581 array \u2581 is STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; rotate ( arr , n ) ; printf ( \" Rotated array is \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; return 0 ; }"}
{"text": "Program to sort an array of strings using Selection Sort | C program to implement selection sort for array of strings . ; Sorts an array of strings where length of every string should be smaller than MAX_LEN ; One by one move boundary of unsorted subarray ; Find the minimum element in unsorted array ; If min is greater than arr [ j ] ; Make arr [ j ] as minStr and update min_idx ; Swap the found minimum element with the first element ; Driver code ; Printing the array before sorting ; Printing the array after sorting", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define MAX_LEN  100 NEW_LINE void selectionSort ( char arr [ ] [ MAX_LEN ] , int n ) { int i , j , min_idx ; char minStr [ MAX_LEN ] ; for ( i = 0 ; i < n - 1 ; i ++ ) { int min_idx = i ; strcpy ( minStr , arr [ i ] ) ; for ( j = i + 1 ; j < n ; j ++ ) { if ( strcmp ( minStr , arr [ j ] ) > 0 ) { strcpy ( minStr , arr [ j ] ) ; min_idx = j ; } } if ( min_idx != i ) { char temp [ MAX_LEN ] ; strcpy ( temp , arr [ i ] ) ; strcpy ( arr [ i ] , arr [ min_idx ] ) ; strcpy ( arr [ min_idx ] , temp ) ; } } } int main ( ) { char arr [ ] [ MAX_LEN ] = { \" GeeksforGeeks \" , \" Practice . GeeksforGeeks \" , \" GeeksQuiz \" } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int i ; printf ( \" Given \u2581 array \u2581 is STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d : \u2581 % s \u2581 STRNEWLINE \" , i , arr [ i ] ) ; selectionSort ( arr , n ) ; printf ( \" Sorted array is \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d : \u2581 % s \u2581 STRNEWLINE \" , i , arr [ i ] ) ; return 0 ; }"}
{"text": "Rearrange an array such that ' arr [ j ] ' becomes ' i ' if ' arr [ i ] ' is ' j ' | Set 1 | A simple C program to rearrange contents of arr [ ] such that arr [ j ] becomes j if arr [ i ] is j ; A simple method to rearrange ' arr [ 0 . . n - 1 ] ' so that ' arr [ j ] ' becomes ' i ' if ' arr [ i ] ' is ' j ' ; Create an auxiliary array of same size ; Store result in temp [ ] ; Copy temp back to arr [ ] ; A utility function to print contents of arr [ 0. . n - 1 ] ; Driver program", "code": "#include <stdio.h> NEW_LINE void rearrangeNaive ( int arr [ ] , int n ) { int temp [ n ] , i ; for ( i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] = i ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 0 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given \u2581 array \u2581 is \u2581 STRNEWLINE \" ) ; printArray ( arr , n ) ; rearrangeNaive ( arr , n ) ; printf ( \" Modified \u2581 array \u2581 is \u2581 STRNEWLINE \" ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Program to find largest element in an array | C program to find maximum in arr [ ] of size n ; C function to find maximum in arr [ ] of size n ; Initialize maximum element ; Traverse array elements from second and compare every element with current max ; Driver Code", "code": "#include <stdio.h> NEW_LINE int largest ( int arr [ ] , int n ) { int i ; int max = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; } int main ( ) { int arr [ ] = { 10 , 324 , 45 , 90 , 9808 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Largest \u2581 in \u2581 given \u2581 array \u2581 is \u2581 % d \" , largest ( arr , n ) ) ; return 0 ; }"}
{"text": "Find Second largest element in an array | C program to find second largest element in an array ; Function to print the second largest elements ; There should be atleast two elements ; If current element is greater than first then update both first and second ; If arr [ i ] is in between first and second then update second ; Driver program to test above function", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { printf ( \" \u2581 Invalid \u2581 Input \u2581 \" ) ; return ; } first = second = INT_MIN ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MIN ) printf ( \" There \u2581 is \u2581 no \u2581 second \u2581 largest \u2581 element STRNEWLINE \" ) ; else printf ( \" The \u2581 second \u2581 largest \u2581 element \u2581 is \u2581 % dn \" , second ) ; } int main ( ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2largest ( arr , n ) ; return 0 ; }"}
{"text": "Maximum and minimum of an array using minimum number of comparisons | structure is used to return two values from minMax ( ) ; If there is only one element then return it as min and max both ; If there are more than one elements , then initialize min and max ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE struct pair { int min ; int max ; } ; struct pair getMinMax ( int arr [ ] , int n ) { struct pair minmax ; int i ; if ( n == 1 ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 0 ] ; return minmax ; } if ( arr [ 0 ] > arr [ 1 ] ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 1 ] ; } else { minmax . max = arr [ 1 ] ; minmax . min = arr [ 0 ] ; } for ( i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > minmax . max ) minmax . max = arr [ i ] ; else if ( arr [ i ] < minmax . min ) minmax . min = arr [ i ] ; } return minmax ; } int main ( ) { int arr [ ] = { 1000 , 11 , 445 , 1 , 330 , 3000 } ; int arr_size = 6 ; struct pair minmax = getMinMax ( arr , arr_size ) ; printf ( \" nMinimum \u2581 element \u2581 is \u2581 % d \" , minmax . min ) ; printf ( \" nMaximum \u2581 element \u2581 is \u2581 % d \" , minmax . max ) ; getchar ( ) ; }"}
{"text": "Maximum and minimum of an array using minimum number of comparisons |  ; structure is used to return two values from minMax ( ) ; If array has even number of elements then initialize the first two elements as minimum and maximum ; set the starting index for loop ; If array has odd number of elements then initialize the first element as minimum and maximum ; set the starting index for loop ; In the while loop , pick elements in pair and compare the pair with max and min so far ; Increment the index by 2 as two elements are processed in loop ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE struct pair { int min ; int max ; } ; struct pair getMinMax ( int arr [ ] , int n ) { struct pair minmax ; int i ; if ( n % 2 == 0 ) { if ( arr [ 0 ] > arr [ 1 ] ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 1 ] ; } else { minmax . min = arr [ 0 ] ; minmax . max = arr [ 1 ] ; } i = 2 ; } else { minmax . min = arr [ 0 ] ; minmax . max = arr [ 0 ] ; i = 1 ; } while ( i < n - 1 ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] > minmax . max ) minmax . max = arr [ i ] ; if ( arr [ i + 1 ] < minmax . min ) minmax . min = arr [ i + 1 ] ; } else { if ( arr [ i + 1 ] > minmax . max ) minmax . max = arr [ i + 1 ] ; if ( arr [ i ] < minmax . min ) minmax . min = arr [ i ] ; } i += 2 ; } return minmax ; } int main ( ) { int arr [ ] = { 1000 , 11 , 445 , 1 , 330 , 3000 } ; int arr_size = 6 ; struct pair minmax = getMinMax ( arr , arr_size ) ; printf ( \" nMinimum \u2581 element \u2581 is \u2581 % d \" , minmax . min ) ; printf ( \" nMaximum \u2581 element \u2581 is \u2581 % d \" , minmax . max ) ; getchar ( ) ; }"}
{"text": "Minimum number of jumps to reach end | C program to find Minimum number of jumps to reach end ; Returns minimum number of jumps to reach arr [ h ] from arr [ l ] ; Base case : when source and destination are same ; When nothing is reachable from the given source ; Traverse through all the points reachable from arr [ l ] . Recursively get the minimum number of jumps needed to reach arr [ h ] from these reachable points . ; Driver program to test above function", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int minJumps ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return INT_MAX ; int min = INT_MAX ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != INT_MAX && jumps + 1 < min ) min = jumps + 1 ; } return min ; } int main ( ) { int arr [ ] = { 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Minimum \u2581 number \u2581 of \u2581 jumps \u2581 to \u2581 reach \u2581 end \u2581 is \u2581 % d \u2581 \" , minJumps ( arr , 0 , n - 1 ) ) ; return 0 ; }"}
{"text": "Smallest subarray with sum greater than a given value |  ; Returns length of smallest subarray with sum greater than x . If there is no subarray with given sum , then returns n + 1 ; Initialize length of smallest subarray as n + 1 ; Pick every element as starting point ; Initialize sum starting with current start ; If first element itself is greater ; Try different ending points for curremt start ; add last element to current sum ; If sum becomes more than x and length of this subarray is smaller than current smallest length , update the smallest length ( or result ) ; Driver program to test above function", "code": "# include <iostream> NEW_LINE using namespace std ; int smallestSubWithSum ( int arr [ ] , int n , int x ) { int min_len = n + 1 ; for ( int start = 0 ; start < n ; start ++ ) { int curr_sum = arr [ start ] ; if ( curr_sum > x ) return 1 ; for ( int end = start + 1 ; end < n ; end ++ ) { curr_sum += arr [ end ] ; if ( curr_sum > x && ( end - start + 1 ) < min_len ) min_len = ( end - start + 1 ) ; } } return min_len ; } int main ( ) { int arr1 [ ] = { 1 , 4 , 45 , 6 , 10 , 19 } ; int x = 51 ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int res1 = smallestSubWithSum ( arr1 , n1 , x ) ; ( res1 == n1 + 1 ) ? cout << \" Not \u2581 possible STRNEWLINE \" : cout << res1 << endl ; int arr2 [ ] = { 1 , 10 , 5 , 2 , 7 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; x = 9 ; int res2 = smallestSubWithSum ( arr2 , n2 , x ) ; ( res2 == n2 + 1 ) ? cout << \" Not \u2581 possible STRNEWLINE \" : cout << res2 << endl ; int arr3 [ ] = { 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; x = 280 ; int res3 = smallestSubWithSum ( arr3 , n3 , x ) ; ( res3 == n3 + 1 ) ? cout << \" Not \u2581 possible STRNEWLINE \" : cout << res3 << endl ; return 0 ; }"}
{"text": "Tree Traversals ( Inorder , Preorder and Postorder ) | C program for different tree traversals ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Given a binary tree , print its nodes according to the \" bottom - up \" postorder traversal . ; first recur on left subtree ; then recur on right subtree ; now deal with the node ; Given a binary tree , print its nodes in inorder ; first recur on left child ; then print the data of node ; now recur on right child ; Given a binary tree , print its nodes in preorder ; first print data of node ; then recur on left sutree ; now recur on right subtree ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void printPostorder ( struct node * node ) { if ( node == NULL ) return ; printPostorder ( node -> left ) ; printPostorder ( node -> right ) ; printf ( \" % d \u2581 \" , node -> data ) ; } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d \u2581 \" , node -> data ) ; printInorder ( node -> right ) ; } void printPreorder ( struct node * node ) { if ( node == NULL ) return ; printf ( \" % d \u2581 \" , node -> data ) ; printPreorder ( node -> left ) ; printPreorder ( node -> right ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Preorder traversal of binary tree is \" printPreorder ( root ) ; printf ( \" Inorder traversal of binary tree is \" printInorder ( root ) ; printf ( \" Postorder traversal of binary tree is \" printPostorder ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Remove all nodes which don 't lie in any path with sum>= k |  ; A Binary Tree Node ; A utility function to create a new Binary Tree node with given data ; print the tree in LVR ( Inorder traversal ) way . ; Main function which truncates the binary tree . ; Base Case ; Recur for left and right subtrees ; If we reach leaf whose data is smaller than sum , we delete the leaf . An important thing to note is a non - leaf node can become leaf when its chilren are deleted . ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } void print ( struct Node * root ) { if ( root != NULL ) { print ( root -> left ) ; printf ( \" % d \u2581 \" , root -> data ) ; print ( root -> right ) ; } } struct Node * prune ( struct Node * root , int sum ) { if ( root == NULL ) return NULL ; root -> left = prune ( root -> left , sum - root -> data ) ; root -> right = prune ( root -> right , sum - root -> data ) ; if ( root -> left == NULL && root -> right == NULL ) { if ( root -> data < sum ) { free ( root ) ; return NULL ; } } return root ; } int main ( ) { int k = 45 ; struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 12 ) ; root -> right -> right -> left = newNode ( 10 ) ; root -> right -> right -> left -> right = newNode ( 11 ) ; root -> left -> left -> right -> left = newNode ( 13 ) ; root -> left -> left -> right -> right = newNode ( 14 ) ; root -> left -> left -> right -> right -> left = newNode ( 15 ) ; printf ( \" Tree \u2581 before \u2581 truncation STRNEWLINE \" ) ; print ( root ) ;"}
{"text": "Merge an array of size n into another array of size m + n | C program to Merge an array of size n into another array of size m + n ; Assuming - 1 is filled for the places where element is not available ; Function to move m elements at the end of array mPlusN [ ] ; Merges array N [ ] of size n into array mPlusN [ ] of size m + n ; Current index of i / p part of mPlusN [ ] ; Current index of N [ ] ; Current index of output mPlusN [ ] ; Take an element from mPlusN [ ] if a ) value of the picked element is smaller and we have not reached end of it b ) We have reached end of N [ ] ; Otherwise take element from N [ ] ; Utility that prints out an array on a line ; Driver code ; Initialize arrays ; Move the m elements at the end of mPlusN ; Merge N [ ] into mPlusN [ ] ; Print the resultant mPlusN", "code": "#include <stdio.h> NEW_LINE #define NA  -1 NEW_LINE void moveToEnd ( int mPlusN [ ] , int size ) { int i = 0 , j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) if ( mPlusN [ i ] != NA ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } } int merge ( int mPlusN [ ] , int N [ ] , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( j == n ) || ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int mPlusN [ ] = { 2 , 8 , NA , NA , NA , 13 , NA , 15 , 20 } ; int N [ ] = { 5 , 7 , 9 , 25 } ; int n = sizeof ( N ) / sizeof ( N [ 0 ] ) ; int m = sizeof ( mPlusN ) / sizeof ( mPlusN [ 0 ] ) - n ; moveToEnd ( mPlusN , m + n ) ; merge ( mPlusN , N , m , n ) ; printArray ( mPlusN , m + n ) ; return 0 ; }"}
{"text": "Count of N | C program to implement the above approach ; Function to find maximum between two numbers ; Function to find minimum between two numbers ; Function to return the count of such numbers ; For 1 - digit numbers , the count is 10 irrespective of K ; dp [ j ] stores the number of such i - digit numbers ending with j ; Stores the results of length i ; Initialize count for 1 - digit numbers ; Compute values for count of digits greater than 1 ; Find the range of allowed numbers if last digit is j ; Perform Range update ; Prefix sum to find actual count of i - digit numbers ending with j ; Update dp [ ] ; Stores the final answer ; Return the final answer ; Driver Code", "code": "#include <stdio.h> NEW_LINE int max ( int num1 , int num2 ) { return ( num1 > num2 ) ? num1 : num2 ; } int min ( int num1 , int num2 ) { return ( num1 > num2 ) ? num2 : num1 ; } int getCount ( int n , int k ) { if ( n == 1 ) return 10 ; int dp [ 11 ] = { 0 } ; int next [ 11 ] = { 0 } ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int l = max ( 0 , ( j - k ) ) ; int r = min ( 9 , ( j + k ) ) ; next [ l ] += dp [ j ] ; next [ r + 1 ] -= dp [ j ] ; } for ( int j = 1 ; j <= 9 ; j ++ ) next [ j ] += next [ j - 1 ] ; for ( int j = 0 ; j < 10 ; j ++ ) { dp [ j ] = next [ j ] ; next [ j ] = 0 ; } } int count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ i ] ; return count ; } int main ( ) { int n = 2 , k = 1 ; printf ( \" % d \" , getCount ( n , k ) ) ; }"}
{"text": "Count Inversions in an array | Set 1 ( Using Merge Sort ) | C program to Count Inversions in an array ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; } int main ( ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" \u2581 Number \u2581 of \u2581 inversions \u2581 are \u2581 % d \u2581 STRNEWLINE \" , getInvCount ( arr , n ) ) ; return 0 ; }"}
{"text": "Two elements whose sum is closest to zero | C code to find Two elements whose sum is closest to zero ; Array should have at least two elements ; Initialization of values ; Driver program to test above function", "code": "# include <stdio.h> NEW_LINE # include <stdlib.h> NEW_LINE # include <math.h> NEW_LINE void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ; if ( arr_size < 2 ) { printf ( \" Invalid \u2581 Input \" ) ; return ; } min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( abs ( min_sum ) > abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } printf ( \" \u2581 The \u2581 two \u2581 elements \u2581 whose \u2581 sum \u2581 is \u2581 minimum \u2581 are \u2581 % d \u2581 and \u2581 % d \" , arr [ min_l ] , arr [ min_r ] ) ; } int main ( ) { int arr [ ] = { 1 , 60 , -10 , 70 , -80 , 85 } ; minAbsSumPair ( arr , 6 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Union and Intersection of two sorted arrays | C program to find union of two sorted arrays ; Function prints union of arr1 [ ] and arr2 [ ] m is the number of elements in arr1 [ ] n is the number of elements in arr2 [ ] ; Print remaining elements of the larger array ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) printf ( \" \u2581 % d \u2581 \" , arr1 [ i ++ ] ) ; else if ( arr2 [ j ] < arr1 [ i ] ) printf ( \" \u2581 % d \u2581 \" , arr2 [ j ++ ] ) ; else { printf ( \" \u2581 % d \u2581 \" , arr2 [ j ++ ] ) ; i ++ ; } } while ( i < m ) printf ( \" \u2581 % d \u2581 \" , arr1 [ i ++ ] ) ; while ( j < n ) printf ( \" \u2581 % d \u2581 \" , arr2 [ j ++ ] ) ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printUnion ( arr1 , arr2 , m , n ) ; getchar ( ) ; return 0 ; }"}
{"text": "Union and Intersection of two sorted arrays | C program to find intersection of two sorted arrays ; Function prints Intersection of arr1 [ ] and arr2 [ ] m is the number of elements in arr1 [ ] n is the number of elements in arr2 [ ] ; Driver program to test above function ; Function calling", "code": "#include <stdio.h> NEW_LINE void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else { printf ( \" \u2581 % d \u2581 \" , arr2 [ j ++ ] ) ; i ++ ; } } } int main ( ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printIntersection ( arr1 , arr2 , m , n ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find the maximum sum leaf to root path in a Binary Tree | C program to find maximum sum leaf to root path in Binary Tree ; A tree node structure ; A utility function that prints all nodes on the path from root to target_leaf ; base case ; return true if this node is the target_leaf or target leaf is present in one of its descendants ; This function Sets the target_leaf_ref to refer the leaf node of the maximum path sum . Also , returns the max_sum using max_sum_ref ; Update current sum to hold sum of nodes on path from root to this node ; If this is a leaf node and path to this node has maximum sum so far , then make this node target_leaf ; If this is not a leaf node , then recur down to find the target_leaf ; Returns the maximum sum and prints the nodes on max sum path ; base case ; find the target leaf and maximum sum ; print the path from root to the target leaf ; return maximum sum ; Utility function to create a new Binary Tree node ; Driver function to test above functions", "code": "#include <limits.h> NEW_LINE #include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; bool printPath ( struct node * root , struct node * target_leaf ) { if ( root == NULL ) return false ; if ( root == target_leaf || printPath ( root -> left , target_leaf ) || printPath ( root -> right , target_leaf ) ) { printf ( \" % d \u2581 \" , root -> data ) ; return true ; } return false ; } void getTargetLeaf ( struct node * node , int * max_sum_ref , int curr_sum , struct node * * target_leaf_ref ) { if ( node == NULL ) return ; curr_sum = curr_sum + node -> data ; if ( node -> left == NULL && node -> right == NULL ) { if ( curr_sum > * max_sum_ref ) { * max_sum_ref = curr_sum ; * target_leaf_ref = node ; } } getTargetLeaf ( node -> left , max_sum_ref , curr_sum , target_leaf_ref ) ; getTargetLeaf ( node -> right , max_sum_ref , curr_sum , target_leaf_ref ) ; } int maxSumPath ( struct node * node ) { if ( node == NULL ) return 0 ; struct node * target_leaf ; int max_sum = INT_MIN ; getTargetLeaf ( node , & max_sum , 0 , & target_leaf ) ; printPath ( node , target_leaf ) ; return max_sum ; } struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int main ( ) { struct node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( -2 ) ; root -> right = newNode ( 7 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( -4 ) ; printf ( \" Following \u2581 are \u2581 the \u2581 nodes \u2581 on \u2581 the \u2581 maximum \u2581 \" \" sum \u2581 path \u2581 STRNEWLINE \" ) ; int sum = maxSumPath ( root ) ; printf ( \" Sum of the nodes is % d \" , sum ) ; getchar ( ) ; return 0 ; }"}
{"text": "Sort an array of 0 s , 1 s and 2 s | C program to sort an array with 0 , 1 and 2 in a single pass ; Function to swap * a and * b ; Sort the input array , the array is assumed to have values in { 0 , 1 , 2 } ; Utility function to print array arr [ ] ; driver program to test", "code": "#include <stdio.h> NEW_LINE void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : swap ( & a [ lo ++ ] , & a [ mid ++ ] ) ; break ; case 1 : mid ++ ; break ; case 2 : swap ( & a [ mid ] , & a [ hi -- ] ) ; break ; } } } void printArray ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; printf ( \" n \" ) ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int i ; sort012 ( arr , arr_size ) ; printf ( \" array \u2581 after \u2581 segregation \u2581 \" ) ; printArray ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find the Minimum length Unsorted Subarray , sorting which makes the complete array sorted | C program to find the Minimum length Unsorted Subarray , sorting which makes the complete array sorted ; step 1 ( a ) of above algo ; step 1 ( b ) of above algo ; step 2 ( a ) of above algo ; step 2 ( b ) of above algo ; step 2 ( c ) of above algo ; step 3 of above algo", "code": "#include <stdio.h> NEW_LINE void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { printf ( \" The \u2581 complete \u2581 array \u2581 is \u2581 sorted \" ) ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } printf ( \" \u2581 The \u2581 unsorted \u2581 subarray \u2581 which \u2581 makes \u2581 the \u2581 given \u2581 array \u2581 \" \" \u2581 sorted \u2581 lies \u2581 between \u2581 the \u2581 indees \u2581 % d \u2581 and \u2581 % d \" , s , e ) ; return ; } int main ( ) { int arr [ ] = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printUnsorted ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Count the number of possible triangles | C program to count number of triangles that can be formed from given array ; Following function is needed for library function qsort ( ) . Refer www . cplusplus . com / reference / clibrary / cstdlib / qsort / ; Function to count all possible triangles with arr [ ] elements ; Sort the array elements in non - decreasing order ; Initialize count of triangles ; Fix the first element . We need to run till n - 3 as the other two elements are selected from arr [ i + 1. . . n - 1 ] ; Initialize index of the rightmost third element ; Fix the second element ; Find the rightmost element which is smaller than the sum of two fixed elements The important thing to note here is , we use the previous value of k . If value of arr [ i ] + arr [ j - 1 ] was greater than arr [ k ] , then arr [ i ] + arr [ j ] must be greater than k , because the array is sorted . ; Total number of possible triangles that can be formed with the two fixed elements is k - j - 1. The two fixed elements are arr [ i ] and arr [ j ] . All elements between arr [ j + 1 ] / to arr [ k - 1 ] can form a triangle with arr [ i ] and arr [ j ] . One is subtracted from k because k is incremented one extra in above while loop . k will always be greater than j . If j becomes equal to k , then above loop will increment k , because arr [ k ] + arr [ i ] is always greater than arr [ k ] ; Driver program to test above functionarr [ j + 1 ]", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE http : int comp ( const void * a , const void * b ) { return * ( int * ) a > * ( int * ) b ; } int findNumberOfTriangles ( int arr [ ] , int n ) { qsort ( arr , n , sizeof ( arr [ 0 ] ) , comp ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; } int main ( ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Total \u2581 number \u2581 of \u2581 triangles \u2581 possible \u2581 is \u2581 % d \u2581 \" , findNumberOfTriangles ( arr , size ) ) ; return 0 ; }"}
{"text": "Search , insert and delete in an unsorted array | C program to implement linear search in unsorted array ; Function to implement search operation ; Driver Code ; Using a last element as search element", "code": "#include <stdio.h> NEW_LINE int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return -1 ; } int main ( ) { int arr [ ] = { 12 , 34 , 10 , 6 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 40 ; int position = findElement ( arr , n , key ) ; if ( position == - 1 ) printf ( \" Element \u2581 not \u2581 found \" ) ; else printf ( \" Element \u2581 Found \u2581 at \u2581 Position : \u2581 % d \" , position + 1 ) ; return 0 ; }"}
{"text": "Search , insert and delete in an unsorted array | C program to implement insert operation in an unsorted array . ; Inserts a key in arr [ ] of given capacity . n is current size of arr [ ] . This function returns n + 1 if insertion is successful , else n . ; Cannot insert more elements if n is already more than or equal to capcity ; Driver Code ; Inserting key", "code": "#include <stdio.h> NEW_LINE int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; arr [ n ] = key ; return ( n + 1 ) ; } int main ( ) { int arr [ 20 ] = { 12 , 16 , 20 , 40 , 50 , 70 } ; int capacity = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 6 ; int i , key = 26 ; printf ( \" Before Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; n = insertSorted ( arr , n , key , capacity ) ; printf ( \" After Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; return 0 ; }"}
{"text": "Search , insert and delete in an unsorted array | C program to implement delete operation in a unsorted array ; Function to implement search operation ; Function to delete an element ; Find position of element to be deleted ; Deleting element ; Driver code", "code": "#include <stdio.h> NEW_LINE int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; } int deleteElement ( int arr [ ] , int n , int key ) { int pos = findElement ( arr , n , key ) ; if ( pos == - 1 ) { printf ( \" Element \u2581 not \u2581 found \" ) ; return n ; } int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; } int main ( ) { int i ; int arr [ ] = { 10 , 50 , 30 , 40 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 30 ; printf ( \" Array \u2581 before \u2581 deletion STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; n = deleteElement ( arr , n , key ) ; printf ( \" Array after deletion \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; return 0 ; }"}
{"text": "Search , insert and delete in a sorted array | C program to implement binary search in sorted array ; function to implement binary search ; low + ( high - low ) / 2 ; ; Driver Code Let us search 3 in below array", "code": "#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } int main ( ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n , key ; n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; key = 10 ; printf ( \" Index : \u2581 % d STRNEWLINE \" , binarySearch ( arr , 0 , n - 1 , key ) ) ; return 0 ; }"}
{"text": "Search , insert and delete in a sorted array | C program to implement insert operation in an sorted array . ; Inserts a key in arr [ ] of given capacity . n is current size of arr [ ] . This function returns n + 1 if insertion is successful , else n . ; Cannot insert more elements if n is already more than or equal to capcity ; Driver program to test above function ; Inserting key", "code": "#include <stdio.h> NEW_LINE int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; int i ; for ( i = n - 1 ; ( i >= 0 && arr [ i ] > key ) ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; } int main ( ) { int arr [ 20 ] = { 12 , 16 , 20 , 40 , 50 , 70 } ; int capacity = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 6 ; int i , key = 26 ; printf ( \" Before Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; n = insertSorted ( arr , n , key , capacity ) ; printf ( \" After Insertion : \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; return 0 ; }"}
{"text": "Search , insert and delete in a sorted array | C program to implement delete operation in a sorted array ; To search a ley to be deleted ; Function to delete an element ; Find position of element to be deleted ; Deleting element ; Driver code", "code": "#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int low , int high , int key ) ; int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } int deleteElement ( int arr [ ] , int n , int key ) { int pos = binarySearch ( arr , 0 , n - 1 , key ) ; if ( pos == -1 ) { printf ( \" Element \u2581 not \u2581 found \" ) ; return n ; } int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; } int main ( ) { int i ; int arr [ ] = { 10 , 20 , 30 , 40 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 30 ; printf ( \" Array \u2581 before \u2581 deletion STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; n = deleteElement ( arr , n , key ) ; printf ( \" Array after deletion \" for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; }"}
{"text": "Equilibrium index of an array | C program to find equilibrium index of an array ; function to find the equilibrium index ; Check for indexes one by one until an equilibrium index is found ; get left sum ; get right sum ; if leftsum and rightsum are same , then we are done ; return - 1 if no equilibrium index is found ; Driver code", "code": "#include <stdio.h> NEW_LINE int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d \" , equilibrium ( arr , arr_size ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Equilibrium index of an array | C program to find equilibrium index of an array ; function to find the equilibrium index ; initialize sum of whole array ; initialize leftsum ; Find sum of the whole array ; sum is now right sum for index i ; If no equilibrium index found , then return 0 ; Driver code", "code": "#include <stdio.h> NEW_LINE int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return -1 ; } int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" First \u2581 equilibrium \u2581 index \u2581 is \u2581 % d \" , equilibrium ( arr , arr_size ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Ceiling in a sorted array |  ; Function to get index of ceiling of x in arr [ low . . high ] ; If x is smaller than or equal to first element , then return the first element ; Otherwise , linearly search for ceil value ; if x lies between arr [ i ] and arr [ i + 1 ] including arr [ i + 1 ] , then return arr [ i + 1 ] ; If we reach here then x is greater than the last element of the array , return - 1 in this case ; Driver program to check above functions", "code": "#include <stdio.h> NEW_LINE int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return -1 ; } int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) printf ( \" Ceiling \u2581 of \u2581 % d \u2581 doesn ' t \u2581 exist \u2581 in \u2581 array \u2581 \" , x ) ; else printf ( \" ceiling \u2581 of \u2581 % d \u2581 is \u2581 % d \" , x , arr [ index ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Ceiling in a sorted array |  ; Function to get index of ceiling of x in arr [ low . . high ] ; If x is smaller than or equal to the first element , then return the first element ; If x is greater than the last element , then return - 1 ; get the index of middle element of arr [ low . . high ] ; If x is same as middle element , then return mid ; If x is greater than arr [ mid ] , then either arr [ mid + 1 ] is ceiling of x or ceiling lies in arr [ mid + 1. . . high ] ; If x is smaller than arr [ mid ] , then either arr [ mid ] is ceiling of x or ceiling lies in arr [ low ... mid - 1 ] ; Driver program to check above functions", "code": "#include <stdio.h> NEW_LINE int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return -1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 20 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) printf ( \" Ceiling \u2581 of \u2581 % d \u2581 doesn ' t \u2581 exist \u2581 in \u2581 array \u2581 \" , x ) ; else printf ( \" ceiling \u2581 of \u2581 % d \u2581 is \u2581 % d \" , x , arr [ index ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Two Pointers Technique | Naive solution to find if there is a pair in A [ 0. . N - 1 ] with given sum . ; as equal i and j means same element ; pair exists ; as the array is sorted ; No pair found with given sum . ; Driver Code ; Function call", "code": "#include <stdio.h> NEW_LINE int isPairSum ( int A [ ] , int N , int X ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; if ( A [ i ] + A [ j ] == X ) return true ; if ( A [ i ] + A [ j ] > X ) break ; } } return 0 ; } int main ( ) { int arr [ ] = { 3 , 5 , 9 , 2 , 8 , 10 , 11 } ; int val = 17 ; int arrSize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d \" , isPairSum ( arr , arrSize , val ) ) ; return 0 ; }"}
{"text": "Two Pointers Technique |  ; Two pointer technique based solution to find if there is a pair in A [ 0. . N - 1 ] with a given sum . ; represents first pointer ; represents second pointer ; If we find a pair ; If sum of elements at current pointers is less , we move towards higher values by doing i ++ ; If sum of elements at current pointers is more , we move towards lower values by doing j -- ; Driver code ; array declaration ; value to search ; size of the array ; Function call", "code": "#include <stdio.h> NEW_LINE int isPairSum ( int A [ ] , int N , int X ) { int i = 0 ; int j = N - 1 ; while ( i < j ) { if ( A [ i ] + A [ j ] == X ) return 1 ; else if ( A [ i ] + A [ j ] < X ) i ++ ; else j -- ; } return 0 ; } int main ( ) { int arr [ ] = { 3 , 5 , 9 , 2 , 8 , 10 , 11 } ; int val = 17 ; int arrSize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d \" , isPairSum ( arr , arrSize , val ) ) ; return 0 ; }"}
{"text": "Assembly Line Scheduling | DP | A C program to find minimum possible time by the car chassis to complete ; Utility function to find minimum of two numbers ; time taken to leave first station in line 1 ; time taken to leave first station in line 2 ; Fill tables T1 [ ] and T2 [ ] using the above given recursive relations ; Consider exit times and retutn minimum ; Driver Code", "code": "#include <stdio.h> NEW_LINE #define NUM_LINE  2 NEW_LINE #define NUM_STATION  4 NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; } int carAssembly ( int a [ ] [ NUM_STATION ] , int t [ ] [ NUM_STATION ] , int * e , int * x ) { int T1 [ NUM_STATION ] , T2 [ NUM_STATION ] , i ; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; } int main ( ) { int a [ ] [ NUM_STATION ] = { { 4 , 5 , 3 , 2 } , { 2 , 10 , 1 , 4 } } ; int t [ ] [ NUM_STATION ] = { { 0 , 7 , 4 , 5 } , { 0 , 9 , 2 , 8 } } ; int e [ ] = { 10 , 12 } , x [ ] = { 18 , 7 } ; printf ( \" % d \" , carAssembly ( a , t , e , x ) ) ; return 0 ; }"}
{"text": "Minimum insertions to form a palindrome | DP | A Dynamic Programming based program to find minimum number insertions needed to make a string palindrome ; A utility function to find minimum of two integers ; A DP function to find minimum number of insertions ; Create a table of size n * n . table [ i ] [ j ] will store minimum number of insertions needed to convert str [ i . . j ] to a palindrome . ; Fill the table ; Return minimum number of insertions for str [ 0. . n - 1 ] ; Driver program to test above function .", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; } int findMinInsertionsDP ( char str [ ] , int n ) { int table [ n ] [ n ] , l , h , gap ; memset ( table , 0 , sizeof ( table ) ) ; for ( gap = 1 ; gap < n ; ++ gap ) for ( l = 0 , h = gap ; h < n ; ++ l , ++ h ) table [ l ] [ h ] = ( str [ l ] == str [ h ] ) ? table [ l + 1 ] [ h - 1 ] : ( min ( table [ l ] [ h - 1 ] , table [ l + 1 ] [ h ] ) + 1 ) ; return table [ 0 ] [ n - 1 ] ; } int main ( ) { char str [ ] = \" geeks \" ; printf ( \" % d \" , findMinInsertionsDP ( str , strlen ( str ) ) ) ; return 0 ; }"}
{"text": "Largest Independent Set Problem | DP | A naive recursive implementation of Largest Independent Set problem ; A utility function to find max of two integers ; A binary tree node has data , pointer to left child and a pointer to right child ; The function returns size of the largest independent set in a given binary tree ; Calculate size excluding the current node ; Calculate size including the current node ; Return the maximum of two sizes ; A utility function to create a node ; Driver program to test above functions ; Let us construct the tree given in the above diagram", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int max ( int x , int y ) { return ( x > y ) ? x : y ; } struct node { int data ; struct node * left , * right ; } ; int LISS ( struct node * root ) { if ( root == NULL ) return 0 ; int size_excl = LISS ( root -> left ) + LISS ( root -> right ) ; int size_incl = 1 ; if ( root -> left ) size_incl += LISS ( root -> left -> left ) + LISS ( root -> left -> right ) ; if ( root -> right ) size_incl += LISS ( root -> right -> left ) + LISS ( root -> right -> right ) ; return max ( size_incl , size_excl ) ; } struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printf ( \" Size \u2581 of \u2581 the \u2581 Largest \u2581 Independent \u2581 Set \u2581 is \u2581 % d \u2581 \" , LISS ( root ) ) ; return 0 ; }"}
{"text": "Maximum Length Chain of Pairs | DP |  ; This function assumes that arr [ ] is sorted in increasing order according the first ( or smaller ) values in pairs . ; Initialize MCL ( max chain length ) values for all indexes ; Compute optimized chain length values in bottom up manner ; Pick maximum of all MCL values ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct pair { int a ; int b ; } ; int maxChainLength ( struct pair arr [ ] , int n ) { int i , j , max = 0 ; int * mcl = ( int * ) malloc ( sizeof ( int ) * n ) ; for ( i = 0 ; i < n ; i ++ ) mcl [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] . a > arr [ j ] . b && mcl [ i ] < mcl [ j ] + 1 ) mcl [ i ] = mcl [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < mcl [ i ] ) max = mcl [ i ] ; free ( mcl ) ; return max ; } int main ( ) { struct pair arr [ ] = { { 5 , 24 } , { 15 , 25 } , { 27 , 40 } , { 50 , 60 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Length \u2581 of \u2581 maximum \u2581 size \u2581 chain \u2581 is \u2581 % d STRNEWLINE \" , maxChainLength ( arr , n ) ) ; return 0 ; }"}
{"text": "Palindrome Partitioning | DP | Dynamic Programming Solution for Palindrome Partitioning Problem ; Returns the minimum number of cuts needed to partition a string such that every part is a palindrome ; Get the length of the string ; Create two arrays to build the solution in bottom up manner C [ i ] [ j ] = Minimum number of cuts needed for palindrome partitioning of substring str [ i . . j ] P [ i ] [ j ] = true if substring str [ i . . j ] is palindrome , else false Note that C [ i ] [ j ] is 0 if P [ i ] [ j ] is true ; different looping variables ; Every substring of length 1 is a palindrome ; L is substring length . Build the solution in bottom up manner by considering all substrings of length starting from 2 to n . The loop structure is same as Matrix Chain Multiplication problem ( See https : www . geeksforgeeks . org / matrix - chain - multiplication - dp - 8 / ) ; For substring of length L , set different possible starting indexes ; Set ending index ; If L is 2 , then we just need to compare two characters . Else need to check two corner characters and value of P [ i + 1 ] [ j - 1 ] ; IF str [ i . . j ] is palindrome , then C [ i ] [ j ] is 0 ; Make a cut at every possible location starting from i to j , and get the minimum cost cut . ; Return the min cut value for complete string . i . e . , str [ 0. . n - 1 ] ; Driver program to test above function", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return ( a < b ) ? a : b ; } int minPalPartion ( char * str ) { int n = strlen ( str ) ; int C [ n ] [ n ] ; bool P [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] ) ; else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; } int main ( ) { char str [ ] = \" ababbbabbababa \" ; printf ( \" Min \u2581 cuts \u2581 needed \u2581 for \u2581 Palindrome \u2581 Partitioning \u2581 is \u2581 % d \" , minPalPartion ( str ) ) ; return 0 ; }"}
{"text": "Boyer Moore Algorithm for Pattern Searching | C Program for Bad Character Heuristic of Boyer Moore String Matching Algorithm ; A utility function to get maximum of two integers ; The preprocessing function for Boyer Moore 's bad character heuristic ; Initialize all occurrences as - 1 ; Fill the actual value of last occurrence of a character ; A pattern searching function that uses Bad Character Heuristic of Boyer Moore Algorithm ; Fill the bad character array by calling the preprocessing function badCharHeuristic ( ) for given pattern ; s is shift of the pattern with respect to text ; Keep reducing index j of pattern while characters of pattern and text are matching at this shift s ; If the pattern is present at current shift , then index j will become - 1 after the above loop ; Shift the pattern so that the next character in text aligns with the last occurrence of it in pattern . The condition s + m < n is necessary for the case when pattern occurs at the end of text ; Shift the pattern so that the bad character in text aligns with the last occurrence of it in pattern . The max function is used to make sure that we get a positive shift . We may get a negative shift if the last occurrence of bad character in pattern is on the right side of the current character . ; Driver program to test above function", "code": "# include <limits.h> NEW_LINE # include <string.h> NEW_LINE # include <stdio.h> NEW_LINE # define NO_OF_CHARS  256 NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } void badCharHeuristic ( char * str , int size , int badchar [ NO_OF_CHARS ] ) { int i ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) badchar [ i ] = -1 ; for ( i = 0 ; i < size ; i ++ ) badchar [ ( int ) str [ i ] ] = i ; } void search ( char * txt , char * pat ) { int m = strlen ( pat ) ; int n = strlen ( txt ) ; int badchar [ NO_OF_CHARS ] ; badCharHeuristic ( pat , m , badchar ) ; int s = 0 ; while ( s <= ( n - m ) ) { int j = m - 1 ; while ( j >= 0 && pat [ j ] == txt [ s + j ] ) j -- ; if ( j < 0 ) { printf ( \" pattern occurs at shift = % d \" , s ) ; s += ( s + m < n ) ? m - badchar [ txt [ s + m ] ] : 1 ; } else s += max ( 1 , j - badchar [ txt [ s + j ] ] ) ; } } int main ( ) { char txt [ ] = \" ABAAABCD \" ; char pat [ ] = \" ABC \" ; search ( txt , pat ) ; return 0 ; }"}
{"text": "Difference between sums of odd level and even level nodes of a Binary Tree | A recursive program to find difference between sum of nodes at odd level and sum at even level ; Binary Tree node ; A utility function to allocate a new tree node with given data ; The main function that return difference between odd and even level nodes ; Base case ; Difference for root is root 's data - difference for  left subtree - difference for right subtree ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int getLevelDiff ( struct node * root ) { if ( root == NULL ) return 0 ; return root -> data - getLevelDiff ( root -> left ) - getLevelDiff ( root -> right ) ; } int main ( ) { struct node * root = newNode ( 5 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; root -> left -> right -> left = newNode ( 3 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 7 ) ; printf ( \" % d \u2581 is \u2581 the \u2581 required \u2581 difference STRNEWLINE \" , getLevelDiff ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Root to leaf path sum equal to a given number |  ; A binary tree node has data , pointer to left child and a pointer to right child ; Given a tree and a sum , return true if there is a path from the root down to a leaf , such that adding up all the values along the path equals the given sum . Strategy : subtract the node value from the sum when recurring down , and check to see if the sum is 0 when you run out of tree . ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver Code ; Constructed binary tree is 10 / \\ 8 2 / \\ / 3 5 2", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define bool  int NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; bool hasPathSum ( struct node * node , int sum ) { if ( node == NULL ) { return ( sum == 0 ) ; } else { bool ans = 0 ; int subSum = sum - node -> data ; if ( subSum == 0 && node -> left == NULL && node -> right == NULL ) return 1 ; if ( node -> left ) ans = ans || hasPathSum ( node -> left , subSum ) ; if ( node -> right ) ans = ans || hasPathSum ( node -> right , subSum ) ; return ans ; } } struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { int sum = 21 ; struct node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ; root -> left -> right = newnode ( 5 ) ; root -> right -> left = newnode ( 2 ) ; if ( hasPathSum ( root , sum ) ) printf ( \" There \u2581 is \u2581 a \u2581 root - to - leaf \u2581 path \u2581 with \u2581 sum \u2581 % d \" , sum ) ; else printf ( \" There \u2581 is \u2581 no \u2581 root - to - leaf \u2581 path \u2581 with \u2581 sum \u2581 % d \" , sum ) ; getchar ( ) ; return 0 ; }"}
{"text": "Sum of all the numbers that are formed from root to leaf paths | C program to find sum of all paths from root to leaves ; function to allocate new node with given data ; Returns sum of all root to leaf paths . The first parameter is root of current subtree , the second parameter is value of the number formed by nodes from root to this node ; Base case ; Update val ; if current node is leaf , return the current value of val ; recur sum of values for left and right subtree ; A wrapper function over treePathsSumUtil ( ) ; Pass the initial value as 0 as there is nothing above root ; Driver function to test the above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int treePathsSumUtil ( struct node * root , int val ) { if ( root == NULL ) return 0 ; val = ( val * 10 + root -> data ) ; if ( root -> left == NULL && root -> right == NULL ) return val ; return treePathsSumUtil ( root -> left , val ) + treePathsSumUtil ( root -> right , val ) ; } int treePathsSum ( struct node * root ) { return treePathsSumUtil ( root , 0 ) ; } int main ( ) { struct node * root = newNode ( 6 ) ; root -> left = newNode ( 3 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 2 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 4 ) ; root -> left -> right -> left = newNode ( 7 ) ; root -> left -> right -> right = newNode ( 4 ) ; printf ( \" Sum \u2581 of \u2581 all \u2581 paths \u2581 is \u2581 % d \" , treePathsSum ( root ) ) ; return 0 ; }"}
{"text": "Lowest Common Ancestor in a Binary Tree | Set 2 ( Using Parent Pointer ) | C ++ program to find lowest common ancestor using parent pointer ; A Tree Node ; A utility function to create a new BST node ; A utility function to insert a new node with given key in Binary Search Tree ; If the tree is empty , return a new node ; Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; To find LCA of nodes n1 and n2 in Binary Tree ; Creata a map to store ancestors of n1 ; Insert n1 and all its ancestors in map ; Check if n2 or any of its ancestors is in map . ; Driver method to test above functions", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { Node * left , * right , * parent ; int key ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> parent = temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) { node -> left = insert ( node -> left , key ) ; node -> left -> parent = node ; } else if ( key > node -> key ) { node -> right = insert ( node -> right , key ) ; node -> right -> parent = node ; } return node ; } Node * LCA ( Node * n1 , Node * n2 ) { map < Node * , bool > ancestors ; while ( n1 != NULL ) { ancestors [ n1 ] = true ; n1 = n1 -> parent ; } while ( n2 != NULL ) { if ( ancestors . find ( n2 ) != ancestors . end ( ) ) return n2 ; n2 = n2 -> parent ; } return NULL ; } int main ( void ) { Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 8 ) ; root = insert ( root , 22 ) ; root = insert ( root , 4 ) ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 14 ) ; Node * n1 = root -> left -> right -> left ; Node * n2 = root -> left ; Node * lca = LCA ( n1 , n2 ) ; printf ( \" LCA \u2581 of \u2581 % d \u2581 and \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , n1 -> key , n2 -> key , lca -> key ) ; return 0 ; }"}
{"text": "Chocolate Distribution Problem | Set 2 | C program for above approach ; Function to return minimum number of chocolates ; decreasing sequence ; add the chocolates received by that person ; end point of decreasing sequence ; val = 1 ; reset value at that index ; increasing sequence ; flat sequence ; add value of chocolates at position n - 1 ; Helper function to get sum of decreasing sequence ; value obtained from decreasing sequence also the count of values in the sequence ; assigning max of values obtained from increasing and decreasing sequences ; sum of count - 1 values & peak value sum of natural numbers : ( n * ( n + 1 ) ) / 2 ; Driver code", "code": "#include <stdio.h> NEW_LINE int minChocolates ( int a [ ] , int n ) { int i = 0 , j = 0 ; int res = 0 , val = 1 ; while ( j < n - 1 ) { if ( a [ j ] > a [ j + 1 ] ) { j += 1 ; continue ; } if ( i == j ) res += val ; else { res += get_sum ( val , i , j ) ; } if ( a [ j ] < a [ j + 1 ] ) val += 1 ; else val = 1 ; j += 1 ; i = j ; } if ( i == j ) res += val ; else res += get_sum ( val , i , j ) ; return res ; } int get_sum ( int peak , int start , int end ) { int count = end - start + 1 ; peak = ( peak > count ) ? peak : count ; int s = peak + ( ( ( count - 1 ) * count ) >> 1 ) ; return s ; } int main ( ) { int a [ ] = { 5 , 5 , 4 , 3 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printf ( \" Minimum \u2581 number \u2581 of \u2581 chocolates \u2581 = \u2581 % d \" , minChocolates ( a , n ) ) ; return 0 ; }"}
{"text": "Program to find sum of harmonic series | C program to find sum of harmonic series ; Function to return sum of harmonic series ; Driver code", "code": "#include <stdio.h> NEW_LINE double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } int main ( ) { int n = 5 ; printf ( \" Sum \u2581 is \u2581 % f \" , sum ( n ) ) ; return 0 ; }"}
{"text": "Find nth term of the series 5 2 13 41 | C program to find nth term of the series 5 2 13 41 ; function to calculate nth term of the series ; to store the nth term of series ; if n is even number ; if n is odd number ; return nth term ; Driver code", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE int nthTermOfTheSeries ( int n ) { int nthTerm ; if ( n % 2 == 0 ) nthTerm = pow ( n - 1 , 2 ) + n ; else nthTerm = pow ( n + 1 , 2 ) + n ; return nthTerm ; } int main ( ) { int n ; n = 8 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 12 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 102 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 999 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; n = 9999 ; printf ( \" % d STRNEWLINE \" , nthTermOfTheSeries ( n ) ) ; return 0 ; }"}
{"text": "Logarithm | C program to find log ( n ) using Recursion ; Driver code", "code": "#include <stdio.h> NEW_LINE unsigned int Log2n ( unsigned int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; } int main ( ) { unsigned int n = 32 ; printf ( \" % u \" , Log2n ( n ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find amount to be added to achieve target ratio in a given mixture | C program to find amount of water to be added to achieve given target ratio . ; Driver code", "code": "#include <stdio.h> NEW_LINE float findAmount ( float X , float W , float Y ) { return ( X * ( Y - W ) ) / ( 100 - Y ) ; } int main ( ) { float X = 100 , W = 50 , Y = 60 ; printf ( \" Water \u2581 to \u2581 be \u2581 added \u2581 = \u2581 % .2f \u2581 \" , findAmount ( X , W , Y ) ) ; return 0 ; }"}
{"text": "Average of Squares of Natural Numbers | C program to get the Average of Square of first n natural numbers ; Function to get the average ; Driver Code", "code": "#include <stdio.h> NEW_LINE float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } int main ( ) { int n = 10 ; printf ( \" % f \" , AvgofSquareN ( n ) ) ; return 0 ; }"}
{"text": "Program to print triangular number series till n | C Program to find Triangular Number Series ; Function to find triangular number ; Driven Function", "code": "#include <stdio.h> NEW_LINE void triangular_series ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) printf ( \" \u2581 % d \u2581 \" , i * ( i + 1 ) / 2 ) ; } int main ( ) { int n = 5 ; triangular_series ( n ) ; return 0 ; }"}
{"text": "Sum of all divisors from 1 to n | C program to find sum of all divisor of number up to ' n ' ; Utility function to find sum of all divisor of number up to ' n ' ; Driver code", "code": "#include <stdio.h> NEW_LINE int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; } int main ( ) { int n = 4 ; printf ( \" % d STRNEWLINE \" , divisorSum ( n ) ) ; n = 5 ; printf ( \" % d \" , divisorSum ( n ) ) ; return 0 ; }"}
{"text": "Sum of the Series 1 + x / 1 + x ^ 2 / 2 + x ^ 3 / 3 + . . + x ^ n / n | C program to find sum of series 1 + x / 1 + x ^ 2 / 2 + x ^ 3 / 3 + ... . + x ^ n / n ; Code to print the sum of the series ; Driver code", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE double sum ( int x , int n ) { double i , total = 1.0 ; for ( i = 1 ; i <= n ; i ++ ) total = total + ( pow ( x , i ) / i ) ; return total ; } int main ( ) { int x = 2 ; int n = 5 ; printf ( \" % .2f \" , sum ( x , n ) ) ; return 0 ; }"}
{"text": "Find whether a given integer is a power of 3 or not | C ++ program to check if a number is power of 3 or not . ; Returns true if n is power of 3 , else false ; The maximum power of 3 value that integer can hold is 1162261467 ( 3 ^ 19 ) . ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdbool.h> NEW_LINE bool check ( int n ) { if ( n <= 0 ) return false ; return 1162261467 % n == 0 ; } int main ( ) { int n = 9 ; if ( check ( n ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Program for Perrin numbers | Optimized C program for n 'th perrin number ; Driver code", "code": "#include <stdio.h> NEW_LINE int per ( int n ) { int a = 3 , b = 0 , c = 2 , i ; int m ; if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return c ; while ( n > 2 ) { m = a + b ; a = b ; b = c ; c = m ; n -- ; } return m ; } int main ( ) { int n = 9 ; printf ( \" % d \" , per ( n ) ) ; return 0 ; }"}
{"text": "Check if count of divisors is even or odd | Naive Solution to find if count of divisors is even or odd ; Function to count the divisors ; Initialize count of divisors ; Note that this loop runs till square root ; If divisors are equal increment count by one Otherwise increment count by 2 ; Driver Code", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE void countDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i <= sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) count += ( n / i == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) printf ( \" Even STRNEWLINE \" ) ; else printf ( \" Odd STRNEWLINE \" ) ; } int main ( ) { printf ( \" The \u2581 count \u2581 of \u2581 divisor : \u2581 \" ) ; countDivisors ( 10 ) ; return 0 ; }"}
{"text": "How to avoid overflow in modular multiplication ? | A Simple solution that causes overflow when value of ( a % mod ) * ( b % mod ) becomes more than maximum value of long long int", "code": "#define ll  long long NEW_LINE ll multiply ( ll a , ll b , ll mod ) { return ( ( a % mod ) * ( b % mod ) ) % mod ; }"}
{"text": "Count number of squares in a rectangle | C program to count squares in a rectangle of size m x n ; Returns count of all squares in a rectangle of size m x n ; If n is smaller , swap m and n ; Now n is greater dimension , apply formula ; Driver Code", "code": "#include <stdio.h> NEW_LINE int countSquares ( int m , int n ) { int temp ; if ( n < m ) { temp = n ; n = m ; m = temp ; } return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; } int main ( ) { int m = 4 , n = 3 ; printf ( \" Count \u2581 of \u2581 squares \u2581 is \u2581 % d \" , countSquares ( m , n ) ) ; }"}
{"text": "Program to find sum of series 1 + 1 / 2 + 1 / 3 + 1 / 4 + . . + 1 / n | C program to find sum of series ; Function to return sum of 1 / 1 + 1 / 2 + 1 / 3 + . . + 1 / n ; Driver code", "code": "#include <stdio.h> NEW_LINE double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } int main ( ) { int n = 5 ; printf ( \" Sum \u2581 is \u2581 % f \" , sum ( n ) ) ; return 0 ; }"}
{"text": "Program to find GCD or HCF of two numbers | C program to find GCD of two numbers ; Recursive function to return gcd of a and b ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int main ( ) { int a = 98 , b = 56 ; printf ( \" GCD \u2581 of \u2581 % d \u2581 and \u2581 % d \u2581 is \u2581 % d \u2581 \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "Print all sequences of given length | C ++ program of above approach ; A utility function that prints a given arr [ ] of length size ; The core function that recursively generates and prints all sequences of length k ; A function that uses printSequencesRecur ( ) to prints all sequences from 1 , 1 , . .1 to n , n , . . n ; Driver Program to test above functions", "code": "#include <stdio.h> NEW_LINE void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; return ; } void printSequencesRecur ( int arr [ ] , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } } void printSequences ( int n , int k ) { int * arr = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; } int main ( ) { int n = 3 ; int k = 2 ; printSequences ( n , k ) ; return 0 ; }"}
{"text": "Check if a number is multiple of 5 without using / and % operators | C program for the above approach ; assumes that n is a positive integer ; Driver Code", "code": "#include <stdio.h> NEW_LINE bool isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; } int main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) printf ( \" % d \u2581 is \u2581 multiple \u2581 of \u2581 5 STRNEWLINE \" , n ) ; else printf ( \" % d \u2581 is \u2581 not \u2581 a \u2581 multiple \u2581 of \u2581 5 STRNEWLINE \" , n ) ; return 0 ; }"}
{"text": "Count total bits in a number | Function to get no of bits in binary representation of positive integer ; Driver program", "code": "#include <stdio.h> NEW_LINE unsigned int countBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; } int main ( ) { int i = 65 ; printf ( \" % d \" , countBits ( i ) ) ; return 0 ; }"}
{"text": "Find the n | C program to find n - th number whose binary representation is palindrome . ; Finds if the kth bit is set in the binary representation ; Returns the position of leftmost set bit in the binary representation ; Finds whether the integer in binary representation is palindrome or not ; One by one compare bits ; Compare left and right bits and converge ; Start from 1 , traverse through all the integers ; If we reach n , break the loop ; Driver code ; Function Call", "code": "#include <stdio.h> NEW_LINE #define INT_MAX  2147483647 NEW_LINE int isKthBitSet ( int x , int k ) { return ( x & ( 1 << ( k - 1 ) ) ) ? 1 : 0 ; } int leftmostSetBit ( int x ) { int count = 0 ; while ( x ) { count ++ ; x = x >> 1 ; } return count ; } int isBinPalindrome ( int x ) { int l = leftmostSetBit ( x ) ; int r = 1 ; while ( l > r ) { if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; } int findNthPalindrome ( int n ) { int pal_count = 0 ; int i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) ) { pal_count ++ ; } if ( pal_count == n ) break ; } return i ; } int main ( ) { int n = 9 ; printf ( \" % d \" , findNthPalindrome ( n ) ) ; }"}
{"text": "Bitwise Operators in C / C ++ | C Program to demonstrate use of bitwise operators ; a = 5 ( 00000101 ) , b = 9 ( 00001001 ) ; The result is 00000001 ; The result is 00001101 ; The result is 00001100 ; The result is 11111010 ; The result is 00010010 ; The result is 00000100", "code": "#include <stdio.h> NEW_LINE int main ( ) { unsigned char a = 5 , b = 9 ; printf ( \" a \u2581 = \u2581 % d , \u2581 b \u2581 = \u2581 % d STRNEWLINE \" , a , b ) ; printf ( \" a & b \u2581 = \u2581 % d STRNEWLINE \" , a & b ) ; printf ( \" a \u2581 b \u2581 = \u2581 % d STRNEWLINE \" , a b ) ; printf ( \" a ^ b \u2581 = \u2581 % d STRNEWLINE \" , a ^ b ) ; printf ( \" ~ a \u2581 = \u2581 % d STRNEWLINE \" , a = ~ a ) ; printf ( \" b < < 1 \u2581 = \u2581 % d STRNEWLINE \" , b << 1 ) ; printf ( \" b > > 1 \u2581 = \u2581 % d STRNEWLINE \" , b >> 1 ) ; return 0 ; }"}
{"text": "Convert a given temperature to another system based on given boiling and freezing points | C program for above approach ; Function to return temperature in the second thermometer ; Calculate the temperature ; Driver Code", "code": "#include <stdio.h> NEW_LINE double temp_convert ( int F1 , int B1 , int F2 , int B2 , int T ) { float t2 ; t2 = F2 + ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; } int main ( ) { int F1 = 0 , B1 = 100 ; int F2 = 32 , B2 = 212 ; int T = 37 ; float t2 ; printf ( \" % .2f \" , temp_convert ( F1 , B1 , F2 , B2 , T ) ) ; return 0 ; }"}
{"text": "Write a Program to Find the Maximum Depth or Height of a Tree |  ; A binary tree node has data , pointer to left child and a pointer to right child ; Compute the \" maxDepth \" of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node . ; compute the depth of each subtree ; use the larger one ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int maxDepth ( struct node * node ) { if ( node == NULL ) return 0 ; else { int lDepth = maxDepth ( node -> left ) ; int rDepth = maxDepth ( node -> right ) ; if ( lDepth > rDepth ) return ( lDepth + 1 ) ; else return ( rDepth + 1 ) ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Height \u2581 of \u2581 tree \u2581 is \u2581 % d \" , maxDepth ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "How to determine if a binary tree is height | C program to check if a tree is height - balanced or not ; A binary tree node has data , pointer to left child and a pointer to right child ; Returns the height of a binary tree ; Returns true if binary tree with root as root is height - balanced ; for height of left subtree ; for height of right subtree ; If tree is empty then return true ; Get the height of left and right sub trees ; If we reach here then tree is not height - balanced ; returns maximum of two integers ; The function Compute the \" height \" of a tree . Height is the number of nodes along the longest path from the root node down to the farthest leaf node . ; base case tree is empty ; If tree is not empty then height = 1 + max of left height and right heights ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define bool  int NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int height ( struct node * node ) ; bool isBalanced ( struct node * root ) { int lh ; int rh ; if ( root == NULL ) return 1 ; lh = height ( root -> left ) ; rh = height ( root -> right ) ; if ( abs ( lh - rh ) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ) ) return 1 ; return 0 ; } int max ( int a , int b ) { return ( a >= b ) ? a : b ; } int height ( struct node * node ) { if ( node == NULL ) return 0 ; return 1 + max ( height ( node -> left ) , height ( node -> right ) ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> left -> left = newNode ( 8 ) ; if ( isBalanced ( root ) ) printf ( \" Tree \u2581 is \u2581 balanced \" ) ; else printf ( \" Tree \u2581 is \u2581 not \u2581 balanced \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Diameter of a Binary Tree | Recursive optimized C program to find the diameter of a Binary Tree ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; returns max of two integers ; The function Compute the \" height \" of a tree . Height is the number f nodes along the longest path from the root node down to the farthest leaf node . ; base case tree is empty ; If tree is not empty then height = 1 + max of left height and right heights ; Function to get diameter of a binary tree ; base case where tree is empty ; get the height of left and right sub - trees ; get the diameter of left and right sub - trees ; Return max of following three 1 ) Diameter of left subtree 2 ) Diameter of right subtree 3 ) Height of left subtree + height of right subtree + 1 ; Driver Code ; Constructed binary tree is 1 / \\ 2 3 / \\ 4 5 ; Function Call", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } int height ( struct node * node ) { if ( node == NULL ) return 0 ; return 1 + max ( height ( node -> left ) , height ( node -> right ) ) ; } int diameter ( struct node * tree ) { if ( tree == NULL ) return 0 ; int lheight = height ( tree -> left ) ; int rheight = height ( tree -> right ) ; int ldiameter = diameter ( tree -> left ) ; int rdiameter = diameter ( tree -> right ) ; return max ( lheight + rheight + 1 , max ( ldiameter , rdiameter ) ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Diameter \u2581 of \u2581 the \u2581 given \u2581 binary \u2581 tree \u2581 is \u2581 % d STRNEWLINE \" , diameter ( root ) ) ; return 0 ; }"}
{"text": "Find if possible to visit every nodes in given Graph exactly once based on given conditions | C ++ program for above approach . ; Function to find print path ; If a [ 0 ] is 1 ; Printing path ; Seeking for a [ i ] = 0 and a [ i + 1 ] = 1 ; Printing path ; If a [ N - 1 ] = 0 ; Driver Code ; Given Input ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findpath ( int N , int a [ ] ) { if ( a [ 0 ] ) { printf ( \" % d \u2581 \" , N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d \u2581 \" , i ) ; return ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ! a [ i ] && a [ i + 1 ] ) { for ( int j = 1 ; j <= i ; j ++ ) printf ( \" % d \u2581 \" , j ) ; printf ( \" % d \u2581 \" , N + 1 ) ; for ( int j = i + 1 ; j <= N ; j ++ ) printf ( \" % d \u2581 \" , j ) ; return ; } } for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d \u2581 \" , i ) ; printf ( \" % d \u2581 \" , N + 1 ) ; } int main ( ) { int N = 3 , arr [ ] = { 0 , 1 , 0 } ; findpath ( N , arr ) ; }"}
{"text": "Find depth of the deepest odd level leaf node | C program to find depth of the deepest odd level leaf node ; A utility function to find maximum of two integers ; A Binary Tree node ; A utility function to allocate a new tree node ; A recursive function to find depth of the deepest odd level leaf ; Base Case ; If this node is a leaf and its level is odd , return its level ; If not leaf , return the maximum value from left and right subtrees ; Main function which calculates the depth of deepest odd level leaf . This function mainly uses depthOfOddLeafUtil ( ) ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int max ( int x , int y ) { return ( x > y ) ? x : y ; } struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } int depthOfOddLeafUtil ( struct Node * root , int level ) { if ( root == NULL ) return 0 ; if ( root -> left == NULL && root -> right == NULL && level & 1 ) return level ; return max ( depthOfOddLeafUtil ( root -> left , level + 1 ) , depthOfOddLeafUtil ( root -> right , level + 1 ) ) ; } int depthOfOddLeaf ( struct Node * root ) { int level = 1 , depth = 0 ; return depthOfOddLeafUtil ( root , level ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 8 ) ; root -> right -> left -> right -> left = newNode ( 9 ) ; root -> right -> right -> right -> right = newNode ( 10 ) ; root -> right -> right -> right -> right -> left = newNode ( 11 ) ; printf ( \" % d \u2581 is \u2581 the \u2581 required \u2581 depth STRNEWLINE \" , depthOfOddLeaf ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Reorder an array such that sum of left half is not equal to sum of right half | C program for the above approach ; A comparator function used by qsort ; Function to print the required reordering of array if possible ; Sort the array in increasing order ; If all elements are equal , then it is not possible ; Else print the sorted array arr [ ] ; Driver Code ; Given array ; Function call", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int compare ( const void * a , const void * b ) { return ( * ( int * ) a - * ( int * ) b ) ; } void printArr ( int arr [ ] , int n ) { qsort ( arr , n , sizeof ( int ) , compare ) ; if ( arr [ 0 ] == arr [ n - 1 ] ) { printf ( \" No STRNEWLINE \" ) ; } else { printf ( \" Yes STRNEWLINE \" ) ; for ( int i = 0 ; i < n ; i ++ ) { printf ( \" % d \u2581 \" , arr [ i ] ) ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 1 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printArr ( arr , N ) ; return 0 ; }"}
{"text": "Maximum width of a binary tree | C program to calculate width of binary tree ; A binary tree node has data , pointer to left child and a pointer to right child ; Function protoypes ; Function to get the maximum width of a binary tree ; Get width of each level and compare the width with maximum width so far ; Get width of a given level ; Compute the \" height \" of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node . ; compute the height of each subtree ; use the larger one ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver code ; Constructed binary tree is : 1 / \\ 2 3 / \\ \\ 4 5 8 / \\ 6 7 ; Function call", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int getWidth ( struct node * root , int level ) ; int height ( struct node * node ) ; struct node * newNode ( int data ) ; int getMaxWidth ( struct node * root ) { int maxWidth = 0 ; int width ; int h = height ( root ) ; int i ; for ( i = 1 ; i <= h ; i ++ ) { width = getWidth ( root , i ) ; if ( width > maxWidth ) maxWidth = width ; } return maxWidth ; } int getWidth ( struct node * root , int level ) { if ( root == NULL ) return 0 ; if ( level == 1 ) return 1 ; else if ( level > 1 ) return getWidth ( root -> left , level - 1 ) + getWidth ( root -> right , level - 1 ) ; } int height ( struct node * node ) { if ( node == NULL ) return 0 ; else { int lHeight = height ( node -> left ) ; int rHeight = height ( node -> right ) ; return ( lHeight > rHeight ) ? ( lHeight + 1 ) : ( rHeight + 1 ) ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 6 ) ; root -> right -> right -> right = newNode ( 7 ) ; printf ( \" Maximum \u2581 width \u2581 is \u2581 % d \u2581 STRNEWLINE \" , getMaxWidth ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Maximum width of a binary tree | C program to calculate width of binary tree ; A binary tree node has data , pointer to left child and a pointer to right child ; A utility function to get height of a binary tree ; Function to get the maximum width of a binary tree ; Create an array that will store count of nodes at each level ; Fill the count array using preorder traversal ; Return the maximum value from count array ; A function that fills count array with count of nodes at every level of given binary tree ; Compute the \" height \" of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node . ; compute the height of each subtree ; use the larger one ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Return the maximum value from count array ; Driver program to test above functions ; Constructed bunary tree is : 1 / \\ 2 3 / \\ \\ 4 5 8 / \\ 6 7", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int height ( struct node * node ) ; struct node * newNode ( int data ) ; int getMax ( int arr [ ] , int n ) ; void getMaxWidthRecur ( struct node * root , int count [ ] , int level ) ; int getMaxWidth ( struct node * root ) { int width ; int h = height ( root ) ; int * count = ( int * ) calloc ( sizeof ( int ) , h ) ; int level = 0 ; getMaxWidthRecur ( root , count , level ) ; return getMax ( count , h ) ; } void getMaxWidthRecur ( struct node * root , int count [ ] , int level ) { if ( root ) { count [ level ] ++ ; getMaxWidthRecur ( root -> left , count , level + 1 ) ; getMaxWidthRecur ( root -> right , count , level + 1 ) ; } } int height ( struct node * node ) { if ( node == NULL ) return 0 ; else { int lHeight = height ( node -> left ) ; int rHeight = height ( node -> right ) ; return ( lHeight > rHeight ) ? ( lHeight + 1 ) : ( rHeight + 1 ) ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 6 ) ; root -> right -> right -> right = newNode ( 7 ) ; printf ( \" Maximum \u2581 width \u2581 is \u2581 % d \u2581 STRNEWLINE \" , getMaxWidth ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program to count leaf nodes in a binary tree | C implementation to find leaf count of a given Binary tree ; A binary tree node has data , pointer to left child and a pointer to right child ; Function to get the count of leaf nodes in a binary tree ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above functions ; create a tree ; get leaf count of the above created tree", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; unsigned int getLeafCount ( struct node * node ) { if ( node == NULL ) return 0 ; if ( node -> left == NULL && node -> right == NULL ) return 1 ; else return getLeafCount ( node -> left ) + getLeafCount ( node -> right ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Leaf \u2581 count \u2581 of \u2581 the \u2581 tree \u2581 is \u2581 % d \" , getLeafCount ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Greedy Algorithm to find Minimum number of Coins | C program to find minimum number of denominations ; All denominations of Indian Currency ; Initialize result ; Traverse through all denomination ; Find denominations ; Print result ; Driver Code", "code": "#include <stdio.h> NEW_LINE #define COINS  9 NEW_LINE #define MAX  20 NEW_LINE int coins [ COINS ] = { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 , 2000 } ; void findMin ( int cost ) { int coinList [ MAX ] = { 0 } ; int i , k = 0 ; for ( i = COINS - 1 ; i >= 0 ; i -- ) { while ( cost >= coins [ i ] ) { cost -= coins [ i ] ; coinList [ k ++ ] = coins [ i ] ; } } for ( i = 0 ; i < k ; i ++ ) { printf ( \" % d \u2581 \" , coinList [ i ] ) ; } return ; } int main ( void ) { int n = 93 ; printf ( \" Following \u2581 is \u2581 minimal \u2581 number \" \" of \u2581 change \u2581 for \u2581 % d : \u2581 \" , n ) ; findMin ( n ) ; return 0 ; }"}
{"text": "Connect nodes at same level using constant extra space | Iterative C program to connect nodes at same level using constant extra space ; Constructor that allocates a new node with the given data and NULL left and right pointers . ; This function returns the leftmost child of nodes at the same level as p . This function is used to getNExt right of p 's right child  If right child of is NULL then this can also be used for the left child  ; Traverse nodes at p ' s \u2581 level \u2581 and \u2581 find \u2581 and \u2581 return \u2581 \u2581 the \u2581 first \u2581 node ' s first child ; If all the nodes at p 's level are leaf nodes then return NULL ; Sets nextRight of all nodes of a tree with root as p ; Set nextRight for root ; set nextRight of all levels one by one ; Connect all childrem nodes of p and children nodes of all other nodes at same level as p ; Set the nextRight pointer for p 's left child ; If q has right child , then right child is nextRight of p and we also need to set nextRight of right child ; Set nextRight for other nodes in pre order fashion ; start from the first node of next level ; Driver program to test above functions ; Constructed binary tree is 10 / \\ 8 2 / \\ 3 90 ; Populates nextRight pointer in all nodes ; Let us check the values of nextRight pointers", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; struct node * nextRight ; } ; struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> nextRight = NULL ; return ( node ) ; } struct node * getNextRight ( struct node * p ) { struct node * temp = p -> nextRight ; while ( temp != NULL ) { if ( temp -> left != NULL ) return temp -> left ; if ( temp -> right != NULL ) return temp -> right ; temp = temp -> nextRight ; } return NULL ; } void connect ( struct node * p ) { struct node * temp ; if ( ! p ) return ; p -> nextRight = NULL ; while ( p != NULL ) { struct node * q = p ; while ( q != NULL ) { if ( q -> left ) { if ( q -> right ) q -> left -> nextRight = q -> right ; else q -> left -> nextRight = getNextRight ( q ) ; } if ( q -> right ) q -> right -> nextRight = getNextRight ( q ) ; q = q -> nextRight ; } if ( p -> left ) p = p -> left ; else if ( p -> right ) p = p -> right ; else p = getNextRight ( p ) ; } } int main ( ) { struct node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ; root -> right -> right = newnode ( 90 ) ; connect ( root ) ; printf ( \" Following \u2581 are \u2581 populated \u2581 nextRight \u2581 pointers \u2581 in \u2581 the \u2581 tree \u2581 \" \" ( -1 \u2581 is \u2581 printed \u2581 if \u2581 there \u2581 is \u2581 no \u2581 nextRight ) \u2581 STRNEWLINE \" ) ; printf ( \" nextRight \u2581 of \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , root -> data , root -> nextRight ? root -> nextRight -> data : -1 ) ; printf ( \" nextRight \u2581 of \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , root -> left -> data , root -> left -> nextRight ? root -> left -> nextRight -> data : -1 ) ; printf ( \" nextRight \u2581 of \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , root -> right -> data , root -> right -> nextRight ? root -> right -> nextRight -> data : -1 ) ; printf ( \" nextRight \u2581 of \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , root -> left -> left -> data , root -> left -> left -> nextRight ? root -> left -> left -> nextRight -> data : -1 ) ; printf ( \" nextRight \u2581 of \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , root -> right -> right -> data , root -> right -> right -> nextRight ? root -> right -> right -> nextRight -> data : -1 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Connect nodes at same level | C program to connect nodes at same level using extended pre - order traversal ; A binary tree node ; Sets the nextRight of root and calls connectRecur ( ) for other nodes ; Set the nextRight for root ; Set the next right for rest of the nodes ( other than root ) ; Set next right of all descendents of p . Assumption : p is a compete binary tree ; Base case ; Set the nextRight pointer for p 's left child ; Set the nextRight pointer for p 's right child  p->nextRight will be NULL if p is the right  most child at its level ; Set nextRight for other nodes in pre order fashion ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above functions ; Constructed binary tree is 10 / \\ 8 2 / 3 ; Populates nextRight pointer in all nodes ; Let us check the values of nextRight pointers", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void connectRecur ( struct node * p ) ; struct node { int data ; struct node * left ; struct node * right ; struct node * nextRight ; } ; void connect ( struct node * p ) { p -> nextRight = NULL ; connectRecur ( p ) ; } void connectRecur ( struct node * p ) { if ( ! p ) return ; if ( p -> left ) p -> left -> nextRight = p -> right ; if ( p -> right ) p -> right -> nextRight = ( p -> nextRight ) ? p -> nextRight -> left : NULL ; connectRecur ( p -> left ) ; connectRecur ( p -> right ) ; } struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> nextRight = NULL ; return ( node ) ; } int main ( ) { struct node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ; connect ( root ) ; printf ( \" Following \u2581 are \u2581 populated \u2581 nextRight \u2581 pointers \u2581 in \u2581 the \u2581 tree \u2581 \" \" ( -1 \u2581 is \u2581 printed \u2581 if \u2581 there \u2581 is \u2581 no \u2581 nextRight ) \u2581 STRNEWLINE \" ) ; printf ( \" nextRight \u2581 of \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , root -> data , root -> nextRight ? root -> nextRight -> data : -1 ) ; printf ( \" nextRight \u2581 of \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , root -> left -> data , root -> left -> nextRight ? root -> left -> nextRight -> data : -1 ) ; printf ( \" nextRight \u2581 of \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , root -> right -> data , root -> right -> nextRight ? root -> right -> nextRight -> data : -1 ) ; printf ( \" nextRight \u2581 of \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , root -> left -> left -> data , root -> left -> left -> nextRight ? root -> left -> left -> nextRight -> data : -1 ) ; return 0 ; }"}
{"text": "Minimum insertions to form a palindrome | DP | A Naive recursive program to find minimum number insertions needed to make a string palindrome ; A utility function to find minimum of two numbers ; Recursive function to find minimum number of insertions ; Base Cases ; Check if the first and last characters are same . On the basis of the comparison result , decide which subrpoblem ( s ) to call ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; } int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; } int main ( ) { char str [ ] = \" geeks \" ; printf ( \" % d \" , findMinInsertions ( str , 0 , strlen ( str ) - 1 ) ) ; return 0 ; }"}
{"text": "Longest Palindromic Subsequence | DP | C program of above approach ; A utility function to get max of two integers ; Returns the length of the longest palindromic subsequence in seq ; Base Case 1 : If there is only 1 character ; Base Case 2 : If there are only 2 characters and both are same ; If the first and last characters match ; If the first and last characters do not match ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int max ( int x , int y ) { return ( x > y ) ? x : y ; } int lps ( char * seq , int i , int j ) { if ( i == j ) return 1 ; if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ; if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ; return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } int main ( ) { char seq [ ] = \" GEEKSFORGEEKS \" ; int n = strlen ( seq ) ; printf ( \" The \u2581 length \u2581 of \u2581 the \u2581 LPS \u2581 is \u2581 % d \" , lps ( seq , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Get Level of a node in a Binary Tree | C program to Get Level of a node in a Binary Tree ; A tree node structure ; Helper function for getLevel ( ) . It returns level of the data if data is present in tree , otherwise returns 0. ; Returns level of given data value ; Utility function to create a new Binary Tree node ; Driver code ; Constructing tree given in the above figure", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int getLevelUtil ( struct node * node , int data , int level ) { if ( node == NULL ) return 0 ; if ( node -> data == data ) return level ; int downlevel = getLevelUtil ( node -> left , data , level + 1 ) ; if ( downlevel != 0 ) return downlevel ; downlevel = getLevelUtil ( node -> right , data , level + 1 ) ; return downlevel ; } int getLevel ( struct node * node , int data ) { return getLevelUtil ( node , data , 1 ) ; } struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int main ( ) { struct node * root ; int x ; root = newNode ( 3 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; for ( x = 1 ; x <= 5 ; x ++ ) { int level = getLevel ( root , x ) ; if ( level ) printf ( \" \u2581 Level \u2581 of \u2581 % d \u2581 is \u2581 % d STRNEWLINE \" , x , getLevel ( root , x ) ) ; else printf ( \" \u2581 % d \u2581 is \u2581 not \u2581 present \u2581 in \u2581 tree \u2581 STRNEWLINE \" , x ) ; } getchar ( ) ; return 0 ; }"}
{"text": "Finite Automata algorithm for Pattern Searching | C program for Finite Automata Pattern searching Algorithm ; If the character c is same as next character in pattern , then simply increment state ; ns stores the result which is next state ; Start from the largest possible value and stop when you find a prefix which is also suffix ; This function builds the TF table which represents4 Finite Automata for a given pattern ; Prints all occurrences of pat in txt ; Process txt over FA . ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE int getNextState ( char * pat , int M , int state , int x ) { if ( state < M && x == pat [ state ] ) return state + 1 ; int ns , i ; for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] == x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) if ( pat [ i ] != pat [ state - ns + 1 + i ] ) break ; if ( i == ns - 1 ) return ns ; } } return 0 ; } void computeTF ( char * pat , int M , int TF [ ] [ NO_OF_CHARS ] ) { int state , x ; for ( state = 0 ; state <= M ; ++ state ) for ( x = 0 ; x < NO_OF_CHARS ; ++ x ) TF [ state ] [ x ] = getNextState ( pat , M , state , x ) ; } void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int TF [ M + 1 ] [ NO_OF_CHARS ] ; computeTF ( pat , M , TF ) ; int i , state = 0 ; for ( i = 0 ; i < N ; i ++ ) { state = TF [ state ] [ txt [ i ] ] ; if ( state == M ) printf ( \" Pattern found at index % d \" , i - M + 1 ) ; } } int main ( ) { char * txt = \" AABAACAADAABAAABAA \" ; char * pat = \" AABA \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Find mirror of a given node in Binary tree | C program to find the mirror Node in Binary tree ; A binary tree Node has data , pointer to left child and a pointer to right child ; create new Node and initialize it ; recursive function to find mirror of Node ; if any of the Node is none then Node itself and decendent have no mirror , so return none , no need to further explore ! ; if left Node is target Node , then return right 's key (that is mirror) and vice  versa  ; first recur external Nodes ; if no mirror found , recur internal Nodes ; interface for mirror search ; Driver ; target Node whose mirror have to be searched", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int key ; struct Node * left , * right ; } ; struct Node * newNode ( int key ) { struct Node * n = ( struct Node * ) malloc ( sizeof ( struct Node * ) ) ; if ( n != NULL ) { n -> key = key ; n -> left = NULL ; n -> right = NULL ; return n ; } else { printf ( \" Memory \u2581 allocation \u2581 failed ! \" ) ; exit ( 1 ) ; } } int findMirrorRec ( int target , struct Node * left , struct Node * right ) { if ( left == NULL right == NULL ) return 0 ; if ( left -> key == target ) return right -> key ; if ( right -> key == target ) return left -> key ; int mirror_val = findMirrorRec ( target , left -> left , right -> right ) ; if ( mirror_val ) return mirror_val ; findMirrorRec ( target , left -> right , right -> left ) ; } int findMirror ( struct Node * root , int target ) { if ( root == NULL ) return 0 ; if ( root -> key == target ) return target ; return findMirrorRec ( target , root -> left , root -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> left -> right = newNode ( 7 ) ; root -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> left = newNode ( 8 ) ; root -> right -> left -> right = newNode ( 9 ) ; int target = root -> left -> left -> key ; int mirror = findMirror ( root , target ) ; if ( mirror ) printf ( \" Mirror \u2581 of \u2581 Node \u2581 % d \u2581 is \u2581 Node \u2581 % d STRNEWLINE \" , target , mirror ) ; else printf ( \" Mirror \u2581 of \u2581 Node \u2581 % d \u2581 is \u2581 NULL ! STRNEWLINE \" , target ) ; }"}
{"text": "Iterative Search for a key ' x ' in Binary Tree | Iterative level order traversal based method to search in Binary Tree ; A binary tree node has data , left child and right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; An iterative process to search an element x in a given binary tree ; Base Case ; Create an empty queue for level order traversal ; Enqueue Root and initialize height ; Queue based level order traversal ; See if current node is same as x ; Remove current node and enqueue its children ; Driver program", "code": "#include <iostream> NEW_LINE #include <queue> NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = new struct node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } bool iterativeSearch ( node * root , int x ) { if ( root == NULL ) return false ; queue < node * > q ; q . push ( root ) ; while ( q . empty ( ) == false ) { node * node = q . front ( ) ; if ( node -> data == x ) return true ; q . pop ( ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; } return false ; } int main ( void ) { struct node * NewRoot = NULL ; struct node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; iterativeSearch ( root , 6 ) ? cout << \" Found STRNEWLINE \" : cout << \" Not \u2581 Found STRNEWLINE \" ; iterativeSearch ( root , 12 ) ? cout << \" Found STRNEWLINE \" : cout << \" Not \u2581 Found STRNEWLINE \" ; return 0 ; }"}
{"text": "Populate Inorder Successor for all nodes | C # program to populate inorder traversal of all nodes ; An implementation that doesn 't use static variable A wrapper over populateNextRecur ; The first visited node will be the rightmost node next of the rightmost node will be NULL ; Set next of all descendants of p by traversing them in reverse Inorder ; First set the next pointer in right subtree ; Set the next as previously visited node in reverse Inorder ; Change the prev for subsequent node ; Finally , set the next pointer in right subtree", "code": "struct node { int data ; struct node * left ; struct node * right ; struct node * next ; } void populateNext ( struct node * root ) { struct node * next = NULL ; populateNextRecur ( root , & next ) ; } void populateNextRecur ( struct node * p , struct node * * next_ref ) { if ( p ) { populateNextRecur ( p -> right , next_ref ) ; p -> next = * next_ref ; * next_ref = p ; populateNextRecur ( p -> left , next_ref ) ; } }"}
{"text": "Given a binary tree , how do you remove all the half nodes ? | C program to remove all half nodes ; Binary tree node ;  ; For inorder traversal ; Removes all nodes with only one child and returns new root ( note that root may change ) ; if current nodes is a half node with left child NULL left , then it 's right child is  returned and replaces it in the given tree  ; if current nodes is a half node with right child NULL right , then it 's right child is  returned and replaces it in the given tree  ; Driver program", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void printInoder ( struct node * root ) { if ( root != NULL ) { printInoder ( root -> left ) ; printf ( \" % d \u2581 \" , root -> data ) ; printInoder ( root -> right ) ; } } struct node * RemoveHalfNodes ( struct node * root ) { if ( root == NULL ) return NULL ; root -> left = RemoveHalfNodes ( root -> left ) ; root -> right = RemoveHalfNodes ( root -> right ) ; if ( root -> left == NULL && root -> right == NULL ) return root ; if ( root -> left == NULL ) { struct node * new_root = root -> right ; free ( root ) ; return new_root ; } if ( root -> right == NULL ) { struct node * new_root = root -> left ; free ( root ) ; return new_root ; } return root ; } int main ( void ) { struct node * NewRoot = NULL ; struct node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; printf ( \" Inorder \u2581 traversal \u2581 of \u2581 given \u2581 tree \u2581 STRNEWLINE \" ) ; printInoder ( root ) ; NewRoot = RemoveHalfNodes ( root ) ; printf ( \" Inorder traversal of the modified tree \" printInoder ( NewRoot ) ; return 0 ; }"}
{"text": "Program to print all substrings of a given string | C program for the above approach ; outermost for loop this is for the selection of starting point ; 2 nd for loop is for selection of ending point ; 3 rd loop is for printing from starting point to ending point ; changing the line after printing from starting point to ending point ; Driver Code ; calling the method to print the substring", "code": "#include <stdio.h> NEW_LINE void printSubstrings ( char str [ ] ) { for ( int start = 0 ; str [ start ] != ' \\0' ; start ++ ) { for ( int end = start ; str [ end ] != ' \\0' ; end ++ ) { for ( int i = start ; i <= end ; i ++ ) { printf ( \" % c \" , str [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } } } int main ( ) { char str [ ] = { ' a ' , ' b ' , ' c ' , ' d ' , ' \\0' } ; printSubstrings ( str ) ; return 0 ; }"}
{"text": "Sudoku | Backtracking |  ; N is the size of the 2D matrix N * N ; A utility function to print grid ; Checks whether it will be legal to assign num to the given row , col ; Check if we find the same num in the similar row , we return 0 ; Check if we find the same num in the similar column , we return 0 ; Check if we find the same num in the particular 3 * 3 matrix , we return 0 ; Takes a partially filled - in grid and attempts to assign values to all unassigned locations in such a way to meet the requirements for Sudoku solution ( non - duplication across rows , columns , and boxes ) ; Check if we have reached the 8 th row and 9 th column ( 0 indexed matrix ) , we are returning true to avoid further backtracking ; Check if column value becomes 9 , we move to next row and column start from 0 ; Check if the current position of the grid already contains value > 0 , we iterate for next column ; Check if it is safe to place the num ( 1 - 9 ) in the given row , col -> we move to next column ; assigning the num in the current ( row , col ) position of the grid and assuming our assigned num in the position is correct ; Checking for next possibility with next column ; Removing the assigned num , since our assumption was wrong , and we go for next assumption with diff num value ; 0 means unassigned cells", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define N  9 NEW_LINE void print ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( \" % d \u2581 \" , arr [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } } int isSafe ( int grid [ N ] [ N ] , int row , int col , int num ) { for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ row ] [ x ] == num ) return 0 ; for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ x ] [ col ] == num ) return 0 ; int startRow = row - row % 3 , startCol = col - col % 3 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow ] [ j + startCol ] == num ) return 0 ; return 1 ; } int solveSuduko ( int grid [ N ] [ N ] , int row , int col ) { if ( row == N - 1 && col == N ) return 1 ; if ( col == N ) { row ++ ; col = 0 ; } if ( grid [ row ] [ col ] > 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( int num = 1 ; num <= N ; num ++ ) { if ( isSafe ( grid , row , col , num ) == 1 ) { grid [ row ] [ col ] = num ; if ( solveSuduko ( grid , row , col + 1 ) == 1 ) return 1 ; } grid [ row ] [ col ] = 0 ; } return 0 ; } int main ( ) { int grid [ N ] [ N ] = { { 3 , 0 , 6 , 5 , 0 , 8 , 4 , 0 , 0 } , { 5 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 8 , 7 , 0 , 0 , 0 , 0 , 3 , 1 } , { 0 , 0 , 3 , 0 , 1 , 0 , 0 , 8 , 0 } , { 9 , 0 , 0 , 8 , 6 , 3 , 0 , 0 , 5 } , { 0 , 5 , 0 , 0 , 9 , 0 , 6 , 0 , 0 } , { 1 , 3 , 0 , 0 , 0 , 0 , 2 , 5 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 4 } , { 0 , 0 , 5 , 2 , 0 , 6 , 3 , 0 , 0 } } ; if ( solveSuduko ( grid , 0 , 0 ) == 1 ) print ( grid ) ; else printf ( \" No \u2581 solution \u2581 exists \" ) ; return 0 ; }"}
{"text": "Subset Sum | Backtracking |  ; prints subset found ; qsort compare function ; inputs s - set vector t - tuplet vector s_size - set size t_size - tuplet size so far sum - sum so far ite - nodes count target_sum - sum to be found ; We found sum ; constraint check ; Exclude previous added item and consider next candidate ; constraint check ; generate nodes along the breadth ; consider next level node ( along depth ) ; Wrapper that prints subsets that sum to target_sum ; sort the set ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define ARRAYSIZE ( a )  (sizeof(a))/(sizeof(a[0])) NEW_LINE static int total_nodes ; void printSubset ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { printf ( \" % * d \" , 5 , A [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } int comparator ( const void * pLhs , const void * pRhs ) { int * lhs = ( int * ) pLhs ; int * rhs = ( int * ) pRhs ; return * lhs > * rhs ; } void subset_sum ( int s [ ] , int t [ ] , int s_size , int t_size , int sum , int ite , int const target_sum ) { total_nodes ++ ; if ( target_sum == sum ) { printSubset ( t , t_size ) ; if ( ite + 1 < s_size && sum - s [ ite ] + s [ ite + 1 ] <= target_sum ) { subset_sum ( s , t , s_size , t_size - 1 , sum - s [ ite ] , ite + 1 , target_sum ) ; } return ; } else { if ( ite < s_size && sum + s [ ite ] <= target_sum ) { for ( int i = ite ; i < s_size ; i ++ ) { t [ t_size ] = s [ i ] ; if ( sum + s [ i ] <= target_sum ) { subset_sum ( s , t , s_size , t_size + 1 , sum + s [ i ] , i + 1 , target_sum ) ; } } } } } void generateSubsets ( int s [ ] , int size , int target_sum ) { int * tuplet_vector = ( int * ) malloc ( size * sizeof ( int ) ) ; int total = 0 ; qsort ( s , size , sizeof ( int ) , & comparator ) ; for ( int i = 0 ; i < size ; i ++ ) { total += s [ i ] ; } if ( s [ 0 ] <= target_sum && total >= target_sum ) { subset_sum ( s , tuplet_vector , size , 0 , 0 , 0 , target_sum ) ; } free ( tuplet_vector ) ; } int main ( ) { int weights [ ] = { 15 , 22 , 14 , 26 , 32 , 9 , 16 , 8 } ; int target = 53 ; int size = ARRAYSIZE ( weights ) ; generateSubsets ( weights , size , target ) ; printf ( \" Nodes \u2581 generated \u2581 % d STRNEWLINE \" , total_nodes ) ; return 0 ; }"}
{"text": "Given an array A [ ] and a number x , check for pair in A [ ] with sum as x | C program to check if given array has 2 elements whose sum is equal to the given value ; function to check for the given sum in the array ; checking for condition ; Driver Code", "code": "#include <stdio.h> NEW_LINE #define MAX  100000 NEW_LINE void printPairs ( int arr [ ] , int arr_size , int sum ) { int i , temp ; bool s [ MAX ] = { 0 } ; for ( i = 0 ; i < arr_size ; i ++ ) { temp = sum - arr [ i ] ; if ( s [ temp ] == 1 ) printf ( \" Pair \u2581 with \u2581 given \u2581 sum \u2581 % d \u2581 is \u2581 ( % d , \u2581 % d ) \u2581 n \" , sum , arr [ i ] , temp ) ; s [ arr [ i ] ] = 1 ; } } int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int n = 16 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; printPairs ( A , arr_size , n ) ; getchar ( ) ; return 0 ; }"}
{"text": "Modular exponentiation ( Recursive ) | Recursive C program to compute modular power ; Base cases ; If B is even ; If B is odd ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; } int main ( ) { int A = 2 , B = 5 , C = 13 ; printf ( \" Power \u2581 is \u2581 % d \" , exponentMod ( A , B , C ) ) ; return 0 ; }"}
{"text": "Modular Exponentiation ( Power in Modular Arithmetic ) | Iterative Function to calculate ( x ^ y ) in O ( log y ) ; Initialize result ; If y is odd , multiply x with result ; y must be even now y = y / 2 ; Change x to x ^ 2", "code": "int power ( int x , unsigned int y ) { int res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }"}
{"text": "Egg Dropping Puzzle | DP |  ; A utility function to get maximum of two integers ; Function to get minimum number of trials needed in worst case with n eggs and k floors ; If there are no floors , then no trials needed . OR if there is one floor , one trial needed . ; We need k trials for one egg and k floors ; Consider all droppings from 1 st floor to kth floor and return the minimum of these values plus 1. ; Driver code", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int eggDrop ( int n , int k ) { if ( k == 1 k == 0 ) return k ; if ( n == 1 ) return k ; int min = INT_MAX , x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; } int main ( ) { int n = 2 , k = 10 ; printf ( \" nMinimum \u2581 number \u2581 of \u2581 trials \u2581 in \u2581 \" \" worst \u2581 case \u2581 with \u2581 % d \u2581 eggs \u2581 and \u2581 \" \" % d \u2581 floors \u2581 is \u2581 % d \u2581 STRNEWLINE \" , n , k , eggDrop ( n , k ) ) ; return 0 ; }"}
{"text": "Binary Tree | Set 1 ( Introduction ) |  ; struct containing left and right child of current node and key value ; newNode ( ) allocates a new node with the given data and NULL left and right pointers . ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find maximum ( or minimum ) in Binary Tree | C program to find maximum and minimum in a Binary Tree ; A tree node ; A utility function to create a new node ; Returns maximum value in a given Binary Tree ; Base case ; Return maximum of 3 values : 1 ) Root 's data 2) Max in Left Subtree 3) Max in right subtree ; Driver code ; Function call", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int findMax ( struct Node * root ) { if ( root == NULL ) return INT_MIN ; int res = root -> data ; int lres = findMax ( root -> left ) ; int rres = findMax ( root -> right ) ; if ( lres > res ) res = lres ; if ( rres > res ) res = rres ; return res ; } int main ( void ) { struct Node * NewRoot = NULL ; struct Node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; printf ( \" Maximum \u2581 element \u2581 is \u2581 % d \u2581 STRNEWLINE \" , findMax ( root ) ) ; return 0 ; }"}
{"text": "Find maximum ( or minimum ) in Binary Tree | Returns minimum value in a given Binary Tree", "code": "int findMin ( struct Node * root ) { if ( root == NULL ) return INT_MAX ; int res = root -> data ; int lres = findMin ( root -> left ) ; int rres = findMin ( root -> right ) ; if ( lres < res ) res = lres ; if ( rres < res ) res = rres ; return res ; }"}
{"text": "Extract Leaves of a Binary Tree in a Doubly Linked List | C program to extract leaves of a Binary Tree in a Doubly Linked List ; Structure for tree and linked list ; Main function which extracts all leaves from given Binary Tree . The function returns new root of Binary Tree ( Note that root may changeif Binary Tree has only one node ) . The function also sets * head_ref as head of doubly linked list . left pointer of tree is used as prev in DLL and right pointer is used as next ; Utility function for allocating node for Binary Tree . ; Utility function for printing tree in In - Order . ; Utility function for printing double linked list . ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * extractLeafList ( struct Node * root , struct Node * * head_ref ) { if ( root == NULL ) return NULL ; if ( root -> left == NULL && root -> right == NULL ) { root -> right = * head_ref ; if ( * head_ref != NULL ) ( * head_ref ) -> left = root ; return NULL ; } root -> right = extractLeafList ( root -> right , head_ref ) ; root -> left = extractLeafList ( root -> left , head_ref ) ; return root ; } struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } void print ( struct Node * root ) { if ( root != NULL ) { print ( root -> left ) ; printf ( \" % d \u2581 \" , root -> data ) ; print ( root -> right ) ; } } void printList ( struct Node * head ) { while ( head ) { printf ( \" % d \u2581 \" , head -> data ) ; head = head -> right ; } } int main ( ) { struct Node * head = NULL ; struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> left -> left -> left = newNode ( 7 ) ; root -> left -> left -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 9 ) ; root -> right -> right -> right = newNode ( 10 ) ; printf ( \" Inorder \u2581 Trvaersal \u2581 of \u2581 given \u2581 Tree \u2581 is : STRNEWLINE \" ) ; print ( root ) ; root = extractLeafList ( root , & head ) ; printf ( \" Extracted Double Linked list is : \" printList ( head ) ; printf ( \" Inorder traversal of modified tree is : \" print ( root ) ; return 0 ; }"}
{"text": "Find n | C program for nth nodes of inorder traversals ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Given a binary tree , print its nth nodes of inorder ; first recur on left child ; when count = n then print element ; now recur on right child ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void NthInorder ( struct Node * node , int n ) { static int count = 0 ; if ( node == NULL ) return ; if ( count <= n ) { NthInorder ( node -> left , n ) ; count ++ ; if ( count == n ) printf ( \" % d \u2581 \" , node -> data ) ; NthInorder ( node -> right , n ) ; } } int main ( ) { struct Node * root = newNode ( 10 ) ; root -> left = newNode ( 20 ) ; root -> right = newNode ( 30 ) ; root -> left -> left = newNode ( 40 ) ; root -> left -> right = newNode ( 50 ) ; int n = 4 ; NthInorder ( root , n ) ; return 0 ; }"}
{"text": "QuickSort Tail Call Optimization ( Reducing worst case space to Log n ) | A Simple implementation of QuickSort that makes two two recursive calls . ; pi is partitioning index , arr [ p ] is now at right place ; Separately sort elements before partition and after partition", "code": "void quickSort ( int arr [ ] , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; quickSort ( arr , low , pi - 1 ) ; quickSort ( arr , pi + 1 , high ) ; } }"}
{"text": "Count all possible strings that can be generated by placing spaces | C program to implement the above approach ; Function to count the number of strings that can be generated by placing spaces between pair of adjacent characters ; Length of the string ; Count of positions for spaces ; Count of possible strings ; Driver Code", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #include <string.h> NEW_LINE long long int countNumberOfStrings ( char * s ) { int length = strlen ( s ) ; int n = length - 1 ; long long int count = pow ( 2 , n ) ; return count ; } int main ( ) { char S [ ] = \" ABCD \" ; printf ( \" % lld \" , countNumberOfStrings ( S ) ) ; return 0 ; }"}
{"text": "Modify given array to make sum of odd and even indexed elements same | C ++ program for the above approach ; Function to modify array to make sum of odd and even indexed elements equal ; Stores the count of 0 s , 1 s ; Stores sum of odd and even indexed elements respectively ; Count 0 s ; Count 1 s ; Calculate odd_sum and even_sum ; If both are equal ; Print the original array ; Otherwise ; Print all the 0 s ; For checking even or odd ; Update total count of 1 s ; Print all 1 s ; Driver Code ; Given array arr [ ] ; Function Call", "code": "#include <stdio.h> NEW_LINE void makeArraySumEqual ( int a [ ] , int N ) { int count_0 = 0 , count_1 = 0 ; int odd_sum = 0 , even_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; if ( ( i + 1 ) % 2 == 0 ) even_sum += a [ i ] ; else if ( ( i + 1 ) % 2 > 0 ) odd_sum += a [ i ] ; } if ( odd_sum == even_sum ) { for ( int i = 0 ; i < N ; i ++ ) printf ( \" % d \u2581 \" , a [ i ] ) ; } else { if ( count_0 >= N / 2 ) { for ( int i = 0 ; i < count_0 ; i ++ ) printf ( \"0 \u2581 \" ) ; } else { int is_Odd = count_1 % 2 ; count_1 -= is_Odd ; for ( int i = 0 ; i < count_1 ; i ++ ) printf ( \"1 \u2581 \" ) ; } } } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; makeArraySumEqual ( arr , N ) ; return 0 ; }"}
{"text": "Count of N digit Numbers whose sum of every K consecutive digits is equal | C program for the above approach ; Function to count the number of N - digit numbers such that sum of every k consecutive digits are equal ; Range of numbers ; Extract digits of the number ; Store the sum of first K digits ; Check for every k - consecutive digits using sliding window ; Driver Code ; Given integer N and K", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE int countDigitSum ( int N , int K ) { int l = ( int ) pow ( 10 , N - 1 ) , r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; int digits [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ; for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( int j = K ; j < N ; j ++ ) { if ( sum - digits [ j - K ] + digits [ j ] != sum ) { flag = 1 ; break ; } } if ( flag == 0 ) count ++ ; } return count ; } int main ( ) { int N = 2 , K = 1 ; printf ( \" % d \" , countDigitSum ( N , K ) ) ; return 0 ; }"}
{"text": "Find if possible to visit every nodes in given Graph exactly once based on given conditions | C ++ program for above approach . ; Function to find print path ; If a [ 0 ] is 1 ; Printing path ; Seeking for a [ i ] = 0 and a [ i + 1 ] = 1 ; Printing path ; If a [ N - 1 ] = 0 ; Driver Code ; Given Input ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findpath ( int N , int a [ ] ) { if ( a [ 0 ] ) { printf ( \" % d \u2581 \" , N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d \u2581 \" , i ) ; return ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ! a [ i ] && a [ i + 1 ] ) { for ( int j = 1 ; j <= i ; j ++ ) printf ( \" % d \u2581 \" , j ) ; printf ( \" % d \u2581 \" , N + 1 ) ; for ( int j = i + 1 ; j <= N ; j ++ ) printf ( \" % d \u2581 \" , j ) ; return ; } } for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d \u2581 \" , i ) ; printf ( \" % d \u2581 \" , N + 1 ) ; } int main ( ) { int N = 3 , arr [ ] = { 0 , 1 , 0 } ; findpath ( N , arr ) ; }"}
{"text": "Printing Items in 0 / 1 Knapsack | CPP code for Dynamic Programming based solution for 0 - 1 Knapsack problem ; A utility function that returns maximum of two integers ; Prints the items which are put in a knapsack of capacity W ; Build table K [ ] [ ] in bottom up manner ; stores the result of Knapsack ; either the result comes from the top ( K [ i - 1 ] [ w ] ) or from ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] ) as in Knapsack table . If it comes from the latter one / it means the item is included . ; This item is included . ; Since this weight is included its value is deducted ; Driver code", "code": "#include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; printf ( \" % d STRNEWLINE \" , res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { printf ( \" % d \u2581 \" , wt [ i - 1 ] ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } } int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printknapSack ( W , wt , val , n ) ; return 0 ; }"}
{"text": "Optimal Binary Search Tree | DP | A naive recursive implementation of optimal binary search tree problem ; A recursive function to calculate cost of optimal binary search tree ; Base cases if ( j < i ) no elements in this subarray ; one element in this subarray ; Get sum of freq [ i ] , freq [ i + 1 ] , ... freq [ j ] ; Initialize minimum value ; One by one consider all elements as root and recursively find cost of the BST , compare the cost with min and update min if needed ; Return minimum value ; The main function that calculates minimum cost of a Binary Search Tree . It mainly uses optCost ( ) to find the optimal cost . ; Here array keys [ ] is assumed to be sorted in increasing order . If keys [ ] is not sorted , then add code to sort keys , and rearrange freq [ ] accordingly . ; A utility function to get sum of array elements freq [ i ] to freq [ j ] ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int optCost ( int freq [ ] , int i , int j ) { return 0 ; if ( j == i ) return freq [ i ] ; int fsum = sum ( freq , i , j ) ; int min = INT_MAX ; for ( int r = i ; r <= j ; ++ r ) { int cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; } return min + fsum ; } int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { return optCost ( freq , 0 , n - 1 ) ; } int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; } int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; printf ( \" Cost \u2581 of \u2581 Optimal \u2581 BST \u2581 is \u2581 % d \u2581 \" , optimalSearchTree ( keys , freq , n ) ) ; return 0 ; }"}
{"text": "Word Wrap Problem | DP | A Dynamic programming solution for Word Wrap Problem ; A utility function to print the solution ; l [ ] represents lengths of different words in input sequence . For example , l [ ] = { 3 , 2 , 2 , 5 } is for a sentence like \" aaa \u2581 bb \u2581 cc \u2581 ddddd \" . n is size of l [ ] and M is line width ( maximum no . of characters that can fit in a line ) ; extras [ i ] [ j ] will have number of extra spaces if words from i to j are put in a single line ; lc [ i ] [ j ] will have cost of a line which has words from i to j ; c [ i ] will have total cost of optimal arrangement of words from 1 to i ; p [ ] is used to print the solution . ; calculate extra spaces in a single line . The value extra [ i ] [ j ] indicates extra spaces if words from word number i to j are placed in a single line ; Calculate line cost corresponding to the above calculated extra spaces . The value lc [ i ] [ j ] indicates cost of putting words from word number i to j in a single line ; Calculate minimum cost and find minimum cost arrangement . The value c [ j ] indicates optimized cost to arrange words from word number 1 to j . ; Driver program to test above functions", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #define INF  INT_MAX NEW_LINE int printSolution ( int p [ ] , int n ) ; void solveWordWrap ( int l [ ] , int n , int M ) { int extras [ n + 1 ] [ n + 1 ] ; int lc [ n + 1 ] [ n + 1 ] ; int c [ n + 1 ] ; int p [ n + 1 ] ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; } for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = INF ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } } c [ 0 ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { c [ j ] = INF ; for ( i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != INF && lc [ i ] [ j ] != INF && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; } int printSolution ( int p [ ] , int n ) { int k ; if ( p [ n ] == 1 ) k = 1 ; else k = printSolution ( p , p [ n ] - 1 ) + 1 ; printf ( \" Line \u2581 number \u2581 % d : \u2581 From \u2581 word \u2581 no . \u2581 % d \u2581 to \u2581 % d \u2581 STRNEWLINE \" , k , p [ n ] , n ) ; return k ; } int main ( ) { int l [ ] = { 3 , 2 , 2 , 5 } ; int n = sizeof ( l ) / sizeof ( l [ 0 ] ) ; int M = 6 ; solveWordWrap ( l , n , M ) ; return 0 ; }"}
{"text": "Egg Dropping Puzzle | DP | A Dynamic Programming based for the Egg Dropping Puzzle ; A utility function to get maximum of two integers ; Function to get minimum number of trials needed in worst case with n eggs and k floors ; A 2D table where entry eggFloor [ i ] [ j ] will represent minimum number of trials needed for i eggs and j floors . ; We need one trial for one floor and 0 trials for 0 floors ; We always need j trials for one egg and j floors . ; Fill rest of the entries in table using optimal substructure property ; eggFloor [ n ] [ k ] holds the result ; Driver program to test to pront printDups", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int eggDrop ( int n , int k ) { int eggFloor [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = INT_MAX ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; } int main ( ) { int n = 2 , k = 36 ; printf ( \" Minimum number of trials \" STRNEWLINE TABSYMBOL TABSYMBOL \" in worst case with % d eggs and \" STRNEWLINE TABSYMBOL TABSYMBOL \" % d floors is % d \" , n , k , eggDrop ( n , k ) ) ; return 0 ; }"}
{"text": "0 | A Naive recursive implementation of 0 - 1 Knapsack problem ; A utility function that returns maximum of two integers ; Returns the maximum value that can be put in a knapsack of capacity W ; Base Case ; If weight of the nth item is more than Knapsack capacity W , then this item cannot be included in the optimal solution ; Return the maximum of two cases : ( 1 ) nth item included ( 2 ) not included ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printf ( \" % d \" , knapSack ( W , wt , val , n ) ) ; return 0 ; }"}
{"text": "Longest Increasing Subsequence | DP | A Naive C recursive implementation of LIS problem ; stores the LIS ; To make use of recursive calls , thisfunction must return two things : 1 ) Length of LIS ending with element arr [ n - 1 ] . We use max_ending_here for this purpose2 ) Overall maximum as the LIS may end with an element before arr [ n - 1 ] max_ref is used this purpose . The value of LIS of full array of size n is stored in * max_ref which is our final result ; Base case ; ' max _ ending _ here ' is length of LIS ending with arr [ n - 1 ] ; Recursively get all LIS ending with arr [ 0 ] , arr [ 1 ] ... arr [ n - 2 ] . If arr [ i - 1 ] is smaller than arr [ n - 1 ] , and max ending with arr [ n - 1 ] needs to be updated , then update it ; Compare max_ending_here with the overall max . And update the overall max if needed ; Return length of LIS ending with arr [ n - 1 ] ; The wrapper function for _lis ( ) ; The max variable holds the result ; The function _lis ( ) stores its result in max ; returns max ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE let max_ref ; int _lis ( int arr [ ] , int n , int * max_ref ) { if ( n == 1 ) return 1 ; int res , max_ending_here = 1 ; for ( int i = 1 ; i < n ; i ++ ) { res = _lis ( arr , i , max_ref ) ; if ( arr [ i - 1 ] < arr [ n - 1 ] && res + 1 > max_ending_here ) max_ending_here = res + 1 ; } if ( * max_ref < max_ending_here ) * max_ref = max_ending_here ; return max_ending_here ; } int lis ( int arr [ ] , int n ) { int max = 1 ; _lis ( arr , n , & max ) ; return max ; } int main ( ) { int arr [ ] = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Length \u2581 of \u2581 lis \u2581 is \u2581 % d \" , lis ( arr , n ) ) ; return 0 ; }"}
{"text": "Rabin | Following program is a C implementation of Rabin Karp Algorithm given in the CLRS book ; d is the number of characters in the input alphabet ; pat -> pattern txt -> text q -> A prime number ; int p = 0 ; hash value for pattern int t = 0 ; hash value for txt ; The value of h would be \" pow ( d , \u2581 M - 1 ) % q \" ; Calculate the hash value of pattern and first window of text ; Slide the pattern over text one by one ; Check the hash values of current window of text and pattern . If the hash values match then only check for characters on by one ; Check for characters one by one ; if p == t and pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Calculate hash value for next window of text : Remove leading digit , add trailing digit ; We might get negative value of t , converting it to positive ; Driver Code ; A prime number ; function call", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define d  256 NEW_LINE void search ( char pat [ ] , char txt [ ] , int q ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i , j ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; } if ( j == M ) printf ( \" Pattern \u2581 found \u2581 at \u2581 index \u2581 % d \u2581 STRNEWLINE \" , i ) ; } if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } int main ( ) { char txt [ ] = \" GEEKS \u2581 FOR \u2581 GEEKS \" ; char pat [ ] = \" GEEK \" ; int q = 101 ; search ( pat , txt , q ) ; return 0 ; }"}
{"text": "The Knight 's tour problem | Backtracking | C program for Knight Tour problem ; A utility function to check if i , j are valid indexes for N * N chessboard ; A utility function to print solution matrix sol [ N ] [ N ] ; This function solves the Knight Tour problem using Backtracking . This function mainly uses solveKTUtil ( ) to solve the problem . It returns false if no complete tour is possible , otherwise return true and prints the tour . Please note that there may be more than one solutions , this function prints one of the feasible solutions . ; Initialization of solution matrix ; xMove [ ] and yMove [ ] define next move of Knight . xMove [ ] is for next value of x coordinate yMove [ ] is for next value of y coordinate ; Since the Knight is initially at the first block ; Start from 0 , 0 and explore all tours using solveKTUtil ( ) ; A recursive utility function to solve Knight Tour problem ; Try all next moves from the current coordinate x , y ; backtracking ; Driver Code ; Function Call", "code": "#include <stdio.h> NEW_LINE #define N  8 NEW_LINE int solveKTUtil ( int x , int y , int movei , int sol [ N ] [ N ] , int xMove [ ] , int yMove [ ] ) ; int isSafe ( int x , int y , int sol [ N ] [ N ] ) { return ( x >= 0 && x < N && y >= 0 && y < N && sol [ x ] [ y ] == -1 ) ; } void printSolution ( int sol [ N ] [ N ] ) { for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < N ; y ++ ) printf ( \" \u2581 % 2d \u2581 \" , sol [ x ] [ y ] ) ; printf ( \" STRNEWLINE \" ) ; } } int solveKT ( ) { int sol [ N ] [ N ] ; for ( int x = 0 ; x < N ; x ++ ) for ( int y = 0 ; y < N ; y ++ ) sol [ x ] [ y ] = -1 ; int xMove [ 8 ] = { 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 } ; int yMove [ 8 ] = { 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 } ; sol [ 0 ] [ 0 ] = 0 ; if ( solveKTUtil ( 0 , 0 , 1 , sol , xMove , yMove ) == 0 ) { printf ( \" Solution \u2581 does \u2581 not \u2581 exist \" ) ; return 0 ; } else printSolution ( sol ) ; return 1 ; } int solveKTUtil ( int x , int y , int movei , int sol [ N ] [ N ] , int xMove [ N ] , int yMove [ N ] ) { int k , next_x , next_y ; if ( movei == N * N ) return 1 ; for ( k = 0 ; k < 8 ; k ++ ) { next_x = x + xMove [ k ] ; next_y = y + yMove [ k ] ; if ( isSafe ( next_x , next_y , sol ) ) { sol [ next_x ] [ next_y ] = movei ; if ( solveKTUtil ( next_x , next_y , movei + 1 , sol , xMove , yMove ) == 1 ) return 1 ; else sol [ next_x ] [ next_y ] = -1 ; } } return 0 ; } int main ( ) { solveKT ( ) ; return 0 ; }"}
{"text": "m Coloring Problem | Backtracking |  ; Number of vertices in the graph ; A utility function to print solution ; check if the colored graph is safe or not ; check for every edge ; This function solves the m Coloring problem using recursion . It returns false if the m colours cannot be assigned , otherwise , return true and prints assignments of colours to all vertices . Please note that there may be more than one solutions , this function prints one of the feasible solutions . ; if current index reached end ; if coloring is safe ; Print the solution ; Assign each color from 1 to m ; Recur of the rest vertices ; Driver program to test above function ; Create following graph and test whether it is 3 colorable ( 3 ) -- - ( 2 ) | / | | / | | / | ( 0 ) -- - ( 1 ) ; Number of colors ; Initialize all color values as 0. This initialization is needed correct functioning of isSafe ( )", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE #define V  4 NEW_LINE void printSolution ( int color [ ] ) ; void printSolution ( int color [ ] ) { printf ( \" Solution \u2581 Exists : \" \" \u2581 Following \u2581 are \u2581 the \u2581 assigned \u2581 colors \u2581 STRNEWLINE \" ) ; for ( int i = 0 ; i < V ; i ++ ) printf ( \" \u2581 % d \u2581 \" , color [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } bool isSafe ( bool graph [ V ] [ V ] , int color [ ] ) { for ( int i = 0 ; i < V ; i ++ ) for ( int j = i + 1 ; j < V ; j ++ ) if ( graph [ i ] [ j ] && color [ j ] == color [ i ] ) return false ; return true ; } bool graphColoring ( bool graph [ V ] [ V ] , int m , int i , int color [ V ] ) { if ( i == V ) { if ( isSafe ( graph , color ) ) { printSolution ( color ) ; return true ; } return false ; } for ( int j = 1 ; j <= m ; j ++ ) { color [ i ] = j ; if ( graphColoring ( graph , m , i + 1 , color ) ) return true ; color [ i ] = 0 ; } return false ; } int main ( ) { bool graph [ V ] [ V ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 1 } , { 1 , 0 , 1 , 0 } , } ; int m = 3 ; int color [ V ] ; for ( int i = 0 ; i < V ; i ++ ) color [ i ] = 0 ; if ( ! graphColoring ( graph , m , 0 , color ) ) printf ( \" Solution \u2581 does \u2581 not \u2581 exist \" ) ; return 0 ; }"}
{"text": "Logarithm tricks for Competitive Programming | C implementation to find the previous and next power of K ; Function to return the highest power of k less than or equal to n ; Function to return the smallest power of k greater than or equal to n ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE int prevPowerofK ( int n , int k ) { int p = ( int ) ( log ( n ) / log ( k ) ) ; return ( int ) pow ( k , p ) ; } int nextPowerOfK ( int n , int k ) { return prevPowerofK ( n , k ) * k ; } int main ( ) { int N = 7 ; int K = 2 ; printf ( \" % d \u2581 \" , prevPowerofK ( N , K ) ) ; printf ( \" % d STRNEWLINE \" , nextPowerOfK ( N , K ) ) ; return 0 ; }"}
{"text": "Program to find HCF ( Highest Common Factor ) of 2 Numbers | C program to find GCD of two numbers ; Recursive function to return gcd of a and b ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int main ( ) { int a = 98 , b = 56 ; printf ( \" GCD \u2581 of \u2581 % d \u2581 and \u2581 % d \u2581 is \u2581 % d \u2581 \" , a , b , gcd ( a , b ) ) ; return 0 ; }"}
{"text": "Check whether a number is semiprime or not | C Program to check whether number is semiprime or not ; Utility function to check whether number is semiprime or not ; If number is greater than 1 , add it to the count variable as it indicates the number remain is prime number ; Return '1' if count is equal to '2' else return '0' ; Function to print ' True ' or ' False ' according to condition of semiprime ; Driver code", "code": "#include <stdio.h> NEW_LINE int checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) while ( num % i == 0 ) num /= i , ++ cnt ; if ( num > 1 ) ++ cnt ; return cnt == 2 ; } void semiprime ( int n ) { if ( checkSemiprime ( n ) ) printf ( \" True STRNEWLINE \" ) ; else printf ( \" False STRNEWLINE \" ) ; } int main ( ) { int n = 6 ; semiprime ( n ) ; n = 8 ; semiprime ( n ) ; return 0 ; }"}
{"text": "Reverse Level Order Traversal | A recursive C program to print REVERSE level order traversal ; A binary tree node has data , pointer to left and right child ; Function protoypes ; Function to print REVERSE level order traversal a tree ; Print nodes at a given level ; Compute the \" height \" of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node . ; compute the height of each subtree ; use the larger one ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above functions ; Let us create trees shown in above diagram", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; void printGivenLevel ( struct node * root , int level ) ; int height ( struct node * node ) ; struct node * newNode ( int data ) ; void reverseLevelOrder ( struct node * root ) { int h = height ( root ) ; int i ; for ( i = h ; i >= 1 ; i -- ) printGivenLevel ( root , i ) ; } void printGivenLevel ( struct node * root , int level ) { if ( root == NULL ) return ; if ( level == 1 ) printf ( \" % d \u2581 \" , root -> data ) ; else if ( level > 1 ) { printGivenLevel ( root -> left , level - 1 ) ; printGivenLevel ( root -> right , level - 1 ) ; } } int height ( struct node * node ) { if ( node == NULL ) return 0 ; else { int lheight = height ( node -> left ) ; int rheight = height ( node -> right ) ; if ( lheight > rheight ) return ( lheight + 1 ) ; else return ( rheight + 1 ) ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( \" Level \u2581 Order \u2581 traversal \u2581 of \u2581 binary \u2581 tree \u2581 is \u2581 STRNEWLINE \" ) ; reverseLevelOrder ( root ) ; return 0 ; }"}
{"text": "Indexed Sequential Search | C program for Indexed Sequential Search ; Storing element ; Storing the index ; Driver code ; Element to search ; Function call", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void indexedSequentialSearch ( int arr [ ] , int n , int k ) { int elements [ 20 ] , indices [ 20 ] , temp , i , set = 0 ; int j = 0 , ind = 0 , start , end ; for ( i = 0 ; i < n ; i += 3 ) { elements [ ind ] = arr [ i ] ; indices [ ind ] = i ; ind ++ ; } if ( k < elements [ 0 ] ) { printf ( \" Not \u2581 found \" ) ; exit ( 0 ) ; } else { for ( i = 1 ; i <= ind ; i ++ ) if ( k <= elements [ i ] ) { start = indices [ i - 1 ] ; end = indices [ i ] ; set = 1 ; break ; } } if ( set == 0 ) { start = indices [ i - 1 ] ; end = n ; } for ( i = start ; i <= end ; i ++ ) { if ( k == arr [ i ] ) { j = 1 ; break ; } } if ( j == 1 ) printf ( \" Found \u2581 at \u2581 index \u2581 % d \" , i ) ; else printf ( \" Not \u2581 found \" ) ; } void main ( ) { int arr [ ] = { 6 , 7 , 8 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 8 ; indexedSequentialSearch ( arr , n , k ) ; }"}
{"text": "Next Smaller Element | Simple C program to print next smaller elements in a given array ; prints element and NSE pair for all elements of arr [ ] of size n ; Driver Code", "code": "#include <stdio.h> NEW_LINE void printNSE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } printf ( \" % d \u2581 - - \u2581 % d STRNEWLINE \" , arr [ i ] , next ) ; } } int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNSE ( arr , n ) ; return 0 ; }"}
{"text": "MSD ( Most Significant Digit ) Radix Sort | C program for the implementation of MSD Radix Sort using counting sort ( ) ; A utility function to print an array ; A utility function to get the digit at index d in a integer ; function to sort array using MSD Radix Sort recursively ; recursion break condition ; temp is created to easily swap strings in arr [ ] ; Store occurrences of most significant character from each integer in count [ ] ; Change count [ ] so that count [ ] now contains actual position of this digits in temp [ ] ; Build the temp ; Copy all integer of temp to arr [ ] , so that arr [ ] now contains partially sorted integers ; Recursively MSD_sort ( ) on each partially sorted integers set to sort them by their next digit ; function find the largest integer ; Main function to call MSD_sort ; Find the maximum number to know number of digits ; get the length of the largest integer ; function call ; Driver Code ; Input array ; Size of the array ; Print the unsorted array ; Function Call ; Print the sorted array", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE void print ( int * arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { printf ( \" % d , \u2581 \" , arr [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } int digit_at ( int x , int d ) { return ( int ) ( x / pow ( 10 , d - 1 ) ) % 10 ; } void MSD_sort ( int * arr , int lo , int hi , int d ) { if ( hi <= lo d < 1 ) { return ; } int count [ 10 + 2 ] = { 0 } ; int temp [ n ] ; for ( int i = lo ; i <= hi ; i ++ ) { int c = digit_at ( arr [ i ] , d ) ; count ++ ; } for ( int r = 0 ; r < 10 + 1 ; r ++ ) count [ r + 1 ] += count [ r ] ; for ( int i = lo ; i <= hi ; i ++ ) { int c = digit_at ( arr [ i ] , d ) ; temp [ count ++ ] = arr [ i ] ; } for ( int i = lo ; i <= hi ; i ++ ) { arr [ i ] = temp [ i - lo ] ; } for ( int r = 0 ; r < 10 ; r ++ ) MSD_sort ( arr , lo + count [ r ] , lo + count [ r + 1 ] - 1 , d - 1 ) ; } int getMax ( int arr [ ] , int n ) { int mx = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > mx ) mx = arr [ i ] ; return mx ; } void radixsort ( int * arr , int n ) { int m = getMax ( arr , n ) ; int d = floor ( log10 ( abs ( m ) ) ) + 1 ; MSD_sort ( arr , 0 , n - 1 , d ) ; } int main ( ) { int arr [ ] = { 9330 , 9950 , 718 , 8977 , 6790 , 95 , 9807 , 741 , 8586 , 5710 } ; n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Unsorted \u2581 array \u2581 : \u2581 \" ) ; print ( arr , n ) ; radixsort ( arr , n ) ; printf ( \" Sorted \u2581 array \u2581 : \u2581 \" ) ; print ( arr , n ) ; return 0 ; }"}
{"text": "In | Merge In Place in C ; Both sorted sub - arrays must be adjacent in ' a ' ' an ' is the length of the first sorted section in ' a ' ' bn ' is the length of the second sorted section in ' a ' ; Return right now if we 're done ; Do insertion sort to merge if size of sub - arrays are small enough ; p -- ) Insert Sort A into B ; p ++ ) Insert Sort B into A ; Find the pivot points . Basically this is just finding the point in ' a ' where we can swap in the first part of ' b ' such that after the swap the last element in ' a ' will be less than or equal to the least element in ' b ' ; Swap first part of b with last part of a ; Now merge the two sub - array pairings ; } merge_array_inplace ; Merge Sort Implementation ; Sort first and second halves ; Now merge the two sorted sub - arrays together ; Function to print an array ; Driver program to test sort utiliyy", "code": "#include <stddef.h> NEW_LINE #include <stdio.h> NEW_LINE #define __INSERT_THRESH  5 NEW_LINE #define __swap ( x , y )  (t = *(x), *(x) = *(y), *(y) = t) NEW_LINE static void merge ( int * a , size_t an , size_t bn ) { int * b = a + an , * e = b + bn , * s , t ; if ( an == 0 || bn == 0 || ! ( * b < * ( b - 1 ) ) ) return ; if ( an < __INSERT_THRESH && an <= bn ) { for ( int * p = b , * v ; p > a ; for ( v = p , s = p - 1 ; v < e && * v < * s ; s = v , v ++ ) __swap ( s , v ) ; return ; } if ( bn < __INSERT_THRESH ) { for ( int * p = b , * v ; p < e ; for ( s = p , v = p - 1 ; s > a && * s < * v ; s = v , v -- ) __swap ( s , v ) ; return ; } int * pa = a , * pb = b ; for ( s = a ; s < b && pb < e ; s ++ ) if ( * pb < * pa ) pb ++ ; else pa ++ ; pa += b - s ; for ( int * la = pa , * fb = b ; la < b ; la ++ , fb ++ ) __swap ( la , fb ) ; merge ( a , pa - a , pb - b ) ; merge ( b , pb - b , e - pb ) ; #undef __swap #undef __INSERT_THRESH void merge_sort ( int * a , size_t n ) { size_t m = ( n + 1 ) / 2 ; if ( m > 1 ) merge_sort ( a , m ) ; if ( n - m > 1 ) merge_sort ( a + m , n - m ) ; merge ( a , m , n - m ) ; } void print_array ( int a [ ] , size_t n ) { if ( n > 0 ) { printf ( \" % d \" , a [ 0 ] ) ; for ( size_t i = 1 ; i < n ; i ++ ) printf ( \" \u2581 % d \" , a [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } int main ( ) { int a [ ] = { 3 , 16 , 5 , 14 , 8 , 10 , 7 , 15 , 1 , 13 , 4 , 9 , 12 , 11 , 6 , 2 } ; size_t n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; merge_sort ( a , n ) ; print_array ( a , n ) ; return 0 ; }"}
{"text": "Channel Assignment Problem |  ; A Depth First Search based recursive function that returns true if a matching for vertex u is possible ; Try every receiver one by one ; If sender u has packets to send to receiver v and receiver v is not already mapped to any other sender just check if the number of packets is greater than '0' because only one packet can be sent in a time frame anyways ; Mark v as visited ; If receiver ' v ' is not assigned to any sender OR previously assigned sender for receiver v ( which is matchR [ v ] ) has an alternate receiver available . Since v is marked as visited in the above line , matchR [ v ] in the following recursive call will not get receiver ' v ' again ; Returns maximum number of packets that can be sent parallely in 1 time slot from sender to receiver ; An array to keep track of the receivers assigned to the senders . The value of matchR [ i ] is the sender ID assigned to receiver i . the value - 1 indicates nobody is assigned . ; Initially all receivers are not mapped to any senders ; Count of receivers assigned to senders ; Mark all receivers as not seen for next sender ; Find if the sender ' u ' can be assigned to the receiver ; Driver program to test above function", "code": "#include <iostream> NEW_LINE #include <string.h> NEW_LINE #include <vector> NEW_LINE #define M  3 NEW_LINE #define N  4 NEW_LINE using namespace std ; bool bpm ( int table [ M ] [ N ] , int u , bool seen [ ] , int matchR [ ] ) { for ( int v = 0 ; v < N ; v ++ ) { if ( table [ u ] [ v ] > 0 && ! seen [ v ] ) { seen [ v ] = true ; if ( matchR [ v ] < 0 || bpm ( table , matchR [ v ] , seen , matchR ) ) { matchR [ v ] = u ; return true ; } } } return false ; } int maxBPM ( int table [ M ] [ N ] ) { int matchR [ N ] ; memset ( matchR , -1 , sizeof ( matchR ) ) ; int result = 0 ; for ( int u = 0 ; u < M ; u ++ ) { bool seen [ N ] ; memset ( seen , 0 , sizeof ( seen ) ) ; if ( bpm ( table , u , seen , matchR ) ) result ++ ; } cout << \" The \u2581 number \u2581 of \u2581 maximum \u2581 packets \u2581 sent \u2581 in \u2581 the \u2581 time \u2581 slot \u2581 is \u2581 \" << result << \" STRNEWLINE \" ; for ( int x = 0 ; x < N ; x ++ ) if ( matchR [ x ] + 1 != 0 ) cout << \" T \" << matchR [ x ] + 1 << \" - > \u2581 R \" << x + 1 << \" STRNEWLINE \" ; return result ; } int main ( ) { int table [ M ] [ N ] = { { 0 , 2 , 0 } , { 3 , 0 , 1 } , { 2 , 4 , 0 } } ; int max_flow = maxBPM ( table ) ; return 0 ; }"}
{"text": "Decode an Encoded Base 64 String to ASCII String | C Program to decode a base64 Encoded string back to ASCII string ; char_set = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ \u2581 abcdefghijklmnopqrstuvwxyz0123456789 + / \" ; stores the bitstream . ; count_bits stores current number of bits in num . ; selects 4 characters from encoded string at a time . find the position of each encoded character in char_set and stores in num . ; make space for 6 bits . ; encoded [ i + j ] = ' E ' , ' E ' - ' A ' = 5 ' E ' has 5 th position in char_set . ; encoded [ i + j ] = ' e ' , ' e ' - ' a ' = 5 , 5 + 26 = 31 , ' e ' has 31 st position in char_set . ; encoded [ i + j ] = '8' , '8' - '0' = 8 8 + 52 = 60 , '8' has 60 th position in char_set . ; ' + ' occurs in 62 nd position in char_set . ; ' / ' occurs in 63 rd position in char_set . ; ( str [ i + j ] == ' = ' ) remove 2 bits to delete appended bits during encoding . ; 255 in binary is 11111111 ; Driver function ; Do not count last NULL character .", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define SIZE  100 NEW_LINE char * base64Decoder ( char encoded [ ] , int len_str ) { char * decoded_string ; decoded_string = ( char * ) malloc ( sizeof ( char ) * SIZE ) ; int i , j , k = 0 ; int num = 0 ; int count_bits = 0 ; for ( i = 0 ; i < len_str ; i += 4 ) { num = 0 , count_bits = 0 ; for ( j = 0 ; j < 4 ; j ++ ) { if ( encoded [ i + j ] != ' = ' ) { num = num << 6 ; count_bits += 6 ; } if ( encoded [ i + j ] >= ' A ' && encoded [ i + j ] <= ' Z ' ) num = num | ( encoded [ i + j ] - ' A ' ) ; else if ( encoded [ i + j ] >= ' a ' && encoded [ i + j ] <= ' z ' ) num = num | ( encoded [ i + j ] - ' a ' + 26 ) ; else if ( encoded [ i + j ] >= '0' && encoded [ i + j ] <= '9' ) num = num | ( encoded [ i + j ] - '0' + 52 ) ; else if ( encoded [ i + j ] == ' + ' ) num = num | 62 ; else if ( encoded [ i + j ] == ' / ' ) num = num | 63 ; else { num = num >> 2 ; count_bits -= 2 ; } } while ( count_bits != 0 ) { count_bits -= 8 ; decoded_string [ k ++ ] = ( num >> count_bits ) & 255 ; } } decoded_string [ k ] = ' \\0' ; return decoded_string ; } int main ( ) { char encoded_string [ ] = \" TUVOT04 = \" ; int len_str = sizeof ( encoded_string ) / sizeof ( encoded_string [ 0 ] ) ; len_str -= 1 ; printf ( \" Encoded \u2581 string \u2581 : \u2581 % s STRNEWLINE \" , encoded_string ) ; printf ( \" Decoded _ string \u2581 : \u2581 % s STRNEWLINE \" , base64Decoder ( encoded_string , len_str ) ) ; return 0 ; }"}
{"text": "Print list items containing all characters of a given word | C program to print all strings that contain all characters of a word ; prints list items having all characters of word ; Since calloc is used , map [ ] is initialized as 0 ; Set the values in map ; Get the length of given word ; Check each item of list if has all characters of word ; unset the bit so that strings like sss not printed ; Set the values in map for next item ; Driver program to test to pront printDups", "code": "# include <stdio.h> NEW_LINE # include <stdlib.h> NEW_LINE # include <string.h> NEW_LINE # define NO_OF_CHARS  256 NEW_LINE void print ( char * list [ ] , char * word , int list_size ) { int * map = ( int * ) calloc ( sizeof ( int ) , NO_OF_CHARS ) ; int i , j , count , word_size ; for ( i = 0 ; * ( word + i ) ; i ++ ) map [ * ( word + i ) ] = 1 ; word_size = strlen ( word ) ; for ( i = 0 ; i < list_size ; i ++ ) { for ( j = 0 , count = 0 ; * ( list [ i ] + j ) ; j ++ ) { if ( map [ * ( list [ i ] + j ) ] ) { count ++ ; map [ * ( list [ i ] + j ) ] = 0 ; } } if ( count == word_size ) printf ( \" % s \" , list [ i ] ) ; for ( j = 0 ; * ( word + j ) ; j ++ ) map [ * ( word + j ) ] = 1 ; } } int main ( ) { char str [ ] = \" sun \" ; char * list [ ] = { \" geeksforgeeks \" , \" unsorted \" , \" sunday \" , \" just \" , \" sss \" } ; print ( list , str , 5 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Given a string , find its first non | C program to find first non - repeating character ; Returns an array of size 256 containing count of characters in the passed char array ; The function returns index of first non - repeating character in a string . If all characters are repeating then returns - 1 ; To avoid memory leak ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE int * getCharCountArray ( char * str ) { int * count = ( int * ) calloc ( sizeof ( int ) , NO_OF_CHARS ) ; int i ; for ( i = 0 ; * ( str + i ) ; i ++ ) count [ * ( str + i ) ] ++ ; return count ; } int firstNonRepeating ( char * str ) { int * count = getCharCountArray ( str ) ; int index = -1 , i ; for ( i = 0 ; * ( str + i ) ; i ++ ) { if ( count [ * ( str + i ) ] == 1 ) { index = i ; break ; } } free ( count ) ; return index ; } int main ( ) { char str [ ] = \" geeksforgeeks \" ; int index = firstNonRepeating ( str ) ; if ( index == -1 ) printf ( \" Either \u2581 all \u2581 characters \u2581 are \u2581 repeating \u2581 or \u2581 \" \" string \u2581 is \u2581 empty \" ) ; else printf ( \" First \u2581 non - repeating \u2581 character \u2581 is \u2581 % c \" , str [ index ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Divide a string in N equal parts | C program to divide a string in n equal parts ; Function to print n equal parts of str ; Check if string can be divided in n equal parts ; Calculate the size of parts to find the division points ; length od string is 28 ; Print 4 equal parts of the string", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void divideString ( char * str , int n ) { int str_size = strlen ( str ) ; int i ; int part_size ; if ( str_size % n != 0 ) { printf ( \" Invalid \u2581 Input : \u2581 String \u2581 size \" ) ; printf ( \" \u2581 is \u2581 not \u2581 divisible \u2581 by \u2581 n \" ) ; return ; } part_size = str_size / n ; for ( i = 0 ; i < str_size ; i ++ ) { if ( i % part_size == 0 ) printf ( \" STRNEWLINE \" ) ; printf ( \" % c \" , str [ i ] ) ; } } int main ( ) { char * str = \" a _ simple _ divide _ string _ quest \" ; divideString ( str , 4 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program to check if three points are collinear | Slope based solution to check if three points are collinear . ; function to check if point collinear or not ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void collinear ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { if ( ( y3 - y2 ) * ( x2 - x1 ) == ( y2 - y1 ) * ( x3 - x2 ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; } int main ( ) { int x1 = 1 , x2 = 1 , x3 = 0 , y1 = 1 , y2 = 6 , y3 = 9 ; collinear ( x1 , y1 , x2 , y2 , x3 , y3 ) ; return 0 ; }"}
{"text": "Represent a given set of points by the best possible straight line | C Program to find m and c for a straight line given , x and y ; function to calculate m and c that best fit points represented by x [ ] and y [ ] ; Driver main function", "code": "#include <stdio.h> NEW_LINE void bestApproximate ( int x [ ] , int y [ ] , int n ) { int i , j ; float m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += ( x [ i ] * x [ i ] ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - ( sum_x * sum_x ) ) ; c = ( sum_y - m * sum_x ) / n ; printf ( \" m \u2581 = % \u2581 f \" , m ) ; printf ( \" c = % f \" , c ) ; } int main ( ) { int x [ ] = { 1 , 2 , 3 , 4 , 5 } ; int y [ ] = { 14 , 27 , 40 , 55 , 68 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; bestApproximate ( x , y , n ) ; return 0 ; }"}
{"text": "Minimum insertions to form a palindrome | DP | A Naive recursive program to find minimum number insertions needed to make a string palindrome ; Recursive function to find minimum number of insertions ; Base Cases ; Check if the first and last characters are same . On the basis of the comparison result , decide which subrpoblem ( s ) to call ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; } int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; } int main ( ) { char str [ ] = \" geeks \" ; printf ( \" % d \" , findMinInsertions ( str , 0 , strlen ( str ) - 1 ) ) ; return 0 ; }"}
{"text": "Morris traversal for Preorder | C program for Morris Preorder traversal ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Preorder traversal without recursion and without stack ; If left child is null , print the current node data . Move to right child . ; Find inorder predecessor ; If the right child of inorder predecessor already points to this node ; If right child doesn 't point to this node, then print this  node and make right child point to this node ; Function for sStandard preorder traversal ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void morrisTraversalPreorder ( struct node * root ) { while ( root ) { if ( root -> left == NULL ) { printf ( \" % d \u2581 \" , root -> data ) ; root = root -> right ; } else { struct node * current = root -> left ; while ( current -> right && current -> right != root ) current = current -> right ; if ( current -> right == root ) { current -> right = NULL ; root = root -> right ; } else { printf ( \" % d \u2581 \" , root -> data ) ; current -> right = root ; root = root -> left ; } } } } void preorder ( struct node * root ) { if ( root ) { printf ( \" % d \u2581 \" , root -> data ) ; preorder ( root -> left ) ; preorder ( root -> right ) ; } } int main ( ) { struct node * root = NULL ; root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 11 ) ; morrisTraversalPreorder ( root ) ; printf ( \" STRNEWLINE \" ) ; preorder ( root ) ; return 0 ; }"}
{"text": "Linked List | Set 2 ( Inserting a node ) | Given a reference ( pointer to pointer ) to the head of a list and an int , inserts a new node on the front of the list . ; 1 & 2 : Allocate the Node & Put in the data ; 3. Make next of new node as head ; 4. move the head to point to the new node", "code": "void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; }"}
{"text": "Linked List | Set 2 ( Inserting a node ) | Given a node prev_node , insert a new node after the given prev_node ; 1. check if the given prev_node is NULL ; 2. Allocate the Node & 3. Put in the data ; 4. Make next of new node as next of prev_node ; 5. move the next of prev_node as new_node", "code": "void insertAfter ( struct Node * prev_node , int new_data ) { if ( prev_node == NULL ) { printf ( \" the \u2581 given \u2581 previous \u2581 node \u2581 cannot \u2581 be \u2581 NULL \" ) ; return ; } struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = prev_node -> next ; prev_node -> next = new_node ; }"}
{"text": "Program for n 'th node from the end of a Linked List |", "code": "void printNthFromLast ( struct Node * head , int n ) { static int i = 0 ; if ( head == NULL ) return ; printNthFromLast ( head -> next , n ) ; if ( ++ i == n ) printf ( \" % d \" , head -> data ) ; }"}
{"text": "Detect loop in a linked list | C program to detect loop in a linked list ; Link list node ; allocate node ; put in the data ; link the old list off the new node ; move the head to point to the new node ; Driver program to test above function ; Start with the empty list ; Create a loop for testing", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int detectLoop ( struct Node * list ) { struct Node * slow_p = list , * fast_p = list ; while ( slow_p && fast_p && fast_p -> next ) { slow_p = slow_p -> next ; fast_p = fast_p -> next -> next ; if ( slow_p == fast_p ) { return 1 ; } } return 0 ; } int main ( ) { struct Node * head = NULL ; push ( & head , 20 ) ; push ( & head , 4 ) ; push ( & head , 15 ) ; push ( & head , 10 ) ; head -> next -> next -> next -> next = head ; if ( detectLoop ( head ) ) printf ( \" Loop \u2581 found \" ) ; else printf ( \" No \u2581 Loop \" ) ; return 0 ; }"}
{"text": "Function to check if a singly linked list is palindrome | Program to check if a linked list is palindrome ; Link list node ; Function to check if given linked list is palindrome or not ; To handle odd size list ; initialize result ; Get the middle of the list . Move slow_ptr by 1 and fast_ptrr by 2 , slow_ptr will have the middle node ; We need previous of the slow_ptr for linked lists with odd elements ; fast_ptr would become NULL when there are even elements in list . And not NULL for odd elements . We need to skip the middle node for odd case and store it somewhere so that we can restore the original list ; Now reverse the second half and compare it with first half ; NULL terminate first half ; Reverse the second half ; compare ; Reverse the second half again ; If there was a mid node ( odd size case ) which was not part of either first half or second half . ; Function to reverse the linked list Note that this function may change the head ; Function to check if two input lists have same data ; Both are empty reurn 1 ; Will reach here when one is NULL and other is not ; Push a node to linked list . Note that this function changes the head ; allocate node ; link the old list off the new node ; move the head to pochar to the new node ; A utility function to print a given linked list ; Drier program to test above function ; Start with the empty list", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { char data ; struct Node * next ; } ; void reverse ( struct Node * * ) ; bool compareLists ( struct Node * , struct Node * ) ; bool isPalindrome ( struct Node * head ) { struct Node * slow_ptr = head , * fast_ptr = head ; struct Node * second_half , * prev_of_slow_ptr = head ; struct Node * midnode = NULL ; bool res = true ; if ( head != NULL && head -> next != NULL ) { while ( fast_ptr != NULL && fast_ptr -> next != NULL ) { fast_ptr = fast_ptr -> next -> next ; prev_of_slow_ptr = slow_ptr ; slow_ptr = slow_ptr -> next ; } if ( fast_ptr != NULL ) { midnode = slow_ptr ; slow_ptr = slow_ptr -> next ; } second_half = slow_ptr ; prev_of_slow_ptr -> next = NULL ; reverse ( & second_half ) ; res = compareLists ( head , second_half ) ; reverse ( & second_half ) ; if ( midnode != NULL ) { prev_of_slow_ptr -> next = midnode ; midnode -> next = second_half ; } else prev_of_slow_ptr -> next = second_half ; } return res ; } void reverse ( struct Node * * head_ref ) { struct Node * prev = NULL ; struct Node * current = * head_ref ; struct Node * next ; while ( current != NULL ) { next = current -> next ; current -> next = prev ; prev = current ; current = next ; } * head_ref = prev ; } bool compareLists ( struct Node * head1 , struct Node * head2 ) { struct Node * temp1 = head1 ; struct Node * temp2 = head2 ; while ( temp1 && temp2 ) { if ( temp1 -> data == temp2 -> data ) { temp1 = temp1 -> next ; temp2 = temp2 -> next ; } else return 0 ; } if ( temp1 == NULL && temp2 == NULL ) return 1 ; return 0 ; } void push ( struct Node * * head_ref , char new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * ptr ) { while ( ptr != NULL ) { printf ( \" % c - > \" , ptr -> data ) ; ptr = ptr -> next ; } printf ( \" NULL STRNEWLINE \" ) ; } int main ( ) { struct Node * head = NULL ; char str [ ] = \" abacaba \" ; int i ; for ( i = 0 ; str [ i ] != ' \\0' ; i ++ ) { push ( & head , str [ i ] ) ; printList ( head ) ; isPalindrome ( head ) ? printf ( \" Is \u2581 Palindrome STRNEWLINE STRNEWLINE \" ) : printf ( \" Not \u2581 Palindrome STRNEWLINE STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "Swap nodes in a linked list without swapping data | This program swaps the nodes of linked list rather than swapping the field from the nodes . ; Function to swap nodes x and y in linked list by changing links ; Nothing to do if x and y are same ; Search for x ( keep track of prevX and CurrX ; Search for y ( keep track of prevY and CurrY ; If either x or y is not present , nothing to do ; If x is not head of linked list ; Else make y as new head ; If y is not head of linked list ; Else make x as new head ; Swap next pointers ; Function to add a node at the beginning of List ; allocate node and put in the data ; link the old list off the new node ; move the head to point to the new node ; Function to print nodes in a given linked list ; Driver program to test above function ; The constructed linked list is : 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void swapNodes ( struct Node * * head_ref , int x , int y ) { if ( x == y ) return ; struct Node * prevX = NULL , * currX = * head_ref ; while ( currX && currX -> data != x ) { prevX = currX ; currX = currX -> next ; } struct Node * prevY = NULL , * currY = * head_ref ; while ( currY && currY -> data != y ) { prevY = currY ; currY = currY -> next ; } if ( currX == NULL currY == NULL ) return ; if ( prevX != NULL ) prevX -> next = currY ; else * head_ref = currY ; if ( prevY != NULL ) prevY -> next = currX ; else * head_ref = currX ; struct Node * temp = currY -> next ; currY -> next = currX -> next ; currX -> next = temp ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * node ) { while ( node != NULL ) { printf ( \" % d \u2581 \" , node -> data ) ; node = node -> next ; } } int main ( ) { struct Node * start = NULL ; push ( & start , 7 ) ; push ( & start , 6 ) ; push ( & start , 5 ) ; push ( & start , 4 ) ; push ( & start , 3 ) ; push ( & start , 2 ) ; push ( & start , 1 ) ; printf ( \" Linked list before calling swapNodes ( ) \" printList ( start ) ; swapNodes ( & start , 4 , 3 ) ; printf ( \" Linked list after calling swapNodes ( ) \" printList ( start ) ; return 0 ; }"}
{"text": "Pairwise swap elements of a given linked list | Recursive function to pairwise swap elements of a linked list ; There must be at - least two nodes in the list ; Swap the node 's data with data of next node  ; Call pairWiseSwap ( ) for rest of the list", "code": "void pairWiseSwap ( struct node * head ) { if ( head != NULL && head -> next != NULL ) { swap ( & head -> data , & head -> next -> data ) ; pairWiseSwap ( head -> next -> next ) ; } }"}
{"text": "Sorted insert for circular linked list | Case 2 of the above algo ; swap the data part of head node and new node assuming that we have a function swap ( int * , int * )", "code": "else if ( current -> data >= new_node -> data ) { swap ( & ( current -> data ) , & ( new_node -> data ) ) ; new_node -> next = ( * head_ref ) -> next ; ( * head_ref ) -> next = new_node ; }"}
{"text": "Doubly Linked List | Set 1 ( Introduction and Insertion ) | Given a reference ( pointer to pointer ) to the head of a list and an int , inserts a new node on the front of the list . ; 1. allocate node * 2. put in the data ; 3. Make next of new node as head and previous as NULL ; 4. change prev of head node to new node ; 5. move the head to point to the new node", "code": "void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; new_node -> prev = NULL ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ; ( * head_ref ) = new_node ; }"}
{"text": "Doubly Linked List | Set 1 ( Introduction and Insertion ) | Given a node as prev_node , insert a new node after the given node ; 1. check if the given prev_node is NULL ; 2. allocate node * 3. put in the data ; 4. Make next of new node as next of prev_node ; 5. Make the next of prev_node as new_node ; 6. Make prev_node as previous of new_node ; 7. Change previous of new_node 's next node", "code": "void insertAfter ( struct Node * prev_node , int new_data ) { if ( prev_node == NULL ) { printf ( \" the \u2581 given \u2581 previous \u2581 node \u2581 cannot \u2581 be \u2581 NULL \" ) ; return ; } struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = prev_node -> next ; prev_node -> next = new_node ; new_node -> prev = prev_node ; if ( new_node -> next != NULL ) new_node -> next -> prev = new_node ; }"}
{"text": "Doubly Linked List | Set 1 ( Introduction and Insertion ) | Given a reference ( pointer to pointer ) to the head of a DLL and an int , appends a new node at the end ; 1. allocate node 2. put in the data ; 3. This new node is going to be the last node , so make next of it as NULL ; 4. If the Linked List is empty , then make the new node as head ; 5. Else traverse till the last node ; 6. Change the next of last node ; 7. Make last node as previous of new node", "code": "void append ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * last = * head_ref ; new_node -> data = new_data ; new_node -> next = NULL ; if ( * head_ref == NULL ) { new_node -> prev = NULL ; * head_ref = new_node ; return ; } while ( last -> next != NULL ) last = last -> next ; last -> next = new_node ; new_node -> prev = last ; return ; }"}
{"text": "Sorted insert in a doubly linked list with head and tail pointers | C program to insetail nodes in doubly linked list such that list remains in ascending order on printing from left to right ; A linked list node ; Function to insetail new node ; If first node to be insetailed in doubly linked list ; If node to be insetailed has value less than first node ; If node to be insetailed has value more than last node ; Find the node before which we need to insert p . ; Insert new node before temp ; Function to print nodes in from left to right ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { struct Node * prev ; int info ; struct Node * next ; } ; void nodeInsetail ( struct Node * * head , struct Node * * tail , int key ) { struct Node * p = new Node ; p -> info = key ; p -> next = NULL ; if ( ( * head ) == NULL ) { ( * head ) = p ; ( * tail ) = p ; ( * head ) -> prev = NULL ; return ; } if ( ( p -> info ) < ( ( * head ) -> info ) ) { p -> prev = NULL ; ( * head ) -> prev = p ; p -> next = ( * head ) ; ( * head ) = p ; return ; } if ( ( p -> info ) > ( ( * tail ) -> info ) ) { p -> prev = ( * tail ) ; ( * tail ) -> next = p ; ( * tail ) = p ; return ; } temp = ( * head ) -> next ; while ( ( temp -> info ) < ( p -> info ) ) temp = temp -> next ; ( temp -> prev ) -> next = p ; p -> prev = temp -> prev ; temp -> prev = p ; p -> next = temp ; } void printList ( struct Node * temp ) { while ( temp != NULL ) { printf ( \" % d \u2581 \" , temp -> info ) ; temp = temp -> next ; } } int main ( ) { struct Node * left = NULL , * right = NULL ; nodeInsetail ( & left , & right , 30 ) ; nodeInsetail ( & left , & right , 50 ) ; nodeInsetail ( & left , & right , 90 ) ; nodeInsetail ( & left , & right , 10 ) ; nodeInsetail ( & left , & right , 40 ) ; nodeInsetail ( & left , & right , 110 ) ; nodeInsetail ( & left , & right , 60 ) ; nodeInsetail ( & left , & right , 95 ) ; nodeInsetail ( & left , & right , 23 ) ; printf ( \" Doubly linked list on printing \" \u2581 \" from left to right \" printList ( left ) ; return 0 ; }"}
{"text": "Practice questions for Linked List and Recursion |", "code": "struct Node { int data ; struct Node * next ; } ;"}
{"text": "Practice questions for Linked List and Recursion |", "code": "void fun1 ( struct Node * head ) { if ( head == NULL ) return ; fun1 ( head -> next ) ; printf ( \" % d \u2581 \" , head -> data ) ; }"}
{"text": "Practice questions for Linked List and Recursion |", "code": "void fun2 ( struct Node * head ) { if ( head == NULL ) return ; printf ( \" % d \u2581 \" , head -> data ) ; if ( head -> next != NULL ) fun2 ( head -> next -> next ) ; printf ( \" % d \u2581 \" , head -> data ) ; }"}
{"text": "Practice questions for Linked List and Recursion |  ; A linked list node ; Prints a linked list in reverse manner ; prints alternate nodes of a Linked List , first from head to end , and then from end to head . ; Given a reference ( pointer to pointer ) to the head of a list and an int , push a new node on the front of the list . ; allocate node ; put in the data ; link the old list off the new node ; move the head to point to the new node ; Driver program to test above functions ; Start with the empty list ; Using push ( ) to construct below list 1 -> 2 -> 3 -> 4 -> 5", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void fun1 ( struct Node * head ) { if ( head == NULL ) return ; fun1 ( head -> next ) ; printf ( \" % d \u2581 \" , head -> data ) ; } void fun2 ( struct Node * start ) { if ( start == NULL ) return ; printf ( \" % d \u2581 \" , start -> data ) ; if ( start -> next != NULL ) fun2 ( start -> next -> next ) ; printf ( \" % d \u2581 \" , start -> data ) ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * head = NULL ; push ( & head , 5 ) ; push ( & head , 4 ) ; push ( & head , 3 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; printf ( \" Output \u2581 of \u2581 fun1 ( ) \u2581 for \u2581 list \u2581 1 - > 2 - > 3 - > 4 - > 5 \u2581 STRNEWLINE \" ) ; fun1 ( head ) ; printf ( \" Output of fun2 ( ) for list 1 -> 2 -> 3 -> 4 -> 5 \" fun2 ( head ) ; getchar ( ) ; return 0 ; }"}
{"text": "Squareroot ( n ) | C program to find sqrt ( n ) 'th node  of a linked list ; Linked list node ; Function to get the sqrt ( n ) th node of a linked list ; Traverse the list ; check if j = sqrt ( i ) ; for first node ; increment j if j = sqrt ( i ) ; return node 's data ; function to add a new node at the beginning of the list ; allocate node ; put in the data ; link the old list off the new node ; move the head to point to the new node ; Driver program to test above function ; Start with the empty list", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; int printsqrtn ( struct Node * head ) { struct Node * sqrtn = NULL ; int i = 1 , j = 1 ; while ( head != NULL ) { if ( i == j * j ) { if ( sqrtn == NULL ) sqrtn = head ; else sqrtn = sqrtn -> next ; j ++ ; } i ++ ; head = head -> next ; } return sqrtn -> data ; } void print ( struct Node * head ) { while ( head != NULL ) { printf ( \" % d \u2581 \" , head -> data ) ; head = head -> next ; } printf ( \" STRNEWLINE \" ) ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * head = NULL ; push ( & head , 40 ) ; push ( & head , 30 ) ; push ( & head , 20 ) ; push ( & head , 10 ) ; printf ( \" Given \u2581 linked \u2581 list \u2581 is : \" ) ; print ( head ) ; printf ( \" sqrt ( n ) th \u2581 node \u2581 is \u2581 % d \u2581 \" , printsqrtn ( head ) ) ; return 0 ; }"}
{"text": "Find the node with minimum value in a Binary Search Tree |  ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Give a binary search tree and a number , inserts a new node with the given number in the correct place in the tree . Returns the new root pointer which the caller should then use ( the standard trick to avoid using reference parameters ) . ; 1. If the tree is empty , return a new , single node ; 2. Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; Given a non - empty binary search tree , return the minimum data value found in that tree . Note that the entire tree does not need to be searched . ; loop down to find the leftmost leaf ; Driver program to test sameTree function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } struct node * insert ( struct node * node , int data ) { if ( node == NULL ) return ( newNode ( data ) ) ; else { if ( data <= node -> data ) node -> left = insert ( node -> left , data ) ; else node -> right = insert ( node -> right , data ) ; return node ; } } int minValue ( struct node * node ) { struct node * current = node ; while ( current -> left != NULL ) { current = current -> left ; } return ( current -> data ) ; } int main ( ) { struct node * root = NULL ; root = insert ( root , 4 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 6 ) ; insert ( root , 5 ) ; printf ( \" Minimum value in BST is % d \" , minValue ( root ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Construct Tree from given Inorder and Preorder traversals | program to construct tree using inorder and preorder traversals ; A binary tree node has data , pointer to left child and a pointer to right child ; Prototypes for utility functions ; Recursive function to construct binary of size len from Inorder traversal in [ ] and Preorder traversal pre [ ] . Initial values of inStrt and inEnd should be 0 and len - 1. The function doesn 't  do any error checking for cases where inorder and preorder  do not form a tree  ; Pick current node from Preorder traversal using preIndex and increment preIndex ; If this node has no children then return ; Else find the index of this node in Inorder traversal ; Using index in Inorder traversal , construct left and right subtress ; Function to find index of value in arr [ start ... end ] The function assumes that value is present in in [ ] ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; This funtcion is here just to test buildTree ( ) ; first recur on left child ; then print the data of node ; now recur on right child ; Driver program to test above functions ; Let us test the built tree by printing Insorder traversal", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { char data ; struct node * left ; struct node * right ; } ; int search ( char arr [ ] , int strt , int end , char value ) ; struct node * newNode ( char data ) ; struct node * buildTree ( char in [ ] , char pre [ ] , int inStrt , int inEnd ) { static int preIndex = 0 ; if ( inStrt > inEnd ) return NULL ; struct node * tNode = newNode ( pre [ preIndex ++ ] ) ; if ( inStrt == inEnd ) return tNode ; int inIndex = search ( in , inStrt , inEnd , tNode -> data ) ; tNode -> left = buildTree ( in , pre , inStrt , inIndex - 1 ) ; tNode -> right = buildTree ( in , pre , inIndex + 1 , inEnd ) ; return tNode ; } int search ( char arr [ ] , int strt , int end , char value ) { int i ; for ( i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) return i ; } } struct node * newNode ( char data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % c \u2581 \" , node -> data ) ; printInorder ( node -> right ) ; } int main ( ) { char in [ ] = { ' D ' , ' B ' , ' E ' , ' A ' , ' F ' , ' C ' } ; char pre [ ] = { ' A ' , ' B ' , ' D ' , ' E ' , ' C ' , ' F ' } ; int len = sizeof ( in ) / sizeof ( in [ 0 ] ) ; struct node * root = buildTree ( in , pre , 0 , len - 1 ) ; printf ( \" Inorder \u2581 traversal \u2581 of \u2581 the \u2581 constructed \u2581 tree \u2581 is \u2581 STRNEWLINE \" ) ; printInorder ( root ) ; getchar ( ) ; }"}
{"text": "Lowest Common Ancestor in a Binary Search Tree . | A recursive C program to find LCA of two nodes n1 and n2 . ; Function to find LCA of n1 and n2 . The function assumes that both n1 and n2 are present in BST ; If both n1 and n2 are smaller than root , then LCA lies in left ; If both n1 and n2 are greater than root , then LCA lies in right ; Helper function that allocates a new node with the given data . ; Driver program to test lca ( ) ; Let us construct the BST shown in the above figure", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * lca ( struct node * root , int n1 , int n2 ) { while ( root != NULL ) { if ( root -> data > n1 && root -> data > n2 ) root = root -> left ; else if ( root -> data < n1 && root -> data < n2 ) root = root -> right ; else break ; } return root ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 22 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; int n1 = 10 , n2 = 14 ; struct node * t = lca ( root , n1 , n2 ) ; printf ( \" LCA \u2581 of \u2581 % d \u2581 and \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , n1 , n2 , t -> data ) ; n1 = 14 , n2 = 8 ; t = lca ( root , n1 , n2 ) ; printf ( \" LCA \u2581 of \u2581 % d \u2581 and \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , n1 , n2 , t -> data ) ; n1 = 10 , n2 = 22 ; t = lca ( root , n1 , n2 ) ; printf ( \" LCA \u2581 of \u2581 % d \u2581 and \u2581 % d \u2581 is \u2581 % d \u2581 STRNEWLINE \" , n1 , n2 , t -> data ) ; getchar ( ) ; return 0 ; }"}
{"text": "A program to check if a binary tree is BST or not |  ; false if left is > than node ; false if right is < than node ; false if , recursively , the left or right is not a BST ; passing all that , it 's a BST", "code": "int isBST ( struct node * node ) { if ( node == NULL ) return 1 ; if ( node -> left != NULL && node -> left -> data > node -> data ) return 0 ; if ( node -> right != NULL && node -> right -> data < node -> data ) return 0 ; if ( ! isBST ( node -> left ) || ! isBST ( node -> right ) ) return 0 ; return 1 ; }"}
{"text": "A program to check if a binary tree is BST or not | Returns true if a binary tree is a binary search tree ; false if the max of the left is > than us ; false if the min of the right is <= than us ; false if , recursively , the left or right is not a BST ; passing all that , it 's a BST", "code": "int isBST ( struct node * node ) { if ( node == NULL ) return 1 ; if ( node -> left != NULL && maxValue ( node -> left ) > node -> data ) return 0 ; if ( node -> right != NULL && minValue ( node -> right ) < node -> data ) return 0 ; if ( ! isBST ( node -> left ) || ! isBST ( node -> right ) ) return 0 ; return 1 ; }"}
{"text": "Check if each internal node of a BST has exactly one child | Check if each internal node of BST has only one child ; driver program to test above function", "code": "#include <stdio.h> NEW_LINE bool hasOnlyOneChild ( int pre [ ] , int size ) { int nextDiff , lastDiff ; for ( int i = 0 ; i < size - 1 ; i ++ ) { nextDiff = pre [ i ] - pre [ i + 1 ] ; lastDiff = pre [ i ] - pre [ size - 1 ] ; if ( nextDiff * lastDiff < 0 ) return false ; ; } return true ; } int main ( ) { int pre [ ] = { 8 , 3 , 5 , 7 , 6 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; if ( hasOnlyOneChild ( pre , size ) == true ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Check if each internal node of a BST has exactly one child | Check if each internal node of BST has only one child ; Initialize min and max using last two elements ; Every element must be either smaller than min or greater than max ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int hasOnlyOneChild ( int pre [ ] , int size ) { int min , max ; if ( pre [ size - 1 ] > pre [ size - 2 ] ) { max = pre [ size - 1 ] ; min = pre [ size - 2 ] ) : else { max = pre [ size - 2 ] ; min = pre [ size - 1 ] ; } for ( int i = size - 3 ; i >= 0 ; i -- ) { if ( pre [ i ] < min ) min = pre [ i ] ; else if ( pre [ i ] > max ) max = pre [ i ] ; else return false ; } return true ; } int main ( ) { int pre [ ] = { 8 , 3 , 5 , 7 , 6 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; if ( hasOnlyOneChild ( pre , size ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "AVL with duplicate keys | C ++ program of AVL tree that handles duplicates ; An AVL tree node ; A utility function to get maximum of two integers ; A utility function to get height of the tree ; A utility function to get maximum of two integers ; Helper function that allocates a new node with the given key and NULL left and right pointers . ; new node is initially added at leaf ; A utility function to right rotate subtree rooted with y See the diagram given above . ; Perform rotation ; Update heights ; Return new root ; A utility function to left rotate subtree rooted with x See the diagram given above . ; Perform rotation ; Update heights ; Return new root ; Get Balance factor of node N ; 1. Perform the normal BST rotation ; If key already exists in BST , increment count and return ; Otherwise , recur down the tree ; 2. Update height of this ancestor node ; 3. Get the balance factor of this ancestor node to check whether this node became unbalanced ; If this node becomes unbalanced , then there are 4 cases Left Left Case ; Right Right Case ; Left Right Case ; Right Left Case ; return the ( unchanged ) node pointer ; Given a non - empty binary search tree , return the node with minimum key value found in that tree . Note that the entire tree does not need to be searched . ; loop down to find the leftmost leaf ; STEP 1 : PERFORM STANDARD BST DELETE ; If the key to be deleted is smaller than the root 's key,  then it lies in left subtree ; If the key to be deleted is greater than the root 's key,  then it lies in right subtree ; if key is same as root 's key, then This is the node  to be deleted ; If key is present more than once , simply decrement count and return ; Else , delete the node node with only one child or no child ; No child case ; One child case ; Copy the contents of the non - empty child ; node with two children : Get the inorder successor ( smallest in the right subtree ) ; Copy the inorder successor 's data to this node and update the count ; Delete the inorder successor ; If the tree had only one node then return ; STEP 2 : UPDATE HEIGHT OF THE CURRENT NODE ; STEP 3 : GET THE BALANCE FACTOR OF THIS NODE ( to check whether this node became unbalanced ) ; If this node becomes unbalanced , then there are 4 cases Left Left Case ; Left Right Case ; Right Right Case ; Right Left Case ; A utility function to print preorder traversal of the tree . The function also prints height of every node ; Driver program to test above function ; Constructing tree given in the above figure", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; struct node * left ; struct node * right ; int height ; int count ; } ; int max ( int a , int b ) ; int height ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> height ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ; node -> height = 1 ; node -> count = 1 ; return ( node ) ; } struct node * rightRotate ( struct node * y ) { struct node * x = y -> left ; struct node * T2 = x -> right ; x -> right = y ; y -> left = T2 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; return x ; } struct node * leftRotate ( struct node * x ) { struct node * y = x -> right ; struct node * T2 = y -> left ; y -> left = x ; x -> right = T2 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; return y ; } int getBalance ( struct node * N ) { if ( N == NULL ) return 0 ; return height ( N -> left ) - height ( N -> right ) ; } struct node * insert ( struct node * node , int key ) { if ( node == NULL ) return ( newNode ( key ) ) ; if ( key == node -> key ) { ( node -> count ) ++ ; return node ; } if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ; node -> height = max ( height ( node -> left ) , height ( node -> right ) ) + 1 ; int balance = getBalance ( node ) ; if ( balance > 1 && key < node -> left -> key ) return rightRotate ( node ) ; if ( balance < -1 && key > node -> right -> key ) return leftRotate ( node ) ; if ( balance > 1 && key > node -> left -> key ) { node -> left = leftRotate ( node -> left ) ; return rightRotate ( node ) ; } if ( balance < -1 && key < node -> right -> key ) { node -> right = rightRotate ( node -> right ) ; return leftRotate ( node ) ; } return node ; } struct node * minValueNode ( struct node * node ) { struct node * current = node ; while ( current -> left != NULL ) current = current -> left ; return current ; } struct node * deleteNode ( struct node * root , int key ) { if ( root == NULL ) return root ; if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ; else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ; else { if ( root -> count > 1 ) { ( root -> count ) -- ; return ; } if ( ( root -> left == NULL ) || ( root -> right == NULL ) ) { struct node * temp = root -> left ? root -> left : root -> right ; if ( temp == NULL ) { temp = root ; root = NULL ; } else * root = * temp ; free ( temp ) ; } else { struct node * temp = minValueNode ( root -> right ) ; root -> key = temp -> key ; root -> count = temp -> count ; temp -> count = 1 ; root -> right = deleteNode ( root -> right , temp -> key ) ; } } if ( root == NULL ) return root ; root -> height = max ( height ( root -> left ) , height ( root -> right ) ) + 1 ; int balance = getBalance ( root ) ; if ( balance > 1 && getBalance ( root -> left ) >= 0 ) return rightRotate ( root ) ; if ( balance > 1 && getBalance ( root -> left ) < 0 ) { root -> left = leftRotate ( root -> left ) ; return rightRotate ( root ) ; } if ( balance < -1 && getBalance ( root -> right ) <= 0 ) return leftRotate ( root ) ; if ( balance < -1 && getBalance ( root -> right ) > 0 ) { root -> right = rightRotate ( root -> right ) ; return leftRotate ( root ) ; } return root ; } void preOrder ( struct node * root ) { if ( root != NULL ) { printf ( \" % d ( % d ) \u2581 \" , root -> key , root -> count ) ; preOrder ( root -> left ) ; preOrder ( root -> right ) ; } } int main ( ) { struct node * root = NULL ; root = insert ( root , 9 ) ; root = insert ( root , 5 ) ; root = insert ( root , 10 ) ; root = insert ( root , 5 ) ; root = insert ( root , 9 ) ; root = insert ( root , 7 ) ; root = insert ( root , 17 ) ; printf ( \" Pre \u2581 order \u2581 traversal \u2581 of \u2581 the \u2581 constructed \u2581 AVL \u2581 tree \u2581 is \u2581 STRNEWLINE \" ) ; preOrder ( root ) ; root = deleteNode ( root , 9 ) ; printf ( \" Pre order traversal after deletion of 9 \" preOrder ( root ) ; return 0 ; }"}
{"text": "Inorder Successor in Binary Search Tree |  ; A binary tree node has data , the pointer to left child and a pointer to right child ; Give a binary search tree and a number , inserts a new node with the given number in the correct place in the tree . Returns the new root pointer which the caller should then use ( the standard trick to avoid using reference parameters ) . ; 1. If the tree is empty , return a new , single node ; 2. Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; step 1 of the above algorithm ; step 2 of the above algorithm ; Given a non - empty binary search tree , return the minimum data value found in that tree . Note that the entire tree does not need to be searched . ; loop down to find the leftmost leaf ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; struct node * parent ; } ; struct node * minValue ( struct node * node ) ; struct node * insert ( struct node * node , int data ) { if ( node == NULL ) return ( newNode ( data ) ) ; else { struct node * temp ; if ( data <= node -> data ) { temp = insert ( node -> left , data ) ; node -> left = temp ; temp -> parent = node ; } else { temp = insert ( node -> right , data ) ; node -> right = temp ; temp -> parent = node ; } return node ; } } struct node * inOrderSuccessor ( struct node * root , struct node * n ) { if ( n -> right != NULL ) return minValue ( n -> right ) ; struct node * p = n -> parent ; while ( p != NULL && n == p -> right ) { n = p ; p = p -> parent ; } return p ; } struct node * minValue ( struct node * node ) { struct node * current = node ; while ( current -> left != NULL ) { current = current -> left ; } return current ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> parent = NULL ; return ( node ) ; } int main ( ) { struct node * root = NULL , * temp , * succ , * min ; root = insert ( root , 20 ) ; root = insert ( root , 8 ) ; root = insert ( root , 22 ) ; root = insert ( root , 4 ) ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 14 ) ; temp = root -> left -> right -> right ; succ = inOrderSuccessor ( root , temp ) ; if ( succ != NULL ) printf ( \" Inorder Successor of % d is % d \" , temp -> data , succ -> data ) ; else printf ( \" Inorder Successor doesn ' exit \" getchar ( ) ; return 0 ; }"}
{"text": "Three numbers in a BST that adds upto zero | A C program to check if there is a triplet with sum equal to 0 in a given BST ; A BST node has key , and left and right pointers ; A function to convert given BST to Doubly Linked List . left pointer is used as previous pointer and right pointer is used as next pointer . The function sets * head to point to first and * tail to point to last node of converted DLL ; Base case ; First convert the left subtree ; Then change left of current root as last node of left subtree ; If tail is not NULL , then set right of tail as root , else current node is head ; Update tail ; Finally , convert right subtree ; This function returns true if there is pair in DLL with sum equal to given sum . The algorithm is similar to hasArrayTwoCandidates ( ) tinyurl . com / dy6palr in method 1 of http : ; The main function that returns true if there is a 0 sum triplet in BST otherwise returns false ; Check if the given BST is empty ; Convert given BST to doubly linked list . head and tail store the pointers to first and last nodes in DLLL ; Now iterate through every node and find if there is a pair with sum equal to - 1 * heaf -> key where head is current node ; If there is a pair with sum equal to - 1 * head -> key , then return true else move forward ; If we reach here , then there was no 0 sum triplet ; A utility function to create a new BST node with key as given num ; A utility function to insert a given key to BST ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE struct node { int key ; struct node * left ; struct node * right ; } ; void convertBSTtoDLL ( node * root , node * * head , node * * tail ) { if ( root == NULL ) return ; if ( root -> left ) convertBSTtoDLL ( root -> left , head , tail ) ; root -> left = * tail ; if ( * tail ) ( * tail ) -> right = root ; else * head = root ; * tail = root ; if ( root -> right ) convertBSTtoDLL ( root -> right , head , tail ) ; } bool isPresentInDLL ( node * head , node * tail , int sum ) { while ( head != tail ) { int curr = head -> key + tail -> key ; if ( curr == sum ) return true ; else if ( curr > sum ) tail = tail -> left ; else head = head -> right ; } return false ; } bool isTripletPresent ( node * root ) { if ( root == NULL ) return false ; node * head = NULL ; node * tail = NULL ; convertBSTtoDLL ( root , & head , & tail ) ; while ( ( head -> right != tail ) && ( head -> key < 0 ) ) { if ( isPresentInDLL ( head -> right , tail , -1 * head -> key ) ) return true ; else head = head -> right ; } return false ; } node * newNode ( int num ) { node * temp = new node ; temp -> key = num ; temp -> left = temp -> right = NULL ; return temp ; } node * insert ( node * root , int key ) { if ( root == NULL ) return newNode ( key ) ; if ( root -> key > key ) root -> left = insert ( root -> left , key ) ; else root -> right = insert ( root -> right , key ) ; return root ; } int main ( ) { node * root = NULL ; root = insert ( root , 6 ) ; root = insert ( root , -13 ) ; root = insert ( root , 14 ) ; root = insert ( root , -8 ) ; root = insert ( root , 15 ) ; root = insert ( root , 13 ) ; root = insert ( root , 7 ) ; if ( isTripletPresent ( root ) ) printf ( \" Present \" ) ; else printf ( \" Not \u2581 Present \" ) ; return 0 ; }"}
{"text": "Find a pair with given sum in a Balanced BST | In a balanced binary search tree isPairPresent two element which sums to a given value time O ( n ) space O ( logn ) ; A BST node ; Stack type ; A utility function to create a stack of given size ; BASIC OPERATIONS OF STACK ; Returns true if a pair with target sum exists in BST , otherwise false ; Create two stacks . s1 is used for normal inorder traversal and s2 is used for reverse inorder traversal ; Note the sizes of stacks is MAX_SIZE , we can find the tree size and fix stack size as O ( Logn ) for balanced trees like AVL and Red Black tree . We have used MAX_SIZE to keep the code simple done1 , val1 and curr1 are used for normal inorder traversal using s1 done2 , val2 and curr2 are used for reverse inorder traversal using s2 ; The loop will break when we either find a pair or one of the two traversals is complete ; Find next node in normal Inorder traversal . See following post www . geeksforgeeks . org / inorder - tree - traversal - without - recursion / https : ; Find next node in REVERSE Inorder traversal . The only difference between above and below loop is , in below loop right subtree is traversed before left subtree ; If we find a pair , then print the pair and return . The first condition makes sure that two same values are not added ; If sum of current values is smaller , then move to next node in normal inorder traversal ; If sum of current values is greater , then move to next node in reverse inorder traversal ; If any of the inorder traversals is over , then there is no pair so return false ; A utility function to create BST node ; Driver program to test above functions ; 15 / \\ 10 20 / \\ / \\ 8 12 16 25", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define MAX_SIZE  100 NEW_LINE struct node { int val ; struct node * left , * right ; } ; struct Stack { int size ; int top ; struct node * * array ; } ; struct Stack * createStack ( int size ) { struct Stack * stack = ( struct Stack * ) malloc ( sizeof ( struct Stack ) ) ; stack -> size = size ; stack -> top = -1 ; stack -> array = ( struct node * * ) malloc ( stack -> size * sizeof ( struct node * ) ) ; return stack ; } int isFull ( struct Stack * stack ) { return stack -> top - 1 == stack -> size ; } int isEmpty ( struct Stack * stack ) { return stack -> top == -1 ; } void push ( struct Stack * stack , struct node * node ) { if ( isFull ( stack ) ) return ; stack -> array [ ++ stack -> top ] = node ; } struct node * pop ( struct Stack * stack ) { if ( isEmpty ( stack ) ) return NULL ; return stack -> array [ stack -> top -- ] ; } bool isPairPresent ( struct node * root , int target ) { struct Stack * s1 = createStack ( MAX_SIZE ) ; struct Stack * s2 = createStack ( MAX_SIZE ) ; bool done1 = false , done2 = false ; int val1 = 0 , val2 = 0 ; struct node * curr1 = root , * curr2 = root ; while ( 1 ) { while ( done1 == false ) { if ( curr1 != NULL ) { push ( s1 , curr1 ) ; curr1 = curr1 -> left ; } else { if ( isEmpty ( s1 ) ) done1 = 1 ; else { curr1 = pop ( s1 ) ; val1 = curr1 -> val ; curr1 = curr1 -> right ; done1 = 1 ; } } } while ( done2 == false ) { if ( curr2 != NULL ) { push ( s2 , curr2 ) ; curr2 = curr2 -> right ; } else { if ( isEmpty ( s2 ) ) done2 = 1 ; else { curr2 = pop ( s2 ) ; val2 = curr2 -> val ; curr2 = curr2 -> left ; done2 = 1 ; } } } if ( ( val1 != val2 ) && ( val1 + val2 ) == target ) { printf ( \" Pair Found : % d + % d = % d \" , val1 , val2 , target ) ; return true ; } else if ( ( val1 + val2 ) < target ) done1 = false ; else if ( ( val1 + val2 ) > target ) done2 = false ; if ( val1 >= val2 ) return false ; } } struct node * NewNode ( int val ) { struct node * tmp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; tmp -> val = val ; tmp -> right = tmp -> left = NULL ; return tmp ; } int main ( ) { struct node * root = NewNode ( 15 ) ; root -> left = NewNode ( 10 ) ; root -> right = NewNode ( 20 ) ; root -> left -> left = NewNode ( 8 ) ; root -> left -> right = NewNode ( 12 ) ; root -> right -> left = NewNode ( 16 ) ; root -> right -> right = NewNode ( 25 ) ; int target = 33 ; if ( isPairPresent ( root , target ) == false ) printf ( \" No such values are found \" getchar ( ) ; return 0 ; }"}
{"text": "Left Leaning Red Black Tree ( Insertion ) | C program to implement insert operation in Red Black Tree . ; red == > true , black == > false ; New Node which is created is always red in color . ; utility function to rotate node anticlockwise . ; utility function to rotate node clockwise . ; utility function to check whether node is red in color or not . ; utility function to swap color of two nodes . ; insertion into Left Leaning Red Black Tree . ; Normal insertion code for any Binary Search tree . ; case 1. when right child is Red but left child is Black or doesn 't exist. ; left rotate the node to make it into valid structure . ; swap the colors as the child node should always be red ; case 2 when left child as well as left grand child in Red ; right rotate the current node to make it into a valid structure . ; case 3 when both left and right child are Red in color . ; invert the color of node as well it 's left and right child. ; change the color to black . ; Inorder traversal ; Driver function ; LLRB tree made after all insertions are made . 1. Nodes which have double INCOMING edge means that they are RED in color . 2. Nodes which have single INCOMING edge means that they are BLACK in color . root | 40 \\ 20 50 / \\ 10 30 25 ; to make sure that root remains black is color ; display the tree through inorder traversal .", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE typedef struct node { struct node * left , * right ; int data ; bool color ; } node ; node * createNode ( int data , bool color ) { node * myNode = ( node * ) malloc ( sizeof ( node ) ) ; myNode -> left = myNode -> right = NULL ; myNode -> data = data ; myNode -> color = true ; return myNode ; } node * rotateLeft ( node * myNode ) { printf ( \" left \u2581 rotation ! ! STRNEWLINE \" ) ; node * child = myNode -> right ; node * childLeft = child -> left ; child -> left = myNode ; myNode -> right = childLeft ; return child ; } node * rotateRight ( node * myNode ) { printf ( \" right \u2581 rotation STRNEWLINE \" ) ; node * child = myNode -> left ; node * childRight = child -> right ; child -> right = myNode ; myNode -> left = childRight ; return child ; } int isRed ( node * myNode ) { if ( myNode == NULL ) return 0 ; return ( myNode -> color == true ) ; } void swapColors ( node * node1 , node * node2 ) { bool temp = node1 -> color ; node1 -> color = node2 -> color ; node2 -> color = temp ; } node * insert ( node * myNode , int data ) { if ( myNode == NULL ) return createNode ( data , false ) ; if ( data < myNode -> data ) myNode -> left = insert ( myNode -> left , data ) ; else if ( data > myNode -> data ) myNode -> right = insert ( myNode -> right , data ) ; else return myNode ; if ( isRed ( myNode -> right ) && ! isRed ( myNode -> left ) ) { myNode = rotateLeft ( myNode ) ; swapColors ( myNode , myNode -> left ) ; } if ( isRed ( myNode -> left ) && isRed ( myNode -> left -> left ) ) { myNode = rotateRight ( myNode ) ; swapColors ( myNode , myNode -> right ) ; } if ( isRed ( myNode -> left ) && isRed ( myNode -> right ) ) { myNode -> color = ! myNode -> color ; myNode -> left -> color = false ; myNode -> right -> color = false ; } return myNode ; } void inorder ( node * node ) { if ( node ) { inorder ( node -> left ) ; printf ( \" % d \u2581 \" , node -> data ) ; inorder ( node -> right ) ; } } int main ( ) { node * root = NULL ; root = insert ( root , 10 ) ; root -> color = false ; root = insert ( root , 20 ) ; root -> color = false ; root = insert ( root , 30 ) ; root -> color = false ; root = insert ( root , 40 ) ; root -> color = false ; root = insert ( root , 50 ) ; root -> color = false ; root = insert ( root , 25 ) ; root -> color = false ; inorder ( root ) ; return 0 ; }"}
{"text": "Threaded Binary Tree | Utility function to find leftmost node in a tree rooted with n ; C code to do inorder traversal in a threaded binary tree ; If this node is a thread node , then go to inorder successor ; Else go to the leftmost child in right ; subtree", "code": "struct Node * leftMost ( struct Node * n ) { if ( n == NULL ) return NULL ; while ( n -> left != NULL ) n = n -> left ; return n ; } void inOrder ( struct Node * root ) { struct Node * cur = leftMost ( root ) ; while ( cur != NULL ) { printf ( \" % d \u2581 \" , cur -> data ) ; if ( cur -> rightThread ) cur = cur -> right ; else cur = leftmost ( cur -> right ) ; } }"}
{"text": "Construct Full Binary Tree from given preorder and postorder traversals | program for construction of full binary tree ; A binary tree node has data , pointer to left child and a pointer to right child ; A utility function to create a node ; A recursive function to construct Full from pre [ ] and post [ ] . preIndex is used to keep track of index in pre [ ] . l is low index and h is high index for the current subarray in post [ ] ; Base case ; The first node in preorder traversal is root . So take the node at preIndex from preorder and make it root , and increment preIndex ; If the current subarry has only one element , no need to recur ; Search the next element of pre [ ] in post [ ] ; Use the index of element found in postorder to divide postorder array in two parts . Left subtree and right subtree ; The main function to construct Full Binary Tree from given preorder and postorder traversals . This function mainly uses constructTreeUtil ( ) ; A utility function to print inorder traversal of a Binary Tree ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } struct node * constructTreeUtil ( int pre [ ] , int post [ ] , int * preIndex , int l , int h , int size ) { if ( * preIndex >= size l > h ) return NULL ; struct node * root = newNode ( pre [ * preIndex ] ) ; ++ * preIndex ; if ( l == h ) return root ; int i ; for ( i = l ; i <= h ; ++ i ) if ( pre [ * preIndex ] == post [ i ] ) break ; if ( i <= h ) { root -> left = constructTreeUtil ( pre , post , preIndex , l , i , size ) ; root -> right = constructTreeUtil ( pre , post , preIndex , i + 1 , h , size ) ; } return root ; } struct node * constructTree ( int pre [ ] , int post [ ] , int size ) { int preIndex = 0 ; return constructTreeUtil ( pre , post , & preIndex , 0 , size - 1 , size ) ; } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d \u2581 \" , node -> data ) ; printInorder ( node -> right ) ; } int main ( ) { int pre [ ] = { 1 , 2 , 4 , 8 , 9 , 5 , 3 , 6 , 7 } ; int post [ ] = { 8 , 9 , 4 , 5 , 2 , 6 , 7 , 3 , 1 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; struct node * root = constructTree ( pre , post , size ) ; printf ( \" Inorder \u2581 traversal \u2581 of \u2581 the \u2581 constructed \u2581 tree : \u2581 STRNEWLINE \" ) ; printInorder ( root ) ; return 0 ; }"}
{"text": "Sorted order printing of a given array that represents a BST | C Code for Sorted order printing of a given array that represents a BST ; print left subtree ; print root ; print right subtree ; driver program to test above function", "code": "#include <stdio.h> NEW_LINE void printSorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; printf ( \" % d \u2581 \" , arr [ start ] ) ; printSorted ( arr , start * 2 + 2 , end ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 } ; int arr_size = sizeof ( arr ) / sizeof ( int ) ; printSorted ( arr , 0 , arr_size - 1 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Floor and Ceil from a BST | Program to find ceil of a given value in BST ; A binary tree node has key , left child and right child ; Helper function that allocates a new node with the given key and NULL left and right pointers . ; Function to find ceil of a given input in BST . If input is more than the max key in BST , return - 1 ; Base case ; We found equal key ; If root 's key is smaller, ceil must be in right subtree ; Else , either left subtree or root has the ceil value ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; struct node * left ; struct node * right ; } ; struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int Ceil ( struct node * root , int input ) { if ( root == NULL ) return -1 ; if ( root -> key == input ) return root -> key ; if ( root -> key < input ) return Ceil ( root -> right , input ) ; int ceil = Ceil ( root -> left , input ) ; return ( ceil >= input ) ? ceil : root -> key ; } int main ( ) { struct node * root = newNode ( 8 ) ; root -> left = newNode ( 4 ) ; root -> right = newNode ( 12 ) ; root -> left -> left = newNode ( 2 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> left = newNode ( 10 ) ; root -> right -> right = newNode ( 14 ) ; for ( int i = 0 ; i < 16 ; i ++ ) printf ( \" % d \u2581 % d STRNEWLINE \" , i , Ceil ( root , i ) ) ; return 0 ; }"}
{"text": "How to handle duplicates in Binary Search Tree ? | C program to implement basic operations ( search , insert and delete ) on a BST that handles duplicates by storing count with every node ; A utility function to create a new BST node ; A utility function to do inorder traversal of BST ; A utility function to insert a new node with given key in BST ; If the tree is empty , return a new node ; If key already exists in BST , icnrement count and return ; Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; Given a non - empty binary search tree , return the node with minimum key value found in that tree . Note that the entire tree does not need to be searched . ; loop down to find the leftmost leaf ; Given a binary search tree and a key , this function deletes a given key and returns root of modified tree ; base case ; If the key to be deleted is smaller than the root 's key, then it lies in left subtree ; If the key to be deleted is greater than the root 's key,  then it lies in right subtree ; if key is same as root 's key ; If key is present more than once , simply decrement count and return ; ElSE , delete the node node with only one child or no child ; node with two children : Get the inorder successor ( smallest in the right subtree ) ; Copy the inorder successor 's content to this node ; Delete the inorder successor ; Driver Program to test above functions ; Let us create following BST 12 ( 3 ) / \\ 10 ( 2 ) 20 ( 1 ) / \\ 9 ( 1 ) 11 ( 1 )", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; int count ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> left = temp -> right = NULL ; temp -> count = 1 ; return temp ; } void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( \" % d ( % d ) \u2581 \" , root -> key , root -> count ) ; inorder ( root -> right ) ; } } struct node * insert ( struct node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key == node -> key ) { ( node -> count ) ++ ; return node ; } if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ; return node ; } struct node * minValueNode ( struct node * node ) { struct node * current = node ; while ( current -> left != NULL ) current = current -> left ; return current ; } struct node * deleteNode ( struct node * root , int key ) { if ( root == NULL ) return root ; if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ; else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ; else { if ( root -> count > 1 ) { ( root -> count ) -- ; return root ; } if ( root -> left == NULL ) { struct node * temp = root -> right ; free ( root ) ; return temp ; } else if ( root -> right == NULL ) { struct node * temp = root -> left ; free ( root ) ; return temp ; } struct node * temp = minValueNode ( root -> right ) ; root -> key = temp -> key ; root -> right = deleteNode ( root -> right , temp -> key ) ; } return root ; } int main ( ) { struct node * root = NULL ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 20 ) ; root = insert ( root , 9 ) ; root = insert ( root , 11 ) ; root = insert ( root , 10 ) ; root = insert ( root , 12 ) ; root = insert ( root , 12 ) ; printf ( \" Inorder \u2581 traversal \u2581 of \u2581 the \u2581 given \u2581 tree \u2581 STRNEWLINE \" ) ; inorder ( root ) ; printf ( \" Delete 20 \" root = deleteNode ( root , 20 ) ; printf ( \" Inorder \u2581 traversal \u2581 of \u2581 the \u2581 modified \u2581 tree \u2581 STRNEWLINE \" ) ; inorder ( root ) ; printf ( \" Delete 12 \" root = deleteNode ( root , 12 ) ; printf ( \" Inorder \u2581 traversal \u2581 of \u2581 the \u2581 modified \u2581 tree \u2581 STRNEWLINE \" ) ; inorder ( root ) ; printf ( \" Delete 9 \" root = deleteNode ( root , 9 ) ; printf ( \" Inorder \u2581 traversal \u2581 of \u2581 the \u2581 modified \u2581 tree \u2581 STRNEWLINE \" ) ; inorder ( root ) ; return 0 ; }"}
{"text": "How to implement decrease key or change key in Binary Search Tree ? | C program to demonstrate decrease key operation on binary search tree ; A utility function to create a new BST node ; A utility function to do inorder traversal of BST ; A utility function to insert a new node with given key in BST ; If the tree is empty , return a new node ; Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; Given a non - empty binary search tree , return the node with minimum key value found in that tree . Note that the entire tree does not need to be searched . ; loop down to find the leftmost leaf ; Given a binary search tree and a key , this function deletes the key and returns the new root ; base case ; If the key to be deleted is smaller than the root 's key,  then it lies in left subtree ; If the key to be deleted is greater than the root 's key,  then it lies in right subtree ; if key is same as root 's key, then This is the node  to be deleted ; node with only one child or no child ; node with two children : Get the inorder successor ( smallest in the right subtree ) ; Copy the inorder successor 's content to this node ; Delete the inorder successor ; Function to decrease a key value in Binary Search Tree ; First delete old key value ; Then insert new key value ; Return new root ; Driver Program to test above functions ; Let us create following BST 50 / \\ 30 70 / \\ / \\ 20 40 60 80 ; BST is modified to 50 / \\ 30 70 / / \\ 20 60 80 / 10", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( \" % d \u2581 \" , root -> key ) ; inorder ( root -> right ) ; } } struct node * insert ( struct node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ; return node ; } struct node * minValueNode ( struct node * node ) { struct node * current = node ; while ( current -> left != NULL ) current = current -> left ; return current ; } struct node * deleteNode ( struct node * root , int key ) { if ( root == NULL ) return root ; if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ; else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ; else { if ( root -> left == NULL ) { struct node * temp = root -> right ; free ( root ) ; return temp ; } else if ( root -> right == NULL ) { struct node * temp = root -> left ; free ( root ) ; return temp ; } struct node * temp = minValueNode ( root -> right ) ; root -> key = temp -> key ; root -> right = deleteNode ( root -> right , temp -> key ) ; } return root ; } struct node * changeKey ( struct node * root , int oldVal , int newVal ) { root = deleteNode ( root , oldVal ) ; root = insert ( root , newVal ) ; return root ; } int main ( ) { struct node * root = NULL ; root = insert ( root , 50 ) ; root = insert ( root , 30 ) ; root = insert ( root , 20 ) ; root = insert ( root , 40 ) ; root = insert ( root , 70 ) ; root = insert ( root , 60 ) ; root = insert ( root , 80 ) ; printf ( \" Inorder \u2581 traversal \u2581 of \u2581 the \u2581 given \u2581 tree \u2581 STRNEWLINE \" ) ; inorder ( root ) ; root = changeKey ( root , 40 , 10 ) ; printf ( \" Inorder traversal of the modified tree \" inorder ( root ) ; return 0 ; }"}
{"text": "Special two digit numbers in a Binary Search Tree | C program to count number of nodes in BST containing two digit special number ; A Tree node ; Function to create a new node ; If the tree is empty , return a new , single node ; Otherwise , recur down the tree ; Function to find if number is special or not ; Check if number is two digit or not ; Function to count number of special two digit number ; Driver program to test ; Function call , to check each node for special two digit number", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { struct Node * left ; int info ; struct Node * right ; } ; void insert ( struct Node * * rt , int key ) { if ( * rt == NULL ) { ( * rt ) = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; ( * rt ) -> left = NULL ; ( * rt ) -> right = NULL ; ( * rt ) -> info = key ; } else if ( key < ( ( * rt ) -> info ) ) insert ( & ( ( * rt ) -> left ) , key ) ; else insert ( & ( * rt ) -> right , key ) ; } int check ( int num ) { int sum = 0 , i = num , sum_of_digits , prod_of_digits ; if ( num < 10 num > 99 ) return 0 ; else { sum_of_digits = ( i % 10 ) + ( i / 10 ) ; prod_of_digits = ( i % 10 ) * ( i / 10 ) ; sum = sum_of_digits + prod_of_digits ; } if ( sum == num ) return 1 ; else return 0 ; } void countSpecialDigit ( struct Node * rt , int * c ) { int x ; if ( rt == NULL ) return ; else { x = check ( rt -> info ) ; if ( x == 1 ) * c = * c + 1 ; countSpecialDigit ( rt -> left , c ) ; countSpecialDigit ( rt -> right , c ) ; } } int main ( ) { struct Node * root = NULL ; int count = 0 ; insert ( & root , 50 ) ; insert ( & root , 29 ) ; insert ( & root , 59 ) ; insert ( & root , 19 ) ; insert ( & root , 53 ) ; insert ( & root , 556 ) ; insert ( & root , 56 ) ; insert ( & root , 94 ) ; insert ( & root , 13 ) ; countSpecialDigit ( root , & count ) ; printf ( \" % d \" , count ) ; return 0 ; }"}
{"text": "Construct Special Binary Tree from given Inorder traversal | program to construct tree from inorder traversal ; A binary tree node has data , pointer to left child and a pointer to right child ; Prototypes of a utility function to get the maximum value in inorder [ start . . end ] ; Recursive function to construct binary of size len from Inorder traversal inorder [ ] . Initial values of start and end should be 0 and len - 1. ; Find index of the maximum element from Binary Tree ; Pick the maximum value and make it root ; If this is the only element in inorder [ start . . end ] , then return it ; Using index in Inorder traversal , construct left and right subtress ; Function to find index of the maximum value in arr [ start ... end ] ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; This funtcion is here just to test buildTree ( ) ; first recur on left child ; then print the data of node ; now recur on right child ; Driver program to test above functions ; Assume that inorder traversal of following tree is given 40 / \\ 10 30 / \\ 5 28 ; Let us test the built tree by printing Insorder traversal", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int max ( int inorder [ ] , int strt , int end ) ; struct node * newNode ( int data ) ; struct node * buildTree ( int inorder [ ] , int start , int end ) { if ( start > end ) return NULL ; int i = max ( inorder , start , end ) ; struct node * root = newNode ( inorder [ i ] ) ; if ( start == end ) return root ; root -> left = buildTree ( inorder , start , i - 1 ) ; root -> right = buildTree ( inorder , i + 1 , end ) ; return root ; } int max ( int arr [ ] , int strt , int end ) { int i , max = arr [ strt ] , maxind = strt ; for ( i = strt + 1 ; i <= end ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; maxind = i ; } } return maxind ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return node ; } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d \u2581 \" , node -> data ) ; printInorder ( node -> right ) ; } int main ( ) { int inorder [ ] = { 5 , 10 , 40 , 30 , 28 } ; int len = sizeof ( inorder ) / sizeof ( inorder [ 0 ] ) ; struct node * root = buildTree ( inorder , 0 , len - 1 ) ; printf ( \" Inorder traversal of the constructed tree is \" printInorder ( root ) ; return 0 ; }"}
{"text": "Program for Identity Matrix | C program to print Identity Matrix ; Checking if row is equal to column ; Driver Code", "code": "#include <stdio.h> NEW_LINE int Identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) printf ( \" % d \u2581 \" , 1 ) ; else printf ( \" % d \u2581 \" , 0 ) ; } printf ( \" STRNEWLINE \" ) ; } return 0 ; } int main ( ) { int size = 5 ; identity ( size ) ; return 0 ; }"}
{"text": "Search in a row wise and column wise sorted matrix | C program to search an element in row - wise and column - wise sorted matrix ; Searches the element x in mat [ ] [ ] . If the element is found , then prints its position and returns true , otherwise prints \" not \u2581 found \" and returns false ; set indexes for top right element ; if mat [ i ] [ j ] < x ; if ( i == n j == - 1 ) ; driver program to test above function", "code": "#include <stdio.h> NEW_LINE int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return -1 ; int smallest = mat [ 0 ] [ 0 ] , largest = mat [ n - 1 ] [ n - 1 ] ; if ( x < smallest x > largest ) return -1 ; int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { printf ( \" Found at % d , % d \" , i , j ) ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } printf ( \" n \u2581 Element \u2581 not \u2581 found \" ) ; return 0 ; } int main ( ) { int mat [ 4 ] [ 4 ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } , } ; search ( mat , 4 , 29 ) ; return 0 ; }"}
{"text": "Create a matrix with alternating rectangles of O and X |  ; Function to print alternating rectangles of 0 and X ; k - starting row index m - ending row index l - starting column index n - ending column index i - iterator ; Store given number of rows and columns for later use ; A 2D array to store the output to be printed ; Iniitialize the character to be stoed in a [ ] [ ] ; Fill characters in a [ ] [ ] in spiral form . Every iteration fills one rectangle of either Xs or Os ; Fill the first row from the remaining rows ; Fill the last column from the remaining columns ; Fill the last row from the remaining rows ; Print the first column from the remaining columns ; Flip character for next iteration ; Print the filled matrix ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE void fill0X ( int m , int n ) { int i , k = 0 , l = 0 ; int r = m , c = n ; char a [ m ] [ n ] ; char x = ' X ' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) a [ k ] [ i ] = x ; k ++ ; for ( i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = x ; n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = x ; l ++ ; } x = ( x == '0' ) ? ' X ' : '0' ; } for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) printf ( \" % c \u2581 \" , a [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } } int main ( ) { puts ( \" Output \u2581 for \u2581 m \u2581 = \u2581 5 , \u2581 n \u2581 = \u2581 6\" ) ; fill0X ( 5 , 6 ) ; puts ( \" Output for m = 4 , n = 4 \" ) ; fill0X ( 4 , 4 ) ; puts ( \" Output for m = 3 , n = 4 \" ) ; fill0X ( 3 , 4 ) ; return 0 ; }"}
{"text": "Program to Interchange Diagonals of Matrix | C program to interchange the diagonals of matrix ; Function to interchange diagonals ; swap elements of diagonal ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE void interchangeDiagonals ( int array [ ] [ N ] ) { for ( int i = 0 ; i < N ; ++ i ) if ( i != N / 2 ) swap ( array [ i ] [ i ] , array [ i ] [ N - i - 1 ] ) ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) printf ( \" \u2581 % d \" , array [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } } int main ( ) { int array [ N ] [ N ] = { 4 , 5 , 6 , 1 , 2 , 3 , 7 , 8 , 9 } ; interchangeDiagonals ( array ) ; return 0 ; }"}
{"text": "Linked complete binary tree & its creation | Program for linked implementation of complete binary tree ; For Queue Size ; A tree node ; A queue node ; A utility function to create a new tree node ; A utility function to create a new Queue ; Standard Queue Functions ; A utility function to check if a tree node has both left and right children ; Function to insert a new node in complete binary tree ; Create a new node for given data ; If the tree is empty , initialize the root with new node . ; get the front node of the queue . ; If the left child of this front node doesn t exist , set the left child as the new node ; If the right child of this front node doesn t exist , set the right child as the new node ; If the front node has both the left child and right child , Dequeue ( ) it . ; Enqueue ( ) the new node for later insertions ; Standard level order traversal to test above function ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define SIZE  50 NEW_LINE struct node { int data ; struct node * right , * left ; } ; struct Queue { int front , rear ; int size ; struct node * * array ; } ; struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } struct Queue * createQueue ( int size ) { struct Queue * queue = ( struct Queue * ) malloc ( sizeof ( struct Queue ) ) ; queue -> front = queue -> rear = -1 ; queue -> size = size ; queue -> array = ( struct node * * ) malloc ( queue -> size * sizeof ( struct node * ) ) ; int i ; for ( i = 0 ; i < size ; ++ i ) queue -> array [ i ] = NULL ; return queue ; } int isEmpty ( struct Queue * queue ) { return queue -> front == -1 ; } int isFull ( struct Queue * queue ) { return queue -> rear == queue -> size - 1 ; } int hasOnlyOneItem ( struct Queue * queue ) { return queue -> front == queue -> rear ; } void Enqueue ( struct node * root , struct Queue * queue ) { if ( isFull ( queue ) ) return ; queue -> array [ ++ queue -> rear ] = root ; if ( isEmpty ( queue ) ) ++ queue -> front ; } struct node * Dequeue ( struct Queue * queue ) { if ( isEmpty ( queue ) ) return NULL ; struct node * temp = queue -> array [ queue -> front ] ; if ( hasOnlyOneItem ( queue ) ) queue -> front = queue -> rear = -1 ; else ++ queue -> front ; return temp ; } struct node * getFront ( struct Queue * queue ) { return queue -> array [ queue -> front ] ; } int hasBothChild ( struct node * temp ) { return temp && temp -> left && temp -> right ; } void insert ( struct node * * root , int data , struct Queue * queue ) { struct node * temp = newNode ( data ) ; if ( ! * root ) * root = temp ; else { struct node * front = getFront ( queue ) ; if ( ! front -> left ) front -> left = temp ; else if ( ! front -> right ) front -> right = temp ; if ( hasBothChild ( front ) ) Dequeue ( queue ) ; } Enqueue ( temp , queue ) ; } void levelOrder ( struct node * root ) { struct Queue * queue = createQueue ( SIZE ) ; Enqueue ( root , queue ) ; while ( ! isEmpty ( queue ) ) { struct node * temp = Dequeue ( queue ) ; printf ( \" % d \u2581 \" , temp -> data ) ; if ( temp -> left ) Enqueue ( temp -> left , queue ) ; if ( temp -> right ) Enqueue ( temp -> right , queue ) ; } } int main ( ) { struct node * root = NULL ; struct Queue * queue = createQueue ( SIZE ) ; int i ; for ( i = 1 ; i <= 12 ; ++ i ) insert ( & root , i , queue ) ; levelOrder ( root ) ; return 0 ; }"}
{"text": "Convert a given Binary Tree to Doubly Linked List | Set 1 | A C program for in - place conversion of Binary Tree to DLL ; A binary tree node has data , and left and right pointers ; This is the core function to convert Tree to list . This function follows steps 1 and 2 of the above algorithm ; Base case ; Convert the left subtree and link to root ; Convert the left subtree ; Find inorder predecessor . After this loop , left will point to the inorder predecessor ; Make root as next of the predecessor ; Make predecssor as previous of root ; Convert the right subtree and link to root ; Convert the right subtree ; Find inorder successor . After this loop , right will point to the inorder successor ; Make root as previous of successor ; Make successor as next of root ; The main function that first calls bintree2listUtil ( ) , then follows step 3 of the above algorithm ; Base case ; Convert to DLL using bintree2listUtil ( ) ; bintree2listUtil ( ) returns root node of the converted DLL . We need pointer to the leftmost node which is head of the constructed DLL , so move to the leftmost node ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Function to print nodes in a given doubly linked list ; Driver program to test above functions ; Let us create the tree shown in above diagram ; Convert to DLL ; Print the converted list", "code": "#include <stdio.h> NEW_LINE struct node { int data ; node * left ; node * right ; } ; node * bintree2listUtil ( node * root ) { if ( root == NULL ) return root ; if ( root -> left != NULL ) { node * left = bintree2listUtil ( root -> left ) ; for ( ; left -> right != NULL ; left = left -> right ) ; left -> right = root ; root -> left = left ; } if ( root -> right != NULL ) { node * right = bintree2listUtil ( root -> right ) ; for ( ; right -> left != NULL ; right = right -> left ) ; right -> left = root ; root -> right = right ; } return root ; } node * bintree2list ( node * root ) { if ( root == NULL ) return root ; root = bintree2listUtil ( root ) ; while ( root -> left != NULL ) root = root -> left ; return ( root ) ; } node * newNode ( int data ) { node * new_node = new node ; new_node -> data = data ; new_node -> left = new_node -> right = NULL ; return ( new_node ) ; } void printList ( node * node ) { while ( node != NULL ) { printf ( \" % d \u2581 \" , node -> data ) ; node = node -> right ; } } int main ( ) { node * root = newNode ( 10 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 15 ) ; root -> left -> left = newNode ( 25 ) ; root -> left -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 36 ) ; node * head = bintree2list ( root ) ; printList ( head ) ; return 0 ; }"}
{"text": "Print unique rows in a given boolean matrix | Given a binary matrix of M X N of integers , you need to return only unique rows of binary array ; A Trie node ; Only two children needed for 0 and 1 ; A utility function to allocate memory for a new Trie node ; Inserts a new matrix row to Trie . If row is already present , then returns 0 , otherwise insets the row and return 1 ; base case ; Recur if there are more entries in this row ; If all entries of this row are processed ; unique row found , return 1 ; duplicate row found , return 0 ; A utility function to print a row ; The main function that prints all unique rows in a given matrix . ; create an empty Trie ; Iterate through all rows ; insert row to TRIE ; unique row found , print it ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE #define ROW  4 NEW_LINE #define COL  5 NEW_LINE typedef struct Node { bool isEndOfCol ; struct Node * child [ 2 ] ; } Node ; Node * newNode ( ) { Node * temp = ( Node * ) malloc ( sizeof ( Node ) ) ; temp -> isEndOfCol = 0 ; temp -> child [ 0 ] = temp -> child [ 1 ] = NULL ; return temp ; } bool insert ( Node * * root , int ( * M ) [ COL ] , int row , int col ) { if ( * root == NULL ) * root = newNode ( ) ; if ( col < COL ) return insert ( & ( ( * root ) -> child [ M [ row ] [ col ] ] ) , M , row , col + 1 ) ; else { if ( ! ( ( * root ) -> isEndOfCol ) ) return ( * root ) -> isEndOfCol = 1 ; return 0 ; } } void printRow ( int ( * M ) [ COL ] , int row ) { int i ; for ( i = 0 ; i < COL ; ++ i ) printf ( \" % d \u2581 \" , M [ row ] [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } void findUniqueRows ( int ( * M ) [ COL ] ) { Node * root = NULL ; int i ; for ( i = 0 ; i < ROW ; ++ i ) if ( insert ( & root , M , i , 0 ) ) printRow ( M , i ) ; } int main ( ) { int M [ ROW ] [ COL ] = { { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 0 , 0 } } ; findUniqueRows ( M ) ; return 0 ; }"}
{"text": "Find a common element in all rows of a given row | A C program to find a common element in all rows of a row wise sorted array ; Specify number of rows and columns ; Returns common element in all rows of mat [ M ] [ N ] . If there is no common element , then - 1 is returned ; An array to store indexes of current last column ; To store index of row whose current last element is minimum ; Initialize current last element of all rows ; Initialize min_row as first row ; Keep finding min_row in current last column , till either all elements of last column become same or we hit first column . ; Find minimum in current last column ; eq_count is count of elements equal to minimum in current last column . ; Traverse current last column elements again to update it ; Decrease last column index of a row whose value is more than minimum . ; Reduce last column index by 1 ; If equal count becomes M , return the value ; driver program to test above function", "code": "#include <stdio.h> NEW_LINE #define M  4 NEW_LINE #define N  5 NEW_LINE int findCommon ( int mat [ M ] [ N ] ) { int column [ M ] ; int min_row ; int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ; min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ; } int eq_count = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return -1 ; column [ i ] -= 1 ; } else eq_count ++ ; } if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } return -1 ; } int main ( ) { int mat [ M ] [ N ] = { { 1 , 2 , 3 , 4 , 5 } , { 2 , 4 , 5 , 8 , 10 } , { 3 , 5 , 7 , 9 , 11 } , { 1 , 3 , 5 , 7 , 9 } , } ; int result = findCommon ( mat ) ; if ( result == -1 ) printf ( \" No \u2581 common \u2581 element \" ) ; else printf ( \" Common \u2581 element \u2581 is \u2581 % d \" , result ) ; return 0 ; }"}
{"text": "Convert a given Binary Tree to Doubly Linked List | Set 2 | A simple inorder traversal based program to convert a Binary Tree to DLL ; A tree node ; A utility function to create a new tree node ; Standard Inorder traversal of tree ; Changes left pointers to work as previous pointers in converted DLL The function simply does inorder traversal of Binary Tree and updates left pointer using previously visited node ; Changes right pointers to work as next pointers in converted DLL ; Find the right most node in BT or last node in DLL ; Start from the rightmost node , traverse back using left pointers . While traversing , change right pointer of nodes . ; The leftmost node is head of linked list , return it ; The main function that converts BST to DLL and returns head of DLL ; Set the previous pointer ; Set the next pointer and return head of DLL ; Traverses the DLL from left tor right ; Driver program to test above functions ; Let us create the tree shown in above diagram", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( \" TABSYMBOL % d \" , root -> data ) ; inorder ( root -> right ) ; } } void fixPrevPtr ( struct node * root ) { static struct node * pre = NULL ; if ( root != NULL ) { fixPrevPtr ( root -> left ) ; root -> left = pre ; pre = root ; fixPrevPtr ( root -> right ) ; } } struct node * fixNextPtr ( struct node * root ) { struct node * prev = NULL ; while ( root && root -> right != NULL ) root = root -> right ; while ( root && root -> left != NULL ) { prev = root ; root = root -> left ; root -> right = prev ; } return ( root ) ; } struct node * BTToDLL ( struct node * root ) { fixPrevPtr ( root ) ; return fixNextPtr ( root ) ; } void printList ( struct node * root ) { while ( root != NULL ) { printf ( \" TABSYMBOL % d \" , root -> data ) ; root = root -> right ; } } int main ( void ) { struct node * root = newNode ( 10 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 15 ) ; root -> left -> left = newNode ( 25 ) ; root -> left -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 36 ) ; printf ( \" Inorder Tree Traversal \" inorder ( root ) ; struct node * head = BTToDLL ( root ) ; printf ( \" DLL Traversal \" printList ( head ) ; return 0 ; }"}
{"text": "Convert an arbitrary Binary Tree to a tree that holds Children Sum Property | Program to convert an aribitary binary tree to a tree that holds children sum property ; A binary tree node ; This function is used to increment left subtree ; This function changes a tree to hold children sum property ; If tree is empty or it 's a leaf node then  return true  ; convert left and right subtrees ; If left child is not present then 0 is used as data of left child ; If right child is not present then 0 is used as data of right child ; get the diff of node 's data and children sum  ; If node ' s \u2581 children \u2581 sum \u2581 is \u2581 greater \u2581 than \u2581 the \u2581 node ' s data ; THIS IS TRICKY -- > If node 's data is greater than children sum,  then increment subtree by diff  ; - diff is used to make diff positive ; This function is used to increment subtree by diff ; IF left child is not NULL then increment it ; Recursively call to fix the descendants of node -> left ; Else increment right child ; Recursively call to fix the descendants of node -> right ; Given a binary tree , printInorder ( ) prints out its inorder traversal ; first recur on left child ; then print the data of node ; now recur on right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; void increment ( struct node * node , int diff ) ; void convertTree ( struct node * node ) { int left_data = 0 , right_data = 0 , diff ; if ( node == NULL || ( node -> left == NULL && node -> right == NULL ) ) return ; else { convertTree ( node -> left ) ; convertTree ( node -> right ) ; if ( node -> left != NULL ) left_data = node -> left -> data ; if ( node -> right != NULL ) right_data = node -> right -> data ; diff = left_data + right_data - node -> data ; if ( diff > 0 ) node -> data = node -> data + diff ; if ( diff < 0 ) increment ( node , - diff ) ; } } void increment ( struct node * node , int diff ) { if ( node -> left != NULL ) { node -> left -> data = node -> left -> data + diff ; increment ( node -> left , diff ) ; } else if ( node -> right != NULL ) { node -> right -> data = node -> right -> data + diff ; increment ( node -> right , diff ) ; } } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d \u2581 \" , node -> data ) ; printInorder ( node -> right ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 50 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 1 ) ; root -> right -> right = newNode ( 30 ) ; printf ( \" Inorder traversal before conversion \" printInorder ( root ) ; convertTree ( root ) ; printf ( \" Inorder traversal after conversion \" printInorder ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Convert a given tree to its Sum Tree |  ; A tree node structure ; Convert a given tree to a tree where every node contains sum of values of nodes in left and right subtrees in the original tree ; Base case ; Store the old value ; Recursively call for left and right subtrees and store the sum as new value of this node ; Return the sum of values of nodes in left and right subtrees and old_value of this node ; A utility function to print inorder traversal of a Binary Tree ; Utility function to create a new Binary Tree node ; Driver function to test above functions ; Constructing tree given in the above figure ; Print inorder traversal of the converted tree to test result of toSumTree ( )", "code": "#include <stdio.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; int toSumTree ( struct node * node ) { if ( node == NULL ) return 0 ; int old_val = node -> data ; node -> data = toSumTree ( node -> left ) + toSumTree ( node -> right ) ; return node -> data + old_val ; } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( \" % d \u2581 \" , node -> data ) ; printInorder ( node -> right ) ; } struct node * newNode ( int data ) { struct node * temp = new struct node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int main ( ) { struct node * root = NULL ; int x ; root = newNode ( 10 ) ; root -> left = newNode ( -2 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( -4 ) ; root -> right -> left = newNode ( 7 ) ; root -> right -> right = newNode ( 5 ) ; toSumTree ( root ) ; printf ( \" Inorder \u2581 Traversal \u2581 of \u2581 the \u2581 resultant \u2581 tree \u2581 is : \u2581 STRNEWLINE \" ) ; printInorder ( root ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find a peak element | C program to find a peak element using divide and conquer ; A binary search based function that returns index of a peak element ; Find index of middle element ( low + high ) / 2 ; Compare middle element with its neighbours ( if neighbours exist ) ; If middle element is not peak and its left neighbour is greater than it , then left half must have a peak element ; If middle element is not peak and its right neighbour is greater than it , then right half must have a peak element ; A wrapper over recursive function findPeakUtil ( ) ; Driver program to check above functions", "code": "#include <stdio.h> NEW_LINE int findPeakUtil ( int arr [ ] , int low , int high , int n ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ; else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; } int findPeak ( int arr [ ] , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Index \u2581 of \u2581 a \u2581 peak \u2581 point \u2581 is \u2581 % d \" , findPeak ( arr , n ) ) ; return 0 ; }"}
{"text": "Find the two repeating elements in a given array |  ; Print Repeating function ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void printRepeating ( int arr [ ] , int size ) { int i , j ; printf ( \" \u2581 Repeating \u2581 elements \u2581 are \u2581 \" ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) printf ( \" \u2581 % d \u2581 \" , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find the two repeating elements in a given array |  ; Function ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void printRepeating ( int arr [ ] , int size ) { int * count = ( int * ) calloc ( sizeof ( int ) , ( size - 2 ) ) ; int i ; printf ( \" \u2581 Repeating \u2581 elements \u2581 are \u2581 \" ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) printf ( \" \u2581 % d \u2581 \" , arr [ i ] ) ; else count [ arr [ i ] ] ++ ; } } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find the two repeating elements in a given array |  ; printRepeating function ; S is for sum of elements in arr [ ] ; P is for product of elements in arr [ ] ; x and y are two repeating elements ; D is for difference of x and y , i . e . , x - y ; Calculate Sum and Product of all elements in arr [ ] ; S is x + y now ; P is x * y now ; D is x - y now ; factorial of n ; driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <math.h> NEW_LINE int fact ( int n ) ; void printRepeating ( int arr [ ] , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; printf ( \" The \u2581 two \u2581 Repeating \u2581 elements \u2581 are \u2581 % d \u2581 & \u2581 % d \" , x , y ) ; } int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find the two repeating elements in a given array | C code to Find the two repeating elements in a given array ; Will hold xor of all elements ; Will have only single set bit of xor ; Get the xor of all elements in arr [ ] and { 1 , 2 . . n } ; Get the rightmost set bit in set_bit_no ; Now divide elements in two sets by comparing rightmost set bit of xor with bit at same position in each element . ; XOR of first set in arr [ ] ; XOR of second set in arr [ ] ; XOR of first set in arr [ ] and { 1 , 2 , ... n } ; XOR of second set in arr [ ] and { 1 , 2 , ... n } ; driver code", "code": "void printRepeating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_bit_no = xor & ~ ( xor - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ; else y = y ^ i ; } printf ( \" n \u2581 The \u2581 two \u2581 repeating \u2581 elements \u2581 are \u2581 % d \u2581 & \u2581 % d \u2581 \" , x , y ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find the two repeating elements in a given array |  ; Function to print repeating ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void printRepeating ( int arr [ ] , int size ) { int i ; printf ( \" The repeating elements are \" for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; else printf ( \" \u2581 % d \u2581 \" , abs ( arr [ i ] ) ) ; } } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find subarray with given sum | Set 1 ( Nonnegative Numbers ) | A simple program to print subarray with sum as given sum ; Returns true if the there is a subarray of arr [ ] with a sum equal to ' sum ' otherwise returns false . Also , prints the result ; Pick a starting point ; try all subarrays starting with ' i ' ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { printf ( \" Sum \u2581 found \u2581 between \u2581 indexes \u2581 % d \u2581 and \u2581 % d \" , i , j - 1 ) ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } printf ( \" No \u2581 subarray \u2581 found \" ) ; return 0 ; } int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; subArraySum ( arr , n , sum ) ; return 0 ; }"}
{"text": "Find subarray with given sum | Set 1 ( Nonnegative Numbers ) | An efficient program to print subarray with sum as given sum ; Returns true if the there is a subarray of arr [ ] with a sum equal to ' sum ' otherwise returns false . Also , prints the result ; Initialize curr_sum as value of first element and starting point as 0 ; Add elements one by one to curr_sum and if the curr_sum exceeds the sum , then remove starting element ; If curr_sum exceeds the sum , then remove the starting elements ; If curr_sum becomes equal to sum , then return true ; Add this element to curr_sum ; If we reach here , then no subarray ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { printf ( \" Sum \u2581 found \u2581 between \u2581 indexes \u2581 % d \u2581 and \u2581 % d \" , start , i - 1 ) ; return 1 ; } if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } printf ( \" No \u2581 subarray \u2581 found \" ) ; return 0 ; } int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; subArraySum ( arr , n , sum ) ; return 0 ; }"}
{"text": "Find a triplet that sum to a given value |  ; returns true if there is triplet with sum equal to ' sum ' present in A [ ] . Also , prints the triplet ; Fix the first element as A [ i ] ; Fix the second element as A [ j ] ; Now look for the third number ; If we reach here , then no triplet was found ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { printf ( \" Triplet \u2581 is \u2581 % d , \u2581 % d , \u2581 % d \" , A [ i ] , A [ j ] , A [ k ] ) ; return true ; } } } } return false ; } int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; find3Numbers ( A , arr_size , sum ) ; return 0 ; }"}
{"text": "Analysis of Algorithms | Set 2 ( Worst , Average and Best Cases ) | C implementation of the approach ; Linearly search x in arr [ ] . If x is present then return the index , otherwise return - 1 ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { 1 , 10 , 30 , 15 } ; int x = 30 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d \u2581 is \u2581 present \u2581 at \u2581 index \u2581 % d \" , x , search ( arr , n , x ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Binary Search | C program to implement recursive Binary Search ; A recursive binary search function . It returns location of x in given array arr [ l . . r ] is present , otherwise - 1 ; If the element is present at the middle itself ; If element is smaller than mid , then it can only be present in left subarray ; Else the element can only be present in right subarray ; We reach here when element is not present in array ; Driver method to test above", "code": "#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( \" Element \u2581 is \u2581 not \u2581 present \u2581 in \u2581 array \" ) : printf ( \" Element \u2581 is \u2581 present \u2581 at \u2581 index \u2581 % d \" , result ) ; return 0 ; }"}
{"text": "Binary Search | C program to implement iterative Binary Search ; A iterative binary search function . It returns location of x in given array arr [ l . . r ] if present , otherwise - 1 ; Check if x is present at mid ; If x greater , ignore left half ; If x is smaller , ignore right half ; if we reach here , then element was not present ; Driver method to test above", "code": "#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( \" Element \u2581 is \u2581 not \u2581 present \" \" \u2581 in \u2581 array \" ) : printf ( \" Element \u2581 is \u2581 present \u2581 at \u2581 \" \" index \u2581 % d \" , result ) ; return 0 ; }"}
{"text": "Interpolation Search | C program to implement interpolation search with recursion ; If x is present in arr [ 0. . n - 1 ] , then returns index of it , else returns - 1. ; Since array is sorted , an element present in array must be in range defined by corner ; Probing the position with keeping uniform distribution in mind . ; Condition of target found ; If x is larger , x is in right sub array ; If x is smaller , x is in left sub array ; Driver Code ; Array of items on which search will be conducted . ; Element to be searched ; If element was found", "code": "#include <stdio.h> NEW_LINE int interpolationSearch ( int arr [ ] , int lo , int hi , int x ) { int pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) return interpolationSearch ( arr , pos + 1 , hi , x ) ; if ( arr [ pos ] > x ) return interpolationSearch ( arr , lo , pos - 1 , x ) ; } return -1 ; } int main ( ) { int arr [ ] = { 10 , 12 , 13 , 16 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 33 , 35 , 42 , 47 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 18 ; int index = interpolationSearch ( arr , 0 , n - 1 , x ) ; if ( index != -1 ) printf ( \" Element \u2581 found \u2581 at \u2581 index \u2581 % d \" , index ) ; else printf ( \" Element \u2581 not \u2581 found . \" ) ; return 0 ; }"}
{"text": "Merge Sort | C program for Merge Sort ; Merges two subarrays of arr [ ] . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ] ; Find sizes of two subarrays to be merged ; create temp arrays ; Copy data to temp arrays L [ ] and R [ ] ; Merge the temp arrays Initial indexes of first and second subarrays ; Initial index of merged subarray ; Copy the remaining elements of L [ ] , if there are any ; Copy the remaining elements of R [ ] , if there are any ; l is for left index and r is right index of the sub - array of arr to be sorted ; Same as ( l + r ) / 2 , but avoids overflow for large l and h ; Sort first and second halves ; Merge the sorted halves ; Function to print an array ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void merge ( int arr [ ] , int l , int m , int r ) { int i , j , k ; int n1 = m - l + 1 ; int n2 = r - m ; int L [ n1 ] , R [ n2 ] ; for ( i = 0 ; i < n1 ; i ++ ) L [ i ] = arr [ l + i ] ; for ( j = 0 ; j < n2 ; j ++ ) R [ j ] = arr [ m + 1 + j ] ; i = 0 ; j = 0 ; k = l ; while ( i < n1 && j < n2 ) { if ( L [ i ] <= R [ j ] ) { arr [ k ] = L [ i ] ; i ++ ; } else { arr [ k ] = R [ j ] ; j ++ ; } k ++ ; } while ( i < n1 ) { arr [ k ] = L [ i ] ; i ++ ; k ++ ; } while ( j < n2 ) { arr [ k ] = R [ j ] ; j ++ ; k ++ ; } } void mergeSort ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } void printArray ( int A [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d \u2581 \" , A [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given \u2581 array \u2581 is \u2581 STRNEWLINE \" ) ; printArray ( arr , arr_size ) ; mergeSort ( arr , 0 , arr_size - 1 ) ; printf ( \" Sorted array is \" printArray ( arr , arr_size ) ; return 0 ; }"}
{"text": "Iterative Quick Sort | An iterative implementation of quick sort ; A utility function to swap two elements ; This function is same in both iterative and recursive ; A [ ] -- > Array to be sorted , l -- > Starting index , h -- > Ending index ; Create an auxiliary stack ; initialize top of stack ; push initial values of l and h to stack ; Keep popping from stack while is not empty ; Pop h and l ; Set pivot element at its correct position in sorted array ; If there are elements on left side of pivot , then push left side to stack ; If there are elements on right side of pivot , then push right side to stack ; A utility function to print contents of arr ; Driver program to test above functions ; Function calling", "code": "#include <stdio.h> NEW_LINE void swap ( int * a , int * b ) { int t = * a ; * a = * b ; * b = t ; } int partition ( int arr [ ] , int l , int h ) { int x = arr [ h ] ; int i = ( l - 1 ) ; for ( int j = l ; j <= h - 1 ; j ++ ) { if ( arr [ j ] <= x ) { i ++ ; swap ( & arr [ i ] , & arr [ j ] ) ; } } swap ( & arr [ i + 1 ] , & arr [ h ] ) ; return ( i + 1 ) ; } void quickSortIterative ( int arr [ ] , int l , int h ) { int stack [ h - l + 1 ] ; int top = -1 ; stack [ ++ top ] = l ; stack [ ++ top ] = h ; while ( top >= 0 ) { h = stack [ top -- ] ; l = stack [ top -- ] ; int p = partition ( arr , l , h ) ; if ( p - 1 > l ) { stack [ ++ top ] = l ; stack [ ++ top ] = p - 1 ; } if ( p + 1 < h ) { stack [ ++ top ] = p + 1 ; stack [ ++ top ] = h ; } } } void printArr ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) printf ( \" % d \u2581 \" , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 4 , 3 , 5 , 2 , 1 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( * arr ) ; quickSortIterative ( arr , 0 , n - 1 ) ; printArr ( arr , n ) ; return 0 ; }"}
{"text": "Activity Selection Problem | Greedy Algo | C program for activity selection problem . The following implementation assumes that the activities are already sorted according to their finish time ; Prints a maximum set of activities that can be done by a single person , one at a time . n -- > Total number of activities s [ ] -- > An array that contains start time of all activities f [ ] -- > An array that contains finish time of all activities ; The first activity always gets selected ; Consider rest of the activities ; If this activity has start time greater than or equal to the finish time of previously selected activity , then select it ; driver program to test above function", "code": "#include <stdio.h> NEW_LINE void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; printf ( \" Following \u2581 activities \u2581 are \u2581 selected \u2581 n \" ) ; i = 0 ; printf ( \" % d \u2581 \" , i ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { printf ( \" % d \u2581 \" , j ) ; i = j ; } } } int main ( ) { int s [ ] = { 1 , 3 , 0 , 5 , 8 , 5 } ; int f [ ] = { 2 , 4 , 6 , 7 , 9 , 9 } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; printMaxActivities ( s , f , n ) ; return 0 ; }"}
{"text": "Efficient Huffman Coding for Sorted Input | Greedy Algo | C Program for Efficient Huffman Coding for Sorted input ; This constant can be avoided by explicitly calculating height of Huffman Tree ; A node of huffman tree ; Structure for Queue : collection of Huffman Tree nodes ( orQueueNodes ) ; A utility function to create a new Queuenode ; A utility function to create a Queue of given capacity ; A utility function to check if size of given queue is 1 ; A utility function to check if given queue is empty ; A utility function to check if given queue is full ; A utility function to add an item to queue ; A utility function to remove an item from queue ; If there is only one item in queue ; A utility function to get from of queue ; A function to get minimum item from two queues ; Step 3. a : If first queue is empty , dequeue from second queue ; Step 3. b : If second queue is empty , dequeue from first queue ; Step 3. c : Else , compare the front of two queues and dequeue minimum ; Utility function to check if this node is leaf ; A utility function to print an array of size n ; The main function that builds Huffman tree ; Step 1 : Create two empty queues ; Step 2 : Create a leaf node for each unique character and Enqueue it to the first queue in non - decreasing order of frequency . Initially second queue is empty ; Run while Queues contain more than one node . Finally , first queue will be empty and second queue will contain only one node ; Step 3 : Dequeue two nodes with the minimum frequency by examining the front of both queues ; Step 4 : Create a new internal node with frequency equal to the sum of the two nodes frequencies . Enqueue this node to second queue . ; Prints huffman codes from the root of Huffman Tree . It uses arr [ ] to store codes ; Assign 0 to left edge and recur ; Assign 1 to right edge and recur ; If this is a leaf node , then it contains one of the input characters , print the character and its code from arr [ ] ; The main function that builds a Huffman Tree and print codes by traversing the built Huffman Tree ; Construct Huffman Tree ; Print Huffman codes using the Huffman tree built above ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define MAX_TREE_HT  100 NEW_LINE struct QueueNode { char data ; unsigned freq ; struct QueueNode * left , * right ; } ; struct Queue { int front , rear ; int capacity ; struct QueueNode * * array ; } ; struct QueueNode * newNode ( char data , unsigned freq ) { struct QueueNode * temp = ( struct QueueNode * ) malloc ( sizeof ( struct QueueNode ) ) ; temp -> left = temp -> right = NULL ; temp -> data = data ; temp -> freq = freq ; return temp ; } struct Queue * createQueue ( int capacity ) { struct Queue * queue = ( struct Queue * ) malloc ( sizeof ( struct Queue ) ) ; queue -> front = queue -> rear = -1 ; queue -> capacity = capacity ; queue -> array = ( struct QueueNode * * ) malloc ( queue -> capacity * sizeof ( struct QueueNode * ) ) ; return queue ; } int isSizeOne ( struct Queue * queue ) { return queue -> front == queue -> rear && queue -> front != -1 ; } int isEmpty ( struct Queue * queue ) { return queue -> front == -1 ; } int isFull ( struct Queue * queue ) { return queue -> rear == queue -> capacity - 1 ; } void enQueue ( struct Queue * queue , struct QueueNode * item ) { if ( isFull ( queue ) ) return ; queue -> array [ ++ queue -> rear ] = item ; if ( queue -> front == -1 ) ++ queue -> front ; } struct QueueNode * deQueue ( struct Queue * queue ) { if ( isEmpty ( queue ) ) return NULL ; struct QueueNode * temp = queue -> array [ queue -> front ] ; if ( queue -> front == queue -> rear ) queue -> front = queue -> rear = -1 ; else ++ queue -> front ; return temp ; } struct QueueNode * getFront ( struct Queue * queue ) { if ( isEmpty ( queue ) ) return NULL ; return queue -> array [ queue -> front ] ; } struct QueueNode * findMin ( struct Queue * firstQueue , struct Queue * secondQueue ) { if ( isEmpty ( firstQueue ) ) return deQueue ( secondQueue ) ; if ( isEmpty ( secondQueue ) ) return deQueue ( firstQueue ) ; if ( getFront ( firstQueue ) -> freq < getFront ( secondQueue ) -> freq ) return deQueue ( firstQueue ) ; return deQueue ( secondQueue ) ; } int isLeaf ( struct QueueNode * root ) { return ! ( root -> left ) && ! ( root -> right ) ; } void printArr ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) printf ( \" % d \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } struct QueueNode * buildHuffmanTree ( char data [ ] , int freq [ ] , int size ) { struct QueueNode * left , * right , * top ; struct Queue * firstQueue = createQueue ( size ) ; struct Queue * secondQueue = createQueue ( size ) ; for ( int i = 0 ; i < size ; ++ i ) enQueue ( firstQueue , newNode ( data [ i ] , freq [ i ] ) ) ; while ( ! ( isEmpty ( firstQueue ) && isSizeOne ( secondQueue ) ) ) { left = findMin ( firstQueue , secondQueue ) ; right = findMin ( firstQueue , secondQueue ) ; top = newNode ( ' $ ' , left -> freq + right -> freq ) ; top -> left = left ; top -> right = right ; enQueue ( secondQueue , top ) ; } return deQueue ( secondQueue ) ; } void printCodes ( struct QueueNode * root , int arr [ ] , int top ) { if ( root -> left ) { arr [ top ] = 0 ; printCodes ( root -> left , arr , top + 1 ) ; } if ( root -> right ) { arr [ top ] = 1 ; printCodes ( root -> right , arr , top + 1 ) ; } if ( isLeaf ( root ) ) { printf ( \" % c : \u2581 \" , root -> data ) ; printArr ( arr , top ) ; } } void HuffmanCodes ( char data [ ] , int freq [ ] , int size ) { struct QueueNode * root = buildHuffmanTree ( data , freq , size ) ; int arr [ MAX_TREE_HT ] , top = 0 ; printCodes ( root , arr , top ) ; } int main ( ) { char arr [ ] = { ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' } ; int freq [ ] = { 5 , 9 , 12 , 13 , 16 , 45 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; HuffmanCodes ( arr , freq , size ) ; return 0 ; }"}
{"text": "Longest Common Subsequence | DP | A Naive recursive implementation of LCS problem ; Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Utility function to get max of 2 integers ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE int max ( int a , int b ) ; int lcs ( char * X , char * Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } int main ( ) { char X [ ] = \" AGGTAB \" ; char Y [ ] = \" GXTXAYB \" ; int m = strlen ( X ) ; int n = strlen ( Y ) ; printf ( \" Length \u2581 of \u2581 LCS \u2581 is \u2581 % d \" , lcs ( X , Y , m , n ) ) ; return 0 ; }"}
{"text": "Longest Common Subsequence | DP | Dynamic Programming C implementation of LCS problem ; Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains length of LCS of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] ; L [ m ] [ n ] contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] ; Utility function to get max of 2 integers ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE int max ( int a , int b ) ; int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } int main ( ) { char X [ ] = \" AGGTAB \" ; char Y [ ] = \" GXTXAYB \" ; int m = strlen ( X ) ; int n = strlen ( Y ) ; printf ( \" Length \u2581 of \u2581 LCS \u2581 is \u2581 % d \" , lcs ( X , Y , m , n ) ) ; return 0 ; }"}
{"text": "Min Cost Path | DP | A Naive recursive implementation of MCP ( Minimum Cost Path ) problem ; A utility function that returns minimum of 3 integers ; Returns cost of minimum cost path from ( 0 , 0 ) to ( m , n ) in mat [ R ] [ C ] ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE int min ( int x , int y , int z ) ; int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } int minCost ( int cost [ R ] [ C ] , int m , int n ) { if ( n < 0 m < 0 ) return INT_MAX ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; printf ( \" \u2581 % d \u2581 \" , minCost ( cost , 2 , 2 ) ) ; return 0 ; }"}
{"text": "Min Cost Path | DP | Dynamic Programming implementation of MCP problem ; Instead of following line , we can use int tc [ m + 1 ] [ n + 1 ] or dynamically allocate memory to save space . The following line is used to keep the program simple and make it working on all compilers . ; Initialize first column of total cost ( tc ) array ; Initialize first row of tc array ; Construct rest of the tc array ; A utility function that returns minimum of 3 integers ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE int min ( int x , int y , int z ) ; int minCost ( int cost [ R ] [ C ] , int m , int n ) { int i , j ; int tc [ R ] [ C ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; } int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; printf ( \" \u2581 % d \u2581 \" , minCost ( cost , 2 , 2 ) ) ; return 0 ; }"}
{"text": "0 | A Naive recursive implementation of 0 - 1 Knapsack problem ; A utility function that returns maximum of two integers ; Returns the maximum value that can be put in a knapsack of capacity W ; Base Case ; If weight of the nth item is more than Knapsack capacity W , then this item cannot be included in the optimal solution ; Return the maximum of two cases : ( 1 ) nth item included ( 2 ) not included ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printf ( \" % d \" , knapSack ( W , wt , val , n ) ) ; return 0 ; }"}
{"text": "0 | A Dynamic Programming based solution for 0 - 1 Knapsack problem ; A utility function that returns maximum of two integers ; Returns the maximum value that can be put in a knapsack of capacity W ; Build table K [ ] [ ] in bottom up manner ; Driver Code", "code": "#include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; } int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printf ( \" % d \" , knapSack ( W , wt , val , n ) ) ; return 0 ; }"}
{"text": "Egg Dropping Puzzle | DP |  ; A utility function to get maximum of two integers ; Function to get minimum number of trials needed in worst case with n eggs and k floors ; If there are no floors , then no trials needed . OR if there is one floor , one trial needed . ; We need k trials for one egg and k floors ; Consider all droppings from 1 st floor to kth floor and return the minimum of these values plus 1. ; Driver program to test to pront printDups", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int eggDrop ( int n , int k ) { if ( k == 1 k == 0 ) return k ; if ( n == 1 ) return k ; int min = INT_MAX , x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; } int main ( ) { int n = 2 , k = 10 ; printf ( \" nMinimum \u2581 number \u2581 of \u2581 trials \u2581 in \u2581 \" \" worst \u2581 case \u2581 with \u2581 % d \u2581 eggs \u2581 and \u2581 \" \" % d \u2581 floors \u2581 is \u2581 % d \u2581 STRNEWLINE \" , n , k , eggDrop ( n , k ) ) ; return 0 ; }"}
{"text": "Longest Palindromic Subsequence | DP | C program of above approach ; A utility function to get max of two integers ; Returns the length of the longest palindromic subsequence in seq ; Base Case 1 : If there is only 1 character ; Base Case 2 : If there are only 2 characters and both are same ; If the first and last characters match ; If the first and last characters do not match ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int max ( int x , int y ) { return ( x > y ) ? x : y ; } int lps ( char * seq , int i , int j ) { if ( i == j ) return 1 ; if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ; if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ; return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } int main ( ) { char seq [ ] = \" GEEKSFORGEEKS \" ; int n = strlen ( seq ) ; printf ( \" The \u2581 length \u2581 of \u2581 the \u2581 LPS \u2581 is \u2581 % d \" , lps ( seq , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Word Wrap Problem | DP | A Dynamic programming solution for Word Wrap Problem ; A utility function to print the solution ; l [ ] represents lengths of different words in input sequence . For example , l [ ] = { 3 , 2 , 2 , 5 } is for a sentence like \" aaa \u2581 bb \u2581 cc \u2581 ddddd \" . n is size of l [ ] and M is line width ( maximum no . of characters that can fit in a line ) ; For simplicity , 1 extra space is used in all below arrays extras [ i ] [ j ] will have number of extra spaces if words from i to j are put in a single line ; lc [ i ] [ j ] will have cost of a line which has words from i to j ; c [ i ] will have total cost of optimal arrangement of words from 1 to i ; p [ ] is used to print the solution . ; calculate extra spaces in a single line . The value extra [ i ] [ j ] indicates extra spaces if words from word number i to j are placed in a single line ; Calculate line cost corresponding to the above calculated extra spaces . The value lc [ i ] [ j ] indicates cost of putting words from word number i to j in a single line ; Calculate minimum cost and find minimum cost arrangement . The value c [ j ] indicates optimized cost to arrange words from word number 1 to j . ; Driver program to test above functions", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #define INF  INT_MAX NEW_LINE int printSolution ( int p [ ] , int n ) ; int printSolution ( int p [ ] , int n ) { int k ; if ( p [ n ] == 1 ) k = 1 ; else k = printSolution ( p , p [ n ] - 1 ) + 1 ; printf ( \" Line \u2581 number \u2581 % d : \u2581 From \u2581 word \u2581 no . \u2581 % d \u2581 to \u2581 % d \u2581 STRNEWLINE \" , k , p [ n ] , n ) ; return k ; } void solveWordWrap ( int l [ ] , int n , int M ) { int extras [ n + 1 ] [ n + 1 ] ; int lc [ n + 1 ] [ n + 1 ] ; int c [ n + 1 ] ; int p [ n + 1 ] ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; } for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = INF ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } } c [ 0 ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { c [ j ] = INF ; for ( i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != INF && lc [ i ] [ j ] != INF && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; } int main ( ) { int l [ ] = { 3 , 2 , 2 , 5 } ; int n = sizeof ( l ) / sizeof ( l [ 0 ] ) ; int M = 6 ; solveWordWrap ( l , n , M ) ; return 0 ; }"}
{"text": "Optimal Binary Search Tree | DP | A naive recursive implementation of optimal binary search tree problem ; A utility function to get sum of array elements freq [ i ] to freq [ j ] ; A recursive function to calculate cost of optimal binary search tree ; Base cases no elements in this subarray ; one element in this subarray ; Get sum of freq [ i ] , freq [ i + 1 ] , ... freq [ j ] ; Initialize minimum value ; One by one consider all elements as root and recursively find cost of the BST , compare the cost with min and update min if needed ; Return minimum value ; The main function that calculates minimum cost of a Binary Search Tree . It mainly uses optCost ( ) to find the optimal cost . ; Here array keys [ ] is assumed to be sorted in increasing order . If keys [ ] is not sorted , then add code to sort keys , and rearrange freq [ ] accordingly . ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; } int optCost ( int freq [ ] , int i , int j ) { if ( j < i ) return 0 ; if ( j == i ) return freq [ i ] ; int fsum = sum ( freq , i , j ) ; int min = INT_MAX ; for ( int r = i ; r <= j ; ++ r ) { int cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; } return min + fsum ; } int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { return optCost ( freq , 0 , n - 1 ) ; } int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; printf ( \" Cost \u2581 of \u2581 Optimal \u2581 BST \u2581 is \u2581 % d \u2581 \" , optimalSearchTree ( keys , freq , n ) ) ; return 0 ; }"}
{"text": "Optimal Binary Search Tree | DP | Dynamic Programming code for Optimal Binary Search Tree Problem ; A utility function to get sum of array elements freq [ i ] to freq [ j ] ; A Dynamic Programming based function that calculates minimum cost of a Binary Search Tree . ; Create an auxiliary 2D matrix to store results of subproblems ; For a single key , cost is equal to frequency of the key ; Now we need to consider chains of length 2 , 3 , ... . L is chain length . ; i is row number in cost [ ] [ ] ; Get column number j from row number i and chain length L ; Try making all keys in interval keys [ i . . j ] as root ; c = cost when keys [ r ] becomes root of this subtree ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; } int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { int cost [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = freq [ i ] ; for ( int L = 2 ; L <= n ; L ++ ) { for ( int i = 0 ; i <= n - L + 1 ; i ++ ) { int j = i + L - 1 ; cost [ i ] [ j ] = INT_MAX ; for ( int r = i ; r <= j ; r ++ ) { int c = ( ( r > i ) ? cost [ i ] [ r - 1 ] : 0 ) + ( ( r < j ) ? cost [ r + 1 ] [ j ] : 0 ) + sum ( freq , i , j ) ; if ( c < cost [ i ] [ j ] ) cost [ i ] [ j ] = c ; } } } return cost [ 0 ] [ n - 1 ] ; } int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; printf ( \" Cost \u2581 of \u2581 Optimal \u2581 BST \u2581 is \u2581 % d \u2581 \" , optimalSearchTree ( keys , freq , n ) ) ; return 0 ; }"}
{"text": "Largest Independent Set Problem | DP | A naive recursive implementation of Largest Independent Set problem ; A utility function to find max of two integers ; A binary tree node has data , pointer to left child and a pointer to right child ; The function returns size of the largest independent set in a given binary tree ; Caculate size excluding the current node ; Calculate size including the current node ; Return the maximum of two sizes ; A utility function to create a node ; Driver program to test above functions ; Let us construct the tree given in the above diagram", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int max ( int x , int y ) { return ( x > y ) ? x : y ; } struct node { int data ; struct node * left , * right ; } ; int LISS ( struct node * root ) { if ( root == NULL ) return 0 ; int size_excl = LISS ( root -> left ) + LISS ( root -> right ) ; int size_incl = 1 ; if ( root -> left ) size_incl += LISS ( root -> left -> left ) + LISS ( root -> left -> right ) ; if ( root -> right ) size_incl += LISS ( root -> right -> left ) + LISS ( root -> right -> right ) ; return max ( size_incl , size_excl ) ; } struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printf ( \" Size \u2581 of \u2581 the \u2581 Largest \u2581 Independent \u2581 Set \u2581 is \u2581 % d \u2581 \" , LISS ( root ) ) ; return 0 ; }"}
{"text": "Mobile Numeric Keypad Problem | A Space Optimized C program to count number of possible numbers of given length ; Return count of all possible numbers of length n in a given numeric keyboard ; odd [ i ] , even [ i ] arrays represent count of numbers starting with digit i for any length j ; for j = 1 ; Bottom Up calculation from j = 2 to n ; Here we are explicitly writing lines for each number 0 to 9. But it can always be written as DFS on 4 X3 grid using row , column array valid moves ; Get count of all possible numbers of length \" n \" starting with digit 0 , 1 , 2 , ... , 9 ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int getCount ( char keypad [ ] [ 3 ] , int n ) { if ( keypad == NULL n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int odd [ 10 ] , even [ 10 ] ; int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; } int main ( ) { char keypad [ 4 ] [ 3 ] = { { '1' , '2' , '3' } , { '4' , '5' , '6' } , { '7' , '8' , '9' } , { ' * ' , '0' , ' # ' } } ; printf ( \" Count \u2581 for \u2581 numbers \u2581 of \u2581 length \u2581 % d : \u2581 % dn \" , 1 , getCount ( keypad , 1 ) ) ; printf ( \" Count \u2581 for \u2581 numbers \u2581 of \u2581 length \u2581 % d : \u2581 % dn \" , 2 , getCount ( keypad , 2 ) ) ; printf ( \" Count \u2581 for \u2581 numbers \u2581 of \u2581 length \u2581 % d : \u2581 % dn \" , 3 , getCount ( keypad , 3 ) ) ; printf ( \" Count \u2581 for \u2581 numbers \u2581 of \u2581 length \u2581 % d : \u2581 % dn \" , 4 , getCount ( keypad , 4 ) ) ; printf ( \" Count \u2581 for \u2581 numbers \u2581 of \u2581 length \u2581 % d : \u2581 % dn \" , 5 , getCount ( keypad , 5 ) ) ; return 0 ; }"}
{"text": "Vertex Cover Problem | Set 2 ( Dynamic Programming Solution for Tree ) | Dynamic programming based program for Vertex Cover problem for a Binary Tree ; A utility function to find min of two integers ; A binary tree node has data , pointer to left child and a pointer to right child ; A memoization based function that returns size of the minimum vertex cover . ; The size of minimum vertex cover is zero if tree is empty or there is only one node ; If vertex cover for this node is already evaluated , then return it to save recomputation of same subproblem again . ; Calculate size of vertex cover when root is part of it ; Calculate size of vertex cover when root is not part of it ; Minimum of two values is vertex cover , store it before returning ; A utility function to create a node ; Set the vertex cover as 0 ; Driver program to test above functions ; Let us construct the tree given in the above diagram", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int min ( int x , int y ) { return ( x < y ) ? x : y ; } struct node { int data ; int vc ; struct node * left , * right ; } ; int vCover ( struct node * root ) { if ( root == NULL ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return 0 ; if ( root -> vc != 0 ) return root -> vc ; int size_incl = 1 + vCover ( root -> left ) + vCover ( root -> right ) ; int size_excl = 0 ; if ( root -> left ) size_excl += 1 + vCover ( root -> left -> left ) + vCover ( root -> left -> right ) ; if ( root -> right ) size_excl += 1 + vCover ( root -> right -> left ) + vCover ( root -> right -> right ) ; root -> vc = min ( size_incl , size_excl ) ; return root -> vc ; } struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; temp -> vc = 0 ; return temp ; } int main ( ) { struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printf ( \" Size \u2581 of \u2581 the \u2581 smallest \u2581 vertex \u2581 cover \u2581 is \u2581 % d \u2581 \" , vCover ( root ) ) ; return 0 ; }"}
{"text": "Count number of ways to reach a given score in a game | A C program to count number of possible ways to a given score can be reached in a game where a move can earn 3 or 5 or 10 ; Returns number of ways to reach score n ; table [ i ] will store count of solutions for value i . ; Initialize all table values as 0 ; Base case ( If given value is 0 ) ; One by one consider given 3 moves and update the table [ ] values after the index greater than or equal to the value of the picked move ; Driver program", "code": "#include <stdio.h> NEW_LINE int count ( int n ) { int table [ n + 1 ] , i ; memset ( table , 0 , sizeof ( table ) ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; } int main ( void ) { int n = 20 ; printf ( \" Count \u2581 for \u2581 % d \u2581 is \u2581 % d STRNEWLINE \" , n , count ( n ) ) ; n = 13 ; printf ( \" Count \u2581 for \u2581 % d \u2581 is \u2581 % d \" , n , count ( n ) ) ; return 0 ; }"}
{"text": "Naive algorithm for Pattern Searching | C program for Naive Pattern Searching algorithm ; A loop to slide pat [ ] one by one ; For current index i , check for pattern match ; if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) printf ( \" Pattern \u2581 found \u2581 at \u2581 index \u2581 % d \u2581 STRNEWLINE \" , i ) ; } } int main ( ) { char txt [ ] = \" AABAACAADAABAAABAA \" ; char pat [ ] = \" AABA \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Rabin | Following program is a C implementation of Rabin Karp Algorithm given in the CLRS book ; d is the number of characters in the input alphabet ; pat -> pattern txt -> text q -> A prime number ; hash value for pattern ; hash value for txt ; The value of h would be \" pow ( d , \u2581 M - 1 ) % q \" ; Calculate the hash value of pattern and first window of text ; Slide the pattern over text one by one ; Check the hash values of current window of text and pattern . If the hash values match then only check for characters on by one ; Check for characters one by one ; if p == t and pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Calculate hash value for next window of text : Remove leading digit , add trailing digit ; We might get negative value of t , converting it to positive ; Driver Code ; A prime number ; function call", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define d  256 NEW_LINE void search ( char pat [ ] , char txt [ ] , int q ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i , j ; int p = 0 ; int t = 0 ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; } if ( j == M ) printf ( \" Pattern \u2581 found \u2581 at \u2581 index \u2581 % d \u2581 STRNEWLINE \" , i ) ; } if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } int main ( ) { char txt [ ] = \" GEEKS \u2581 FOR \u2581 GEEKS \" ; char pat [ ] = \" GEEK \" ; int q = 101 ; search ( pat , txt , q ) ; return 0 ; }"}
{"text": "Optimized Naive Algorithm for Pattern Searching | C program for A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different ; A modified Naive Pettern Searching algorithn that is optimized for the cases when all characters of pattern are different ; For current index i , check for pattern match ; if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; slide the pattern by j ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void search ( char pat [ ] , char txt [ ] ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { printf ( \" Pattern \u2581 found \u2581 at \u2581 index \u2581 % d \u2581 STRNEWLINE \" , i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } int main ( ) { char txt [ ] = \" ABCEABCDABCEABCD \" ; char pat [ ] = \" ABCD \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Finite Automata algorithm for Pattern Searching | C program for Finite Automata Pattern searching Algorithm ; If the character c is same as next character in pattern , then simply increment state ; ns stores the result which is next state ; ns finally contains the longest prefix which is also suffix in \" pat [ 0 . . state - 1 ] c \" Start from the largest possible value and stop when you find a prefix which is also suffix ; This function builds the TF table which represents4 Finite Automata for a given pattern ; Prints all occurrences of pat in txt ; Process txt over FA . ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE int getNextState ( char * pat , int M , int state , int x ) { if ( state < M && x == pat [ state ] ) return state + 1 ; int ns , i ; for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] == x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) if ( pat [ i ] != pat [ state - ns + 1 + i ] ) break ; if ( i == ns - 1 ) return ns ; } } return 0 ; } void computeTF ( char * pat , int M , int TF [ ] [ NO_OF_CHARS ] ) { int state , x ; for ( state = 0 ; state <= M ; ++ state ) for ( x = 0 ; x < NO_OF_CHARS ; ++ x ) TF [ state ] [ x ] = getNextState ( pat , M , state , x ) ; } void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int TF [ M + 1 ] [ NO_OF_CHARS ] ; computeTF ( pat , M , TF ) ; int i , state = 0 ; for ( i = 0 ; i < N ; i ++ ) { state = TF [ state ] [ txt [ i ] ] ; if ( state == M ) printf ( \" Pattern found at index % d \" , i - M + 1 ) ; } } int main ( ) { char * txt = \" AABAACAADAABAAABAA \" ; char * pat = \" AABA \" ; search ( pat , txt ) ; return 0 ; }"}
{"text": "Boyer Moore Algorithm for Pattern Searching | C Program for Bad Character Heuristic of Boyer Moore String Matching Algorithm ; A utility function to get maximum of two integers ; The preprocessing function for Boyer Moore 's bad character heuristic ; Initialize all occurrences as - 1 ; Fill the actual value of last occurrence of a character ; A pattern searching function that uses Bad Character Heuristic of Boyer Moore Algorithm ; Fill the bad character array by calling the preprocessing function badCharHeuristic ( ) for given pattern ; s is shift of the pattern with respect to text ; there are n - m + 1 potential allignments ; Keep reducing index j of pattern while characters of pattern and text are matching at this shift s ; If the pattern is present at current shift , then index j will become - 1 after the above loop ; Shift the pattern so that the next character in text aligns with the last occurrence of it in pattern . The condition s + m < n is necessary for the case when pattern occurs at the end of text ; Shift the pattern so that the bad character in text aligns with the last occurrence of it in pattern . The max function is used to make sure that we get a positive shift . We may get a negative shift if the last occurrence of bad character in pattern is on the right side of the current character . ; Driver program to test above function", "code": "# include <limits.h> NEW_LINE # include <string.h> NEW_LINE # include <stdio.h> NEW_LINE # define NO_OF_CHARS  256 NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } void badCharHeuristic ( char * str , int size , int badchar [ NO_OF_CHARS ] ) { int i ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) badchar [ i ] = -1 ; for ( i = 0 ; i < size ; i ++ ) badchar [ ( int ) str [ i ] ] = i ; } void search ( char * txt , char * pat ) { int m = strlen ( pat ) ; int n = strlen ( txt ) ; int badchar [ NO_OF_CHARS ] ; badCharHeuristic ( pat , m , badchar ) ; int s = 0 ; while ( s <= ( n - m ) ) { int j = m - 1 ; while ( j >= 0 && pat [ j ] == txt [ s + j ] ) j -- ; if ( j < 0 ) { printf ( \" pattern occurs at shift = % d \" , s ) ; s += ( s + m < n ) ? m - badchar [ txt [ s + m ] ] : 1 ; } else s += max ( 1 , j - badchar [ txt [ s + j ] ] ) ; } } int main ( ) { char txt [ ] = \" ABAAABCD \" ; char pat [ ] = \" ABC \" ; search ( txt , pat ) ; return 0 ; }"}
{"text": "Subset Sum | Backtracking |  ; prints subset found ; inputs s - set vector t - tuplet vector s_size - set size t_size - tuplet size so far sum - sum so far ite - nodes count target_sum - sum to be found ; We found subset ; Exclude previously added item and consider next candidate ; generate nodes along the breadth ; consider next level node ( along depth ) ; Wrapper to print subsets that sum to target_sum input is weights vector and target_sum ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define ARRAYSIZE ( a )  (sizeof(a))/(sizeof(a[0])) NEW_LINE static int total_nodes ; void printSubset ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { printf ( \" % * d \" , 5 , A [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } void subset_sum ( int s [ ] , int t [ ] , int s_size , int t_size , int sum , int ite , int const target_sum ) { total_nodes ++ ; if ( target_sum == sum ) { printSubset ( t , t_size ) ; subset_sum ( s , t , s_size , t_size - 1 , sum - s [ ite ] , ite + 1 , target_sum ) ; return ; } else { for ( int i = ite ; i < s_size ; i ++ ) { t [ t_size ] = s [ i ] ; subset_sum ( s , t , s_size , t_size + 1 , sum + s [ i ] , i + 1 , target_sum ) ; } } } void generateSubsets ( int s [ ] , int size , int target_sum ) { int * tuplet_vector = ( int * ) malloc ( size * sizeof ( int ) ) ; subset_sum ( s , tuplet_vector , size , 0 , 0 , 0 , target_sum ) ; free ( tuplet_vector ) ; } int main ( ) { int weights [ ] = { 10 , 7 , 5 , 18 , 12 , 20 , 15 } ; int size = ARRAYSIZE ( weights ) ; generateSubsets ( weights , size , 35 ) ; printf ( \" Nodes \u2581 generated \u2581 % d \u2581 STRNEWLINE \" , total_nodes ) ; return 0 ; }"}
{"text": "Subset Sum | Backtracking |  ; prints subset found ; qsort compare function ; inputs s - set vector t - tuplet vector s_size - set size t_size - tuplet size so far sum - sum so far ite - nodes count target_sum - sum to be found ; We found sum ; constraint check ; Exclude previous added item and consider next candidate ; constraint check ; generate nodes along the breadth ; consider next level node ( along depth ) ; Wrapper that prints subsets that sum to target_sum ; sort the set ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define ARRAYSIZE ( a )  (sizeof(a))/(sizeof(a[0])) NEW_LINE static int total_nodes ; void printSubset ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { printf ( \" % * d \" , 5 , A [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } int comparator ( const void * pLhs , const void * pRhs ) { int * lhs = ( int * ) pLhs ; int * rhs = ( int * ) pRhs ; return * lhs > * rhs ; } void subset_sum ( int s [ ] , int t [ ] , int s_size , int t_size , int sum , int ite , int const target_sum ) { total_nodes ++ ; if ( target_sum == sum ) { printSubset ( t , t_size ) ; if ( ite + 1 < s_size && sum - s [ ite ] + s [ ite + 1 ] <= target_sum ) { subset_sum ( s , t , s_size , t_size - 1 , sum - s [ ite ] , ite + 1 , target_sum ) ; } return ; } else { if ( ite < s_size && sum + s [ ite ] <= target_sum ) { for ( int i = ite ; i < s_size ; i ++ ) { t [ t_size ] = s [ i ] ; if ( sum + s [ i ] <= target_sum ) { subset_sum ( s , t , s_size , t_size + 1 , sum + s [ i ] , i + 1 , target_sum ) ; } } } } } void generateSubsets ( int s [ ] , int size , int target_sum ) { int * tuplet_vector = ( int * ) malloc ( size * sizeof ( int ) ) ; int total = 0 ; qsort ( s , size , sizeof ( int ) , & comparator ) ; for ( int i = 0 ; i < size ; i ++ ) { total += s [ i ] ; } if ( s [ 0 ] <= target_sum && total >= target_sum ) { subset_sum ( s , tuplet_vector , size , 0 , 0 , 0 , target_sum ) ; } free ( tuplet_vector ) ; } int main ( ) { int weights [ ] = { 15 , 22 , 14 , 26 , 32 , 9 , 16 , 8 } ; int target = 53 ; int size = ARRAYSIZE ( weights ) ; generateSubsets ( weights , size , target ) ; printf ( \" Nodes \u2581 generated \u2581 % d STRNEWLINE \" , total_nodes ) ; return 0 ; }"}
{"text": "Sudoku | Backtracking |  ; N is the size of the 2D matrix N * N ; A utility function to print grid ; Checks whether it will be legal to assign num to the given row , col ; Check if we find the same num in the similar row , we return 0 ; Check if we find the same num in the similar column , we return 0 ; Check if we find the same num in the particular 3 * 3 matrix , we return 0 ; Takes a partially filled - in grid and attempts to assign values to all unassigned locations in such a way to meet the requirements for Sudoku solution ( non - duplication across rows , columns , and boxes ) ; Check if we have reached the 8 th row and 9 th column ( 0 indexed matrix ) , we are returning true to avoid further backtracking ; Check if column value becomes 9 , we move to next row and column start from 0 ; Check if the current position of the grid already contains value > 0 , we iterate for next column ; Check if it is safe to place the num ( 1 - 9 ) in the given row , col -> we move to next column ; assigning the num in the current ( row , col ) position of the grid and assuming our assined num in the position is correct ; Checking for next possibility with next column ; Removing the assigned num , since our assumption was wrong , and we go for next assumption with diff num value ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define N  9 NEW_LINE void print ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( \" % d \u2581 \" , arr [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } } int isSafe ( int grid [ N ] [ N ] , int row , int col , int num ) { for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ row ] [ x ] == num ) return 0 ; for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ x ] [ col ] == num ) return 0 ; int startRow = row - row % 3 , startCol = col - col % 3 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow ] [ j + startCol ] == num ) return 0 ; return 1 ; } int solveSuduko ( int grid [ N ] [ N ] , int row , int col ) { if ( row == N - 1 && col == N ) return 1 ; if ( col == N ) { row ++ ; col = 0 ; } if ( grid [ row ] [ col ] > 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( int num = 1 ; num <= N ; num ++ ) { if ( isSafe ( grid , row , col , num ) == 1 ) { grid [ row ] [ col ] = num ; if ( solveSuduko ( grid , row , col + 1 ) == 1 ) return 1 ; } grid [ row ] [ col ] = 0 ; } return 0 ; } int main ( ) { int grid [ N ] [ N ] = { { 3 , 0 , 6 , 5 , 0 , 8 , 4 , 0 , 0 } , { 5 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 8 , 7 , 0 , 0 , 0 , 0 , 3 , 1 } , { 0 , 0 , 3 , 0 , 1 , 0 , 0 , 8 , 0 } , { 9 , 0 , 0 , 8 , 6 , 3 , 0 , 0 , 5 } , { 0 , 5 , 0 , 0 , 9 , 0 , 6 , 0 , 0 } , { 1 , 3 , 0 , 0 , 0 , 0 , 2 , 5 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 4 } , { 0 , 0 , 5 , 2 , 0 , 6 , 3 , 0 , 0 } } ; if ( solveSuduko ( grid , 0 , 0 ) == 1 ) print ( grid ) ; else printf ( \" No \u2581 solution \u2581 exists \" ) ; return 0 ; }"}
{"text": "Median of two sorted arrays of same size | A Simple Merge based O ( n ) solution to find median of two sorted arrays ; This function returns median of ar1 [ ] and ar2 [ ] . Assumptions in this function : Both ar1 [ ] and ar2 [ ] are sorted arrays Both have n elements ; Since there are 2 n elements , median will be average of elements at index n - 1 and n in the array obtained after merging ar1 and ar2 ; Below is to handle case where all elements of ar1 [ ] are smaller than smallest ( or first ) element of ar2 [ ] ; Below is to handle case where all elements of ar2 [ ] are smaller than smallest ( or first ) element of ar1 [ ] ; equals sign because if two arrays have some common elements ; Store the prev median ; Store the prev median ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = -1 , m2 = -1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; } int main ( ) { int ar1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; if ( n1 == n2 ) printf ( \" Median \u2581 is \u2581 % d \" , getMedian ( ar1 , ar2 , n1 ) ) ; else printf ( \" Doesn ' t \u2581 work \u2581 for \u2581 arrays \u2581 of \u2581 unequal \u2581 size \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Median of two sorted arrays of same size | A divide and conquer based efficient solution to find median of two sorted arrays of same size . ; to get median of a sorted array ; This function returns median of ar1 [ ] and ar2 [ ] . Assumptions in this function : Both ar1 [ ] and ar2 [ ] are sorted arrays Both have n elements ; get the median of the first array ; get the median of the second array ; If medians are equal then return either m1 or m2 ; if m1 < m2 then median must exist in ar1 [ m1 ... . ] and ar2 [ ... . m2 ] ; if m1 > m2 then median must exist in ar1 [ ... . m1 ] and ar2 [ m2 ... ] ; Function to get median of a sorted array ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int median ( int [ ] , int ) ; int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { if ( n <= 0 ) return -1 ; if ( n == 1 ) return ( ar1 [ 0 ] + ar2 [ 0 ] ) / 2 ; if ( n == 2 ) return ( max ( ar1 [ 0 ] , ar2 [ 0 ] ) + min ( ar1 [ 1 ] , ar2 [ 1 ] ) ) / 2 ; int m1 = median ( ar1 , n ) ; int m2 = median ( ar2 , n ) ; if ( m1 == m2 ) return m1 ; if ( m1 < m2 ) { if ( n % 2 == 0 ) return getMedian ( ar1 + n / 2 - 1 , ar2 , n - n / 2 + 1 ) ; return getMedian ( ar1 + n / 2 , ar2 , n - n / 2 ) ; } if ( n % 2 == 0 ) return getMedian ( ar2 + n / 2 - 1 , ar1 , n - n / 2 + 1 ) ; return getMedian ( ar2 + n / 2 , ar1 , n - n / 2 ) ; } int median ( int arr [ ] , int n ) { if ( n % 2 == 0 ) return ( arr [ n / 2 ] + arr [ n / 2 - 1 ] ) / 2 ; else return arr [ n / 2 ] ; } int main ( ) { int ar1 [ ] = { 1 , 2 , 3 , 6 } ; int ar2 [ ] = { 4 , 6 , 8 , 10 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; if ( n1 == n2 ) printf ( \" Median \u2581 is \u2581 % d \" , getMedian ( ar1 , ar2 , n1 ) ) ; else printf ( \" Doesn ' t \u2581 work \u2581 for \u2581 arrays \u2581 of \u2581 unequal \u2581 size \" ) ; return 0 ; }"}
{"text": "Closest Pair of Points using Divide and Conquer algorithm | A divide and conquer program in C / C ++ to find the smallest distance from a given set of points . ; A structure to represent a Point in 2D plane ; Needed to sort array of points according to X coordinate ; Needed to sort array of points according to Y coordinate ; A utility function to find the distance between two points ; A Brute Force method to return the smallest distance between two points in P [ ] of size n ; A utility function to find a minimum of two float values ; A utility function to find the distance between the closest points of strip of a given size . All points in strip [ ] are sorted according to y coordinate . They all have an upper bound on minimum distance as d . Note that this method seems to be a O ( n ^ 2 ) method , but it 's a O(n) method as the inner loop runs at most 6 times ; Initialize the minimum distance as d ; Pick all points one by one and try the next points till the difference between y coordinates is smaller than d . This is a proven fact that this loop runs at most 6 times ; A recursive function to find the smallest distance . The array P contains all points sorted according to x coordinate ; If there are 2 or 3 points , then use brute force ; Find the middle point ; Consider the vertical line passing through the middle point calculate the smallest distance dl on left of middle point and dr on right side ; Find the smaller of two distances ; Build an array strip [ ] that contains points close ( closer than d ) to the line passing through the middle point ; Find the closest points in strip . Return the minimum of d and closest distance is strip [ ] ; The main function that finds the smallest distance This method mainly uses closestUtil ( ) ; Use recursive function closestUtil ( ) to find the smallest distance ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <float.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <math.h> NEW_LINE struct Point { int x , y ; } ; int compareX ( const void * a , const void * b ) { Point * p1 = ( Point * ) a , * p2 = ( Point * ) b ; return ( p1 -> x - p2 -> x ) ; } int compareY ( const void * a , const void * b ) { Point * p1 = ( Point * ) a , * p2 = ( Point * ) b ; return ( p1 -> y - p2 -> y ) ; } float dist ( Point p1 , Point p2 ) { return sqrt ( ( p1 . x - p2 . x ) * ( p1 . x - p2 . x ) + ( p1 . y - p2 . y ) * ( p1 . y - p2 . y ) ) ; } float bruteForce ( Point P [ ] , int n ) { float min = FLT_MAX ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i + 1 ; j < n ; ++ j ) if ( dist ( P [ i ] , P [ j ] ) < min ) min = dist ( P [ i ] , P [ j ] ) ; return min ; } float min ( float x , float y ) { return ( x < y ) ? x : y ; } float stripClosest ( Point strip [ ] , int size , float d ) { float min = d ; qsort ( strip , size , sizeof ( Point ) , compareY ) ; for ( int i = 0 ; i < size ; ++ i ) for ( int j = i + 1 ; j < size && ( strip [ j ] . y - strip [ i ] . y ) < min ; ++ j ) if ( dist ( strip [ i ] , strip [ j ] ) < min ) min = dist ( strip [ i ] , strip [ j ] ) ; return min ; } float closestUtil ( Point P [ ] , int n ) { if ( n <= 3 ) return bruteForce ( P , n ) ; int mid = n / 2 ; Point midPoint = P [ mid ] ; float dl = closestUtil ( P , mid ) ; float dr = closestUtil ( P + mid , n - mid ) ; float d = min ( dl , dr ) ; Point strip [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( abs ( P [ i ] . x - midPoint . x ) < d ) strip [ j ] = P [ i ] , j ++ ; return min ( d , stripClosest ( strip , j , d ) ) ; } float closest ( Point P [ ] , int n ) { qsort ( P , n , sizeof ( Point ) , compareX ) ; return closestUtil ( P , n ) ; } int main ( ) { Point P [ ] = { { 2 , 3 } , { 12 , 30 } , { 40 , 50 } , { 5 , 1 } , { 12 , 10 } , { 3 , 4 } } ; int n = sizeof ( P ) / sizeof ( P [ 0 ] ) ; printf ( \" The \u2581 smallest \u2581 distance \u2581 is \u2581 % f \u2581 \" , closest ( P , n ) ) ; return 0 ; }"}
{"text": "Lucky Numbers |  ; Returns 1 if n is a lucky no . ohterwise returns 0 ; variable next_position is just for readability of the program we can remove it and use n only ; calculate next position of input no ; Driver function to test above function", "code": "#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isLucky ( int n ) { static int counter = 2 ; int next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; } int main ( ) { int x = 5 ; if ( isLucky ( x ) ) printf ( \" % d \u2581 is \u2581 a \u2581 lucky \u2581 no . \" , x ) ; else printf ( \" % d \u2581 is \u2581 not \u2581 a \u2581 lucky \u2581 no . \" , x ) ; getchar ( ) ; }"}
{"text": "Write you own Power without using multiplication ( * ) and division ( / ) operators |  ; Works only if a >= 0 and b >= 0 ; driver program to test above function", "code": "#include <stdio.h> NEW_LINE int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; } int main ( ) { printf ( \" % d \" , pow ( 5 , 3 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Write you own Power without using multiplication ( * ) and division ( / ) operators |  ; A recursive function to get x * y ; A recursive function to get a ^ b Works only if a >= 0 and b >= 0 ; driver program to test above functions", "code": "#include <stdio.h> NEW_LINE int multiply ( int x , int y ) { if ( y ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; } int pow ( int a , int b ) { if ( b ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; } int main ( ) { printf ( \" % d \" , pow ( 5 , 3 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Count numbers that don 't contain 3 |  ; returns count of numbers which are in range from 1 to n and don 't contain 3  as a digit  ; Base cases ( Assuming n is not negative ) ; Calculate 10 ^ ( d - 1 ) ( 10 raise to the power d - 1 ) where d is number of digits in n . po will be 100 for n = 578 ; find the most significant digit ( msd is 5 for 578 ) ; For 578 , total will be 4 * count ( 10 ^ 2 - 1 ) + 4 + count ( 78 ) ; For 35 , total will be equal to count ( 29 ) ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; } int main ( ) { printf ( \" % d \u2581 \" , count ( 578 ) ) ; return 0 ; }"}
{"text": "Lexicographic rank of a string | C program to find lexicographic rank of a string ; A utility function to find factorial of n ; A utility function to count smaller characters on right of arr [ low ] ; A function to find rank of a string in all permutations of characters ; count number of chars smaller than str [ i ] fron str [ i + 1 ] to str [ len - 1 ] ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } int findSmallerInRight ( char * str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str [ i ] < str [ low ] ) ++ countRight ; return countRight ; } int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; int i ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ; countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; } int main ( ) { char str [ ] = \" string \" ; printf ( \" % d \" , findRank ( str ) ) ; return 0 ; }"}
{"text": "Lexicographic rank of a string | A O ( n ) solution for finding rank of string ; all elements of count [ ] are initialized with 0 ; A utility function to find factorial of n ; Construct a count array where value at every index contains count of smaller characters in whole string ; Removes a character ch from count [ ] array constructed by populateAndIncreaseCount ( ) ; A function to find rank of a string in all permutations of characters ; Populate the count array such that count [ i ] contains count of characters which are present in str and are smaller than i ; count number of chars smaller than str [ i ] fron str [ i + 1 ] to str [ len - 1 ] ; Reduce count of characters greater than str [ i ] ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define MAX_CHAR  256 NEW_LINE int count [ MAX_CHAR ] = { 0 } ; int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } void populateAndIncreaseCount ( int * count , char * str ) { int i ; for ( i = 0 ; str [ i ] ; ++ i ) ++ count [ str [ i ] ] ; for ( i = 1 ; i < MAX_CHAR ; ++ i ) count [ i ] += count [ i - 1 ] ; } void updatecount ( int * count , char ch ) { int i ; for ( i = ch ; i < MAX_CHAR ; ++ i ) -- count [ i ] ; } int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 , i ; populateAndIncreaseCount ( count , str ) ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ; rank += count [ str [ i ] - 1 ] * mul ; updatecount ( count , str [ i ] ) ; } return rank ; } int main ( ) { char str [ ] = \" string \" ; printf ( \" % d \" , findRank ( str ) ) ; return 0 ; }"}
{"text": "Print all permutations in sorted ( lexicographic ) order | Program to print all permutations of a string in sorted order . ; Following function is needed for library function qsort ( ) . Refer http : www . cplusplus . com / reference / clibrary / cstdlib / qsort / ; A utility function two swap two characters a and b ; This function finds the index of the smallest character which is greater than ' first ' and is present in str [ l . . h ] ; initialize index of ceiling element ; Now iterate through rest of the elements and find the smallest character greater than ' first ' ; Print all permutations of str in sorted order ; Get size of string ; Sort the string in increasing order ; Print permutations one by one ; print this permutation ; Find the rightmost character which is smaller than its next character . Let us call it ' first \u2581 char ' ; If there is no such character , all are sorted in decreasing order , means we just printed the last permutation and we are done . ; Find the ceil of ' first \u2581 char ' in right of first character . Ceil of a character is the smallest character greater than it ; Swap first and second characters ; Sort the string on right of ' first \u2581 char ' ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE int compare ( const void * a , const void * b ) { return ( * ( char * ) a - * ( char * ) b ) ; } void swap ( char * a , char * b ) { char t = * a ; * a = * b ; * b = t ; } int findCeil ( char str [ ] , char first , int l , int h ) { int ceilIndex = l ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( str [ i ] > first && str [ i ] < str [ ceilIndex ] ) ceilIndex = i ; return ceilIndex ; } void sortedPermutations ( char str [ ] ) { int size = strlen ( str ) ; qsort ( str , size , sizeof ( str [ 0 ] ) , compare ) ; bool isFinished = false ; while ( ! isFinished ) { printf ( \" % s \u2581 STRNEWLINE \" , str ) ; int i ; for ( i = size - 2 ; i >= 0 ; -- i ) if ( str [ i ] < str [ i + 1 ] ) break ; if ( i == -1 ) isFinished = true ; else { int ceilIndex = findCeil ( str , str [ i ] , i + 1 , size - 1 ) ; swap ( & str [ i ] , & str [ ceilIndex ] ) ; qsort ( str + i + 1 , size - i - 1 , sizeof ( str [ 0 ] ) , compare ) ; } } } int main ( ) { char str [ ] = \" ABCD \" ; sortedPermutations ( str ) ; return 0 ; }"}
{"text": "Print all permutations in sorted ( lexicographic ) order | An optimized version that uses reverse instead of sort for finding the next permutation A utility function to reverse a string str [ l . . h ] ;  ;  ; Print all permutations of str in sorted order ; Get size of string ; Sort the string in increasing order ; Print permutations one by one ; print this permutation ; Find the rightmost character which is smaller than its next character . Let us call it ' first \u2581 char ' ; If there is no such character , all are sorted in decreasing order , means we just printed the last permutation and we are done . ; Find the ceil of ' first \u2581 char ' in right of first character . Ceil of a character is the smallest character greater than it ; Swap first and second characters ; reverse the string on right of ' first \u2581 char '", "code": "void reverse ( char str [ ] , int l , int h ) { while ( l < h ) { swap ( & str [ l ] , & str [ h ] ) ; l ++ ; h -- ; } } void swap ( char * a , char * b ) { char t = * a ; * a = * b ; * b = t ; } int compare ( const void * a , const void * b ) { return ( * ( char * ) a - * ( char * ) b ) ; } int findCeil ( char str [ ] , char first , int l , int h ) { int ceilIndex = l ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( str [ i ] > first && str [ i ] < str [ ceilIndex ] ) ceilIndex = i ; return ceilIndex ; } void sortedPermutations ( char str [ ] ) { int size = strlen ( str ) ; qsort ( str , size , sizeof ( str [ 0 ] ) , compare ) ; bool isFinished = false ; while ( ! isFinished ) { printf ( \" % s \u2581 STRNEWLINE \" , str ) ; int i ; for ( i = size - 2 ; i >= 0 ; -- i ) if ( str [ i ] < str [ i + 1 ] ) break ; if ( i == -1 ) isFinished = true ; else { int ceilIndex = findCeil ( str , str [ i ] , i + 1 , size - 1 ) ; swap ( & str [ i ] , & str [ ceilIndex ] ) ; reverse ( str , i + 1 , size - 1 ) ; } } }"}
{"text": "Efficient program to calculate e ^ x | C Efficient program to calculate e raise to the power x ; Returns approximate value of e ^ x using sum of first n terms of Taylor Series ; initialize sum of series ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE float exponential ( int n , float x ) { float sum = 1.0f ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; } int main ( ) { int n = 10 ; float x = 1.0f ; printf ( \" e ^ x \u2581 = \u2581 % f \" , exponential ( n , x ) ) ; return 0 ; }"}
{"text": "Random number generator in arbitrary probability distribution fashion | C program to generate random numbers according to given frequency distribution ; Utility function to find ceiling of r in arr [ l . . h ] ; Same as mid = ( l + h ) / 2 ; The main function that returns a random number from arr [ ] according to distribution array defined by freq [ ] . n is size of arrays . ; Create and fill prefix array ; prefix [ n - 1 ] is sum of all frequencies . Generate a random number with value from 1 to this sum ; Find index of ceiling of r in prefix arrat ; Driver program to test above functions ; Use a different seed value for every run . ; Let us generate 10 random numbers accroding to given distribution", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int findCeil ( int arr [ ] , int r , int l , int h ) { int mid ; while ( l < h ) { mid = l + ( ( h - l ) >> 1 ) ; ( r > arr [ mid ] ) ? ( l = mid + 1 ) : ( h = mid ) ; } return ( arr [ l ] >= r ) ? l : -1 ; } int myRand ( int arr [ ] , int freq [ ] , int n ) { int prefix [ n ] , i ; prefix [ 0 ] = freq [ 0 ] ; for ( i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] + freq [ i ] ; int r = ( rand ( ) % prefix [ n - 1 ] ) + 1 ; int indexc = findCeil ( prefix , r , 0 , n - 1 ) ; return arr [ indexc ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int freq [ ] = { 10 , 5 , 20 , 100 } ; int i , n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; srand ( time ( NULL ) ) ; for ( i = 0 ; i < 5 ; i ++ ) printf ( \" % d STRNEWLINE \" , myRand ( arr , freq , n ) ) ; return 0 ; }"}
{"text": "Write a function that generates one of 3 numbers according to given probabilities | This function generates ' x ' with probability px / 100 , ' y ' with probability py / 100 and ' z ' with probability pz / 100 : Assumption : px + py + pz = 100 where px , py and pz lie between 0 to 100 ; Generate a number from 1 to 100 ; r is smaller than px with probability px / 100 ; r is greater than px and smaller than or equal to px + py with probability py / 100 ; r is greater than px + py and smaller than or equal to 100 with probability pz / 100", "code": "int random ( int x , int y , int z , int px , int py , int pz ) { int r = rand ( 1 , 100 ) ; if ( r <= px ) return x ; if ( r <= ( px + py ) ) return y ; else return z ; }"}
{"text": "Calculate the angle between hour hand and minute hand | C program to find angle between hour and minute hands ; Utility function to find minimum of two integers ; Function to calculate the angle ; validate the input ; Calculate the angles moved by hour and minute hands with reference to 12 : 00 ; Find the difference between two angles ; Return the smaller angle of two possible angles ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int min ( int x , int y ) { return ( x < y ) ? x : y ; } int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) printf ( \" Wrong \u2581 input \" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } int hour_angle = 0.5 * ( h * 60 + m ) ; int minute_angle = 6 * m ; int angle = abs ( hour_angle - minute_angle ) ; angle = min ( 360 - angle , angle ) ; return angle ; } int main ( ) { printf ( \" % d \u2581 n \" , calcAngle ( 9 , 60 ) ) ; printf ( \" % d \u2581 n \" , calcAngle ( 3 , 30 ) ) ; return 0 ; }"}
{"text": "Find the element that appears once | C program to find the element that occur only once ; Method to find the element that occur only once ; The expression \" one \u2581 & \u2581 arr [ i ] \" gives the bits that are there in both ' ones ' and new element from arr [ ] . We add these bits to ' twos ' using bitwise OR Value of ' twos ' will be set as 0 , 3 , 3 and 1 after 1 st , 2 nd , 3 rd and 4 th iterations respectively ; XOR the new bits with previous ' ones ' to get all bits appearing odd number of times Value of ' ones ' will be set as 3 , 0 , 2 and 3 after 1 st , 2 nd , 3 rd and 4 th iterations respectively ; The common bits are those bits which appear third time So these bits should not be there in both ' ones ' and ' twos ' . common_bit_mask contains all these bits as 0 , so that the bits can be removed from ' ones ' and ' twos ' Value of ' common _ bit _ mask ' will be set as 00 , 00 , 01 and 10 after 1 st , 2 nd , 3 rd and 4 th iterations respectively ; Remove common bits ( the bits that appear third time ) from ' ones ' Value of ' ones ' will be set as 3 , 0 , 0 and 2 after 1 st , 2 nd , 3 rd and 4 th iterations respectively ; Remove common bits ( the bits that appear third time ) from ' twos ' Value of ' twos ' will be set as 0 , 3 , 1 and 0 after 1 st , 2 nd , 3 rd and 4 th itearations respectively ; Driver Code", "code": "#include <stdio.h> NEW_LINE int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; } int main ( ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The \u2581 element \u2581 with \u2581 single \u2581 occurrence \u2581 is \u2581 % d \u2581 \" , getSingle ( arr , n ) ) ; return 0 ; }"}
{"text": "Find the element that appears once | C program to find the element that occur only once ; Initialize result ; Iterate through every bit ; Find sum of set bits at ith position in all array elements ; The bits with sum not multiple of 3 , are the bits of element with single occurrence . ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #define INT_SIZE  32 NEW_LINE int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; } int main ( ) { int arr [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The \u2581 element \u2581 with \u2581 single \u2581 occurrence \u2581 is \u2581 % d \u2581 \" , getSingle ( arr , n ) ) ; return 0 ; }"}
{"text": "Count total set bits in all numbers from 1 to n | A O ( Logn ) complexity program to count set bits in all numbers from 1 to n ; Returns position of leftmost set bit . The rightmost position is considered as 0 ; Given the position of previous leftmost set bit in n ( or an upper bound on leftmost position ) returns the new position of leftmost set bit in n ; The main recursive function used by countSetBits ( ) ; Get the position of leftmost set bit in n . This will be used as an upper bound for next set bit function ; Use the position ; Base Case : if n is 0 , then set bit count is 0 ; get position of next leftmost set bit ; If n is of the form 2 ^ x - 1 , i . e . , if n is like 1 , 3 , 7 , 15 , 31 , . . etc , then we are done . Since positions are considered starting from 0 , 1 is added to m ; update n for next recursive call ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE unsigned int getLeftmostBit ( int n ) { int m = 0 ; while ( n > 1 ) { n = n >> 1 ; m ++ ; } return m ; } unsigned int getNextLeftmostBit ( int n , int m ) { unsigned int temp = 1 << m ; while ( n < temp ) { temp = temp >> 1 ; m -- ; } return m ; } unsigned int _countSetBits ( unsigned int n , int m ) ; unsigned int countSetBits ( unsigned int n ) { int m = getLeftmostBit ( n ) ; return _countSetBits ( n , m ) ; } unsigned int _countSetBits ( unsigned int n , int m ) { if ( n == 0 ) return 0 ; m = getNextLeftmostBit ( n , m ) ; if ( n == ( ( unsigned int ) 1 << ( m + 1 ) ) - 1 ) return ( unsigned int ) ( m + 1 ) * ( 1 << m ) ; n = n - ( 1 << m ) ; return ( n + 1 ) + countSetBits ( n ) + m * ( 1 << ( m - 1 ) ) ; } int main ( ) { int n = 17 ; printf ( \" Total \u2581 set \u2581 bit \u2581 count \u2581 is \u2581 % d \" , countSetBits ( n ) ) ; return 0 ; }"}
{"text": "Swap bits in a given number | C Program to swap bits in a given number ; Move all bits of first set to rightmost side ; Move all bits of second set to rightmost side ; XOR the two sets ; Put the xor bits back to their original positions ; XOR the ' xor ' with the original number so that the two sets are swapped ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int swapBits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) { unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ; unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ; unsigned int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; unsigned int result = x ^ xor ; return result ; } int main ( ) { int res = swapBits ( 28 , 0 , 3 , 2 ) ; printf ( \" Result = % d \" , res ) ; return 0 ; }"}
{"text": "Smallest of three integers without comparison operators | C program to find Smallest of three integers without comparison operators ; Driver code", "code": "#include <stdio.h> NEW_LINE int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; } int main ( ) { int x = 12 , y = 15 , z = 5 ; printf ( \" Minimum \u2581 of \u2581 3 \u2581 numbers \u2581 is \u2581 % d \" , smallest ( x , y , z ) ) ; return 0 ; }"}
{"text": "Smallest of three integers without comparison operators | C implementation of above approach ; Function to find minimum of x and y ; Function to find minimum of 3 numbers x , y and z ; Driver code", "code": "#include <stdio.h> NEW_LINE #define CHAR_BIT  8 NEW_LINE int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; } int smallest ( int x , int y , int z ) { return min ( x , min ( y , z ) ) ; } int main ( ) { int x = 12 , y = 15 , z = 5 ; printf ( \" Minimum \u2581 of \u2581 3 \u2581 numbers \u2581 is \u2581 % d \" , smallest ( x , y , z ) ) ; return 0 ; }"}
{"text": "Smallest of three integers without comparison operators |  ; Using division operator to find minimum of three numbers ; Same as \" if \u2581 ( y \u2581 < \u2581 x ) \" ; Driver code", "code": "#include <stdio.h> NEW_LINE int smallest ( int x , int y , int z ) { if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ; return ( ! ( x / z ) ) ? x : z ; } int main ( ) { int x = 78 , y = 88 , z = 68 ; printf ( \" Minimum \u2581 of \u2581 3 \u2581 numbers \u2581 is \u2581 % d \" , smallest ( x , y , z ) ) ; return 0 ; }"}
{"text": "A Boolean Array Puzzle |  ; Driver code", "code": "void changeToZero ( int a [ 2 ] ) { a [ a [ 1 ] ] = a [ ! a [ 1 ] ] ; } int main ( ) { int a [ ] = { 1 , 0 } ; changeToZero ( a ) ; printf ( \" \u2581 arr [ 0 ] \u2581 = \u2581 % d \u2581 STRNEWLINE \" , a [ 0 ] ) ; printf ( \" \u2581 arr [ 1 ] \u2581 = \u2581 % d \u2581 \" , a [ 1 ] ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program to count number of set bits in an ( big ) array |  ; Size of array 64 K ; GROUP_A - When combined with META_LOOK_UP generates count for 4 x4 elements ; GROUP_B - When combined with META_LOOK_UP generates count for 4 x4x4 elements ; GROUP_C - When combined with META_LOOK_UP generates count for 4 x4x4x4 elements ; Provide appropriate letter to generate the table ; A static table will be much faster to access ; No shifting funda ( for better readability ) ; It is fine , bypass the type system ; Count set bits in individual bytes ; Driver program , generates table of random 64 K numbers ; Seed to the random - number generator ; Generate random numbers .", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <time.h> NEW_LINE #define SIZE  (1 << 16) NEW_LINE #define GROUP_A ( x )  x, x + 1, x + 1, x + 2 NEW_LINE #define GROUP_B ( x )  GROUP_A(x), GROUP_A(x+1), GROUP_A(x+1), GROUP_A(x+2) NEW_LINE #define GROUP_C ( x )  GROUP_B(x), GROUP_B(x+1), GROUP_B(x+1), GROUP_B(x+2) NEW_LINE #define META_LOOK_UP ( PARAMETER )  \\NEW_LINE GROUP_##PARAMETER(0), \\NEW_LINE GROUP_##PARAMETER(1), \\NEW_LINE GROUP_##PARAMETER(1), \\NEW_LINE GROUP_##PARAMETER(2) \\NEW_LINEint countSetBits(int array[], size_t array_size) NEW_LINE { int count = 0 ; static unsigned char const look_up [ ] = { META_LOOK_UP ( C ) } ; unsigned char * pData = NULL ; for ( size_t index = 0 ; index < array_size ; index ++ ) { pData = ( unsigned char * ) & array [ index ] ; count += look_up [ pData [ 0 ] ] ; count += look_up [ pData [ 1 ] ] ; count += look_up [ pData [ 2 ] ] ; count += look_up [ pData [ 3 ] ] ; } return count ; } int main ( ) { int index ; int random [ SIZE ] ; srand ( ( unsigned ) time ( 0 ) ) ; for ( index = 0 ; index < SIZE ; index ++ ) { random [ index ] = rand ( ) ; } printf ( \" Total \u2581 number \u2581 of \u2581 bits \u2581 = \u2581 % d STRNEWLINE \" , countSetBits ( random , SIZE ) ) ; return 0 ; }"}
{"text": "Add 1 to a given number | C ++ code to add add one to a given number ; Flip all the set bits until we find a 0 ; flip the rightmost 0 bit ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE int addOne ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } int main ( ) { printf ( \" % d \" , addOne ( 13 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Add 1 to a given number |  ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE int addOne ( int x ) { return ( - ( ~ x ) ) ; } int main ( ) { printf ( \" % d \" , addOne ( 13 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Turn off the rightmost set bit |  ; unsets the rightmost set bit of n and returns the result ; Driver Code", "code": "#include <stdio.h> NEW_LINE int fun ( unsigned int n ) { return n & ( n - 1 ) ; } int main ( ) { int n = 7 ; printf ( \" The \u2581 number \u2581 after \u2581 unsetting \u2581 the \" ) ; printf ( \" \u2581 rightmost \u2581 set \u2581 bit \u2581 % d \" , fun ( n ) ) ; return 0 ; }"}
{"text": "Find whether a given number is a power of 4 or not |  ; Function to check if x is power of 4 ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; } int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) printf ( \" % d \u2581 is \u2581 a \u2581 power \u2581 of \u2581 4\" , test_no ) ; else printf ( \" % d \u2581 is \u2581 not \u2581 a \u2581 power \u2581 of \u2581 4\" , test_no ) ; getchar ( ) ; }"}
{"text": "Find whether a given number is a power of 4 or not |  ; Function to check if x is power of 4 ; Check if there is only one bit set in n ; count 0 bits before set bit ; If count is even then return true else false ; If there are more than 1 bit set then n is not a power of 4 ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isPowerOfFour ( unsigned int n ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; } int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) printf ( \" % d \u2581 is \u2581 a \u2581 power \u2581 of \u2581 4\" , test_no ) ; else printf ( \" % d \u2581 is \u2581 not \u2581 a \u2581 power \u2581 of \u2581 4\" , test_no ) ; getchar ( ) ; }"}
{"text": "Find whether a given number is a power of 4 or not | C program to check if given number is power of 4 or not ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isPowerOfFour ( unsigned int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ; } int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) printf ( \" % d \u2581 is \u2581 a \u2581 power \u2581 of \u2581 4\" , test_no ) ; else printf ( \" % d \u2581 is \u2581 not \u2581 a \u2581 power \u2581 of \u2581 4\" , test_no ) ; getchar ( ) ; }"}
{"text": "Compute the minimum or maximum of two integers without branching | C program to Compute the minimum or maximum of two integers without branching ; Function to find minimum of x and y ; Function to find maximum of x and y ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x < y ) ) ; } int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x < y ) ) ; } int main ( ) { int x = 15 ; int y = 6 ; printf ( \" Minimum \u2581 of \u2581 % d \u2581 and \u2581 % d \u2581 is \u2581 \" , x , y ) ; printf ( \" % d \" , min ( x , y ) ) ; printf ( \" Maximum of % d and % d is \" printf ( \" % d \" , max ( x , y ) ) ; getchar ( ) ; }"}
{"text": "Compute the minimum or maximum of two integers without branching |  ; Function to find minimum of x and y ; Function to find maximum of x and y ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #define CHAR_BIT  8 NEW_LINE int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; } int max ( int x , int y ) { return x - ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; } int main ( ) { int x = 15 ; int y = 6 ; printf ( \" Minimum \u2581 of \u2581 % d \u2581 and \u2581 % d \u2581 is \u2581 \" , x , y ) ; printf ( \" % d \" , min ( x , y ) ) ; printf ( \" Maximum of % d and % d is \" printf ( \" % d \" , max ( x , y ) ) ; getchar ( ) ; }"}
{"text": "Check for Integer Overflow |  ; Takes pointer to result and two numbers as arguments . If there is no overflow , the function places the resultant = sum a + b in result and returns 0 , otherwise it returns - 1 ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int addOvf ( int * result , int a , int b ) { * result = a + b ; if ( a > 0 && b > 0 && * result < 0 ) return -1 ; if ( a < 0 && b < 0 && * result > 0 ) return -1 ; return 0 ; } int main ( ) { int * res = ( int * ) malloc ( sizeof ( int ) ) ; int x = 2147483640 ; int y = 10 ; printf ( \" % d \" , addOvf ( res , x , y ) ) ; printf ( \" % d \" , * res ) ; getchar ( ) ; return 0 ; }"}
{"text": "Check for Integer Overflow |", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE #include <stdlib.h> NEW_LINE int addOvf ( int * result , int a , int b ) { if ( a > INT_MAX - b ) return -1 ; else { * result = a + b ; return 0 ; } } int main ( ) { int * res = ( int * ) malloc ( sizeof ( int ) ) ; int x = 2147483640 ; int y = 10 ; printf ( \" % d \" , addOvf ( res , x , y ) ) ; printf ( \" % d \" , * res ) ; getchar ( ) ; return 0 ; }"}
{"text": "Little and Big Endian Mystery |", "code": "#include <stdio.h> NEW_LINE int main ( ) { unsigned int i = 1 ; char * c = ( char * ) & i ; if ( * c ) printf ( \" Little \u2581 endian \" ) ; else printf ( \" Big \u2581 endian \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Position of rightmost set bit | C program for Position of rightmost set bit ; Driver code", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE unsigned int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; } int main ( ) { int n = 12 ; printf ( \" % u \" , getFirstSetBitPos ( n ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Binary representation of a given number |  ; bin function ; Driver Code", "code": "#include <stdio.h> NEW_LINE void bin ( unsigned n ) { unsigned i ; for ( i = 1 << 31 ; i > 0 ; i = i / 2 ) ( n & i ) ? printf ( \"1\" ) : printf ( \"0\" ) ; } int main ( void ) { bin ( 7 ) ; printf ( \" STRNEWLINE \" ) ; bin ( 4 ) ; }"}
{"text": "Swap all odd and even bits | C program to swap even and odd bits of a given number ; Function to swap even and odd bits ; Get all even bits of x ; Get all odd bits of x ; Right shift even bits ; Left shift odd bits ; Combine even and odd bits ; Driver program to test above function ; 00010111 ; Output is 43 ( 00101011 )", "code": "#include <stdio.h> NEW_LINE unsigned int swapBits ( unsigned int x ) { unsigned int even_bits = x & 0xAAAAAAAA ; unsigned int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; } int main ( ) { unsigned int x = 23 ; printf ( \" % u \u2581 \" , swapBits ( x ) ) ; return 0 ; }"}
{"text": "Find position of the only set bit | C program to find position of only set bit in a given number ; A utility function to check whether n is a power of 2 or not . goo . gl / 17 Arj See http : ; Returns position of the only set bit in ' n ' ; Iterate through bits of n till we find a set bit i & n will be non - zero only when ' i ' and ' n ' have a set bit at same position ; Unset current bit and set the next bit in ' i ' ; increment position ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; } int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned i = 1 , pos = 1 ; while ( ! ( i & n ) ) { i = i << 1 ; ++ pos ; } return pos ; } int main ( void ) { int n = 16 ; int pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n \u2581 = \u2581 % d , \u2581 Invalid \u2581 number STRNEWLINE \" , n ) : printf ( \" n \u2581 = \u2581 % d , \u2581 Position \u2581 % d \u2581 STRNEWLINE \" , n , pos ) ; n = 12 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n \u2581 = \u2581 % d , \u2581 Invalid \u2581 number STRNEWLINE \" , n ) : printf ( \" n \u2581 = \u2581 % d , \u2581 Position \u2581 % d \u2581 STRNEWLINE \" , n , pos ) ; n = 128 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n \u2581 = \u2581 % d , \u2581 Invalid \u2581 number STRNEWLINE \" , n ) : printf ( \" n \u2581 = \u2581 % d , \u2581 Position \u2581 % d \u2581 STRNEWLINE \" , n , pos ) ; return 0 ; }"}
{"text": "Find position of the only set bit | C program to find position of only set bit in a given number ; A utility function to check whether n is power of 2 or not ; Returns position of the only set bit in ' n ' ; One by one move the only set bit to right till it reaches end ; increment count of shifts ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; } int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned count = 0 ; while ( n ) { n = n >> 1 ; ++ count ; } return count ; } int main ( void ) { int n = 0 ; int pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n \u2581 = \u2581 % d , \u2581 Invalid \u2581 number STRNEWLINE \" , n ) : printf ( \" n \u2581 = \u2581 % d , \u2581 Position \u2581 % d \u2581 STRNEWLINE \" , n , pos ) ; n = 12 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n \u2581 = \u2581 % d , \u2581 Invalid \u2581 number STRNEWLINE \" , n ) : printf ( \" n \u2581 = \u2581 % d , \u2581 Position \u2581 % d \u2581 STRNEWLINE \" , n , pos ) ; n = 128 ; pos = findPosition ( n ) ; ( pos == -1 ) ? printf ( \" n \u2581 = \u2581 % d , \u2581 Invalid \u2581 number STRNEWLINE \" , n ) : printf ( \" n \u2581 = \u2581 % d , \u2581 Position \u2581 % d \u2581 STRNEWLINE \" , n , pos ) ; return 0 ; }"}
{"text": "How to swap two numbers without using a temporary variable ? | C Program to swap two numbers without using temporary variable ; Code to swap ' x ' and ' y ' x now becomes 50 ; y becomes 10 ; x becomes 5", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 10 , y = 5 ; x = x * y ; y = x / y ; x = x / y ; printf ( \" After \u2581 Swapping : \u2581 x \u2581 = \u2581 % d , \u2581 y \u2581 = \u2581 % d \" , x , y ) ; return 0 ; }"}
{"text": "How to swap two numbers without using a temporary variable ? | C code to swap using XOR ; Code to swap ' x ' ( 1010 ) and ' y ' ( 0101 ) x now becomes 15 ( 1111 ) ; y becomes 10 ( 1010 ) ; x becomes 5 ( 0101 )", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 10 , y = 5 ; x = x ^ y ; y = x ^ y ; x = x ^ y ; printf ( \" After \u2581 Swapping : \u2581 x \u2581 = \u2581 % d , \u2581 y \u2581 = \u2581 % d \" , x , y ) ; return 0 ; }"}
{"text": "How to swap two numbers without using a temporary variable ? | C program to implement the above approach ; Swap function ; Driver code", "code": "#include <stdio.h> NEW_LINE void swap ( int * xp , int * yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; * xp = * xp ^ * yp ; } int main ( ) { int x = 10 ; swap ( & x , & x ) ; printf ( \" After \u2581 swap ( & x , \u2581 & x ) : \u2581 x \u2581 = \u2581 % d \" , x ) ; return 0 ; }"}
{"text": "Replace every element with the greatest element on right side | C Program to replace every element with the greatest element on right side ; Function to replace every element with the next greatest element ; Initialize the next greatest element ; The next greatest element for the rightmost element is always - 1 ; Replace all other elements with the next greatest ; Store the current element ( needed later for updating the next greatest element ) ; Replace current element with the next greatest ; Update the greatest element , if needed ; A utility Function that prints an array ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE void nextGreatest ( int arr [ ] , int size ) { int max_from_right = arr [ size - 1 ] ; arr [ size - 1 ] = -1 ; for ( int i = size - 2 ; i >= 0 ; i -- ) { int temp = arr [ i ] ; arr [ i ] = max_from_right ; if ( max_from_right < temp ) max_from_right = temp ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nextGreatest ( arr , size ) ; printf ( \" The \u2581 modified \u2581 array \u2581 is : \u2581 STRNEWLINE \" ) ; printArray ( arr , size ) ; return ( 0 ) ; }"}
{"text": "Maximum difference between two elements such that larger element appears after the smaller number |  ; The function assumes that there are at least two elements in array . The function returns a negative value if the array is sorted in decreasing order . Returns 0 if elements are equal ; Driver program to test above function ; Function calling", "code": "#include <stdio.h> NEW_LINE int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_size ; i ++ ) { for ( j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; } int main ( ) { int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ; printf ( \" Maximum \u2581 difference \u2581 is \u2581 % d \" , maxDiff ( arr , 5 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find the maximum element in an array which is first increasing and then decreasing | C program to find maximum element ; function to find the maximum element ; Driver program to check above functions", "code": "#include <stdio.h> NEW_LINE int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; } int main ( ) { int arr [ ] = { 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The \u2581 maximum \u2581 element \u2581 is \u2581 % d \" , findMaximum ( arr , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find the maximum element in an array which is first increasing and then decreasing |  ; Base Case : Only one element is present in arr [ low . . high ] ; If there are two elements and first is greater then the first element is maximum ; If there are two elements and second is greater then the second element is maximum ; If we reach a point where arr [ mid ] is greater than both of its adjacent elements arr [ mid - 1 ] and arr [ mid + 1 ] , then arr [ mid ] is the maximum element ; If arr [ mid ] is greater than the next element and smaller than the previous element then maximum lies on left side of mid ; when arr [ mid ] is greater than arr [ mid - 1 ] and smaller than arr [ mid + 1 ] ; Driver program to check above functions", "code": "#include <stdio.h> NEW_LINE int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 50 , 10 , 9 , 7 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The \u2581 maximum \u2581 element \u2581 is \u2581 % d \" , findMaximum ( arr , 0 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Count smaller elements on right side |  ; initialize all the counts in countSmaller array as 0 ; Utility function that prints out an array on a line ; Driver program to test above functions", "code": "void constructLowerArray ( int * arr [ ] , int * countSmaller , int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ i ] ) countSmaller [ i ] ++ ; } } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 12 , 10 , 5 , 4 , 2 , 20 , 6 , 1 , 0 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * low = ( int * ) malloc ( sizeof ( int ) * n ) ; constructLowerArray ( arr , low , n ) ; printArray ( low , n ) ; return 0 ; }"}
{"text": "Count smaller elements on right side |  ; An AVL tree node ; size of the tree rooted with this node ; A utility function to get maximum of two integers ; A utility function to get height of the tree rooted with N ; A utility function to size of the tree of rooted with N ; A utility function to get maximum of two integers ; Helper function that allocates a new node with the given key and NULL left and right pointers . ; new node is initially added at leaf ; A utility function to right rotate subtree rooted with y ; Perform rotation ; Update heights ; Update sizes ; Return new root ; A utility function to left rotate subtree rooted with x ; Perform rotation ; Update heights ; Update sizes ; Return new root ; Get Balance factor of node N ; Inserts a new key to the tree rotted with node . Also , updates * count to contain count of smaller elements for the new key ; 1. Perform the normal BST rotation ; UPDATE COUNT OF SMALLER ELEMENTS FOR KEY ; 2. Update height and size of this ancestor node ; 3. Get the balance factor of this ancestor node to check whether this node became unbalanced ; Left Left Case ; Right Right Case ; Left Right Case ; Right Left Case ; return the ( unchanged ) node pointer ; The following function updates the countSmaller array to contain count of smaller elements on right side . ; initialize all the counts in countSmaller array as 0 ; Starting from rightmost element , insert all elements one by one in an AVL tree and get the count of smaller elements ; Utility function that prints out an array on a line ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int key ; struct node * left ; struct node * right ; int height ; int size ; } ; int max ( int a , int b ) ; int height ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> height ; } int size ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> size ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ; node -> height = 1 ; node -> size = 1 ; return ( node ) ; } struct node * rightRotate ( struct node * y ) { struct node * x = y -> left ; struct node * T2 = x -> right ; x -> right = y ; y -> left = T2 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; y -> size = size ( y -> left ) + size ( y -> right ) + 1 ; x -> size = size ( x -> left ) + size ( x -> right ) + 1 ; return x ; } struct node * leftRotate ( struct node * x ) { struct node * y = x -> right ; struct node * T2 = y -> left ; y -> left = x ; x -> right = T2 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; x -> size = size ( x -> left ) + size ( x -> right ) + 1 ; y -> size = size ( y -> left ) + size ( y -> right ) + 1 ; return y ; } int getBalance ( struct node * N ) { if ( N == NULL ) return 0 ; return height ( N -> left ) - height ( N -> right ) ; } struct node * insert ( struct node * node , int key , int * count ) { if ( node == NULL ) return ( newNode ( key ) ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key , count ) ; else { node -> right = insert ( node -> right , key , count ) ; * count = * count + size ( node -> left ) + 1 ; } node -> height = max ( height ( node -> left ) , height ( node -> right ) ) + 1 ; node -> size = size ( node -> left ) + size ( node -> right ) + 1 ; int balance = getBalance ( node ) ; if ( balance > 1 && key < node -> left -> key ) return rightRotate ( node ) ; if ( balance < -1 && key > node -> right -> key ) return leftRotate ( node ) ; if ( balance > 1 && key > node -> left -> key ) { node -> left = leftRotate ( node -> left ) ; return rightRotate ( node ) ; } if ( balance < -1 && key < node -> right -> key ) { node -> right = rightRotate ( node -> right ) ; return leftRotate ( node ) ; } return node ; } void constructLowerArray ( int arr [ ] , int countSmaller [ ] , int n ) { int i , j ; struct node * root = NULL ; for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { root = insert ( root , arr [ i ] , & countSmaller [ i ] ) ; } } void printArray ( int arr [ ] , int size ) { int i ; printf ( \" STRNEWLINE \" ) ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 10 , 6 , 15 , 20 , 30 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * low = ( int * ) malloc ( sizeof ( int ) * n ) ; constructLowerArray ( arr , low , n ) ; printf ( \" Following \u2581 is \u2581 the \u2581 constructed \u2581 smaller \u2581 count \u2581 array \" ) ; printArray ( low , n ) ; return 0 ; }"}
{"text": "Find the smallest positive number missing from an unsorted array | Set 1 | C program to find the smallest positive missing number ; Utility to swap to integers ; Utility function that puts all non - positive ( 0 and negative ) numbers on left side of arr [ ] and return count of such numbers ; increment count of non - positive integers ; Find the smallest positive missing number in an array that contains all positive integers ; Mark arr [ i ] as visited by making arr [ arr [ i ] - 1 ] negative . Note that 1 is subtracted because index start from 0 and positive numbers start from 1 ; Return the first index value at which is positive ; 1 is added because indexes start from 0 ; Find the smallest positive missing number in an array that contains both positive and negative integers ; First separate positive and negative numbers ; Shift the array and call findMissingPositive for positive part ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void swap ( int * a , int * b ) { int temp ; temp = * a ; * a = * b ; * b = temp ; } int segregate ( int arr [ ] , int size ) { int j = 0 , i ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] <= 0 ) { swap ( & arr [ i ] , & arr [ j ] ) ; j ++ ; } } return j ; } int findMissingPositive ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { if ( abs ( arr [ i ] ) - 1 < size && arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; } for ( i = 0 ; i < size ; i ++ ) if ( arr [ i ] > 0 ) return i + 1 ; return size + 1 ; } int findMissing ( int arr [ ] , int size ) { int shift = segregate ( arr , size ) ; return findMissingPositive ( arr + shift , size - shift ) ; } int main ( ) { int arr [ ] = { 0 , 10 , 2 , -10 , -20 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int missing = findMissing ( arr , arr_size ) ; printf ( \" The \u2581 smallest \u2581 positive \u2581 missing \u2581 number \u2581 is \u2581 % d \u2581 \" , missing ) ; getchar ( ) ; return 0 ; }"}
{"text": "Find the Missing Number |  ; getMissingNo takes array and size of array as arguments ; program to test above function", "code": "#include <stdio.h> NEW_LINE int getMissingNo ( int a [ ] , int n ) { int i , total ; total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; } int main ( ) { int a [ ] = { 1 , 2 , 4 , 5 , 6 } ; int miss = getMissingNo ( a , 5 ) ; printf ( \" % d \" , miss ) ; getchar ( ) ; }"}
{"text": "Find the repeating and the missing | Added 3 new methods | C program to Find the repeating and missing elements ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void printTwoElements ( int arr [ ] , int size ) { int i ; printf ( \" The repeating element is \" for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else printf ( \" \u2581 % d \u2581 \" , abs ( arr [ i ] ) ) ; } printf ( \" and the missing element is \" for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) printf ( \" % d \" , i + 1 ) ; } } int main ( ) { int arr [ ] = { 7 , 3 , 4 , 5 , 5 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoElements ( arr , n ) ; return 0 ; }"}
{"text": "Find the repeating and the missing | Added 3 new methods | C program to Find the repeating and missing elements ; The output of this function is stored at * x and * y ; Will hold xor of all elements and numbers from 1 to n ; Will have only single set bit of xor1 ; Get the xor of all array elements ; XOR the previous result with numbers from 1 to n ; Get the rightmost set bit in set_bit_no ; Now divide elements in two sets by comparing rightmost set bit of xor1 with bit at same position in each element . Also , get XORs of two sets . The two XORs are the output elements . The following two for loops serve the purpose ; arr [ i ] belongs to first set ; arr [ i ] belongs to second set ; i belongs to first set ; i belongs to second set ; * x and * y hold the desired output elements ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void getTwoElements ( int arr [ ] , int n , int * x , int * y ) { int xor1 ; int set_bit_no ; int i ; * x = 0 ; * y = 0 ; xor1 = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) xor1 = xor1 ^ arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor1 = xor1 ^ i ; set_bit_no = xor1 & ~ ( xor1 - 1 ) ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit_no ) * x = * x ^ arr [ i ] ; else * y = * y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) * x = * x ^ i ; else * y = * y ^ i ; } } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 , 6 , 2 } ; int * x = ( int * ) malloc ( sizeof ( int ) ) ; int * y = ( int * ) malloc ( sizeof ( int ) ) ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getTwoElements ( arr , n , x , y ) ; printf ( \" \u2581 The \u2581 missing \u2581 element \u2581 is \u2581 % d \" \" \u2581 and \u2581 the \u2581 repeating \u2581 number \" \" \u2581 is \u2581 % d \" , * x , * y ) ; getchar ( ) ; }"}
{"text": "Find four elements that sum to a given value | Set 1 ( n ^ 3 solution ) |  ; A naive solution to print all combination of 4 elements in A [ ] with sum equal to X ; Fix the first element and find other three ; Fix the second element and find other two ; Fix the third element and find the fourth ; find the fourth ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE void findFourElements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) printf ( \" % d , \u2581 % d , \u2581 % d , \u2581 % d \" , A [ i ] , A [ j ] , A [ k ] , A [ l ] ) ; } } } } int main ( ) { int A [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int X = 91 ; findFourElements ( A , n , X ) ; return 0 ; }"}
{"text": "Find four elements that sum to a given value | Set 2 | C program to find 4 elements with given sum ; The following structure is needed to store pair sums in aux [ ] ; index ( int A [ ] ) of first element in pair ; index of second element in pair ; sum of the pair ; Following function is needed for library function qsort ( ) ; Function to check if two given pairs have any common element or not ; The function finds four elements with given sum X ; Create an auxiliary array to store all pair sums ; Generate all possible pairs from A [ ] and store sums of all possible pairs in aux [ ] ; Sort the aux [ ] array using library function for sorting ; Now start two index variables from two corners of array and move them toward each other . ; Driver code ; Function call", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct pairSum { int first ; int sec ; int sum ; } ; int compare ( const void * a , const void * b ) { return ( ( * ( pairSum * ) a ) . sum - ( * ( pairSum * ) b ) . sum ) ; } bool noCommon ( struct pairSum a , struct pairSum b ) { if ( a . first == b . first a . first == b . sec a . sec == b . first a . sec == b . sec ) return false ; return true ; } void findFourElements ( int arr [ ] , int n , int X ) { int i , j ; int size = ( n * ( n - 1 ) ) / 2 ; struct pairSum aux [ size ] ; int k = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { aux [ k ] . sum = arr [ i ] + arr [ j ] ; aux [ k ] . first = i ; aux [ k ] . sec = j ; k ++ ; } } qsort ( aux , size , sizeof ( aux [ 0 ] ) , compare ) ; i = 0 ; j = size - 1 ; while ( i < size && j >= 0 ) { if ( ( aux [ i ] . sum + aux [ j ] . sum == X ) && noCommon ( aux [ i ] , aux [ j ] ) ) { printf ( \" % d , \u2581 % d , \u2581 % d , \u2581 % d STRNEWLINE \" , arr [ aux [ i ] . first ] , arr [ aux [ i ] . sec ] , arr [ aux [ j ] . first ] , arr [ aux [ j ] . sec ] ) ; return ; } else if ( aux [ i ] . sum + aux [ j ] . sum < X ) i ++ ; else j -- ; } } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 91 ; findFourElements ( arr , n , X ) ; return 0 ; }"}
{"text": "Minimum distance between two occurrences of maximum | C program to find Min distance of maximum element ; function to return min distance ; case a ; case b ; case c ; driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDistance ( int arr [ ] , int n ) { int maximum_element = arr [ 0 ] ; int min_dis = n ; int index = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( maximum_element == arr [ i ] ) { min_dis = min ( min_dis , ( i - index ) ) ; index = i ; } else if ( maximum_element < arr [ i ] ) { maximum_element = arr [ i ] ; min_dis = n ; index = i ; } else continue ; } return min_dis ; } int main ( ) { int arr [ ] = { 6 , 3 , 1 , 3 , 6 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Minimum \u2581 distance \u2581 = \u2581 \" << minDistance ( arr , n ) ; return 0 ; }"}
{"text": "Search an element in a Linked List ( Iterative and Recursive ) | Recursive C program to search an element in linked list ; Link list node ; Given a reference ( pointer to pointer ) to the head of a list and an int , push a new node on the front of the list . ; allocate node put in the key ; link the old list off the new node ; move the head to point to the new node ; Checks whether the value x is present in linked list ; Base case ; If key is present in current node , return true ; Recur for remaining list ; Driver program to test count function ; Start with the empty list ; Use push ( ) to construct below list 14 -> 21 -> 11 -> 30 -> 10", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE struct Node { int key ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_key ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> key = new_key ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } bool search ( struct Node * head , int x ) { if ( head == NULL ) return false ; if ( head -> key == x ) return true ; return search ( head -> next , x ) ; } int main ( ) { struct Node * head = NULL ; int x = 21 ; push ( & head , 10 ) ; push ( & head , 30 ) ; push ( & head , 11 ) ; push ( & head , 21 ) ; push ( & head , 14 ) ; search ( head , 21 ) ? printf ( \" Yes \" ) : printf ( \" No \" ) ; return 0 ; }"}
{"text": "Delete alternate nodes of a Linked List | deletes alternate nodes of a list starting with head ; Change the next link of head ; free memory allocated for node ; Recursively call for the new next of head", "code": "void deleteAlt ( struct Node * head ) { if ( head == NULL ) return ; struct Node * node = head -> next ; if ( node == NULL ) return ; head -> next = node -> next ; free ( node ) ; deleteAlt ( head -> next ) ; }"}
{"text": "Alternating split of a given Singly Linked List | Set 1 |  ; points to the last node in ' a ' ; points to the last node in ' b ' ; add at ' a ' tail ; advance the ' a ' tail", "code": "void AlternatingSplit ( struct Node * source , struct Node * * aRef , struct Node * * bRef ) { struct Node aDummy ; struct Node * aTail = & aDummy ; struct Node bDummy ; struct Node * bTail = & bDummy ; struct Node * current = source ; aDummy . next = NULL ; bDummy . next = NULL ; while ( current != NULL ) { MoveNode ( & ( aTail -> next ) , t ) ; aTail = aTail -> next ; if ( current != NULL ) { MoveNode ( & ( bTail -> next ) , t ) ; bTail = bTail -> next ; } } * aRef = aDummy . next ; * bRef = bDummy . next ; }"}
{"text": "Identical Linked Lists | An iterative C program to check if two linked lists are identical or not ; Structure for a linked list node ; Returns true if linked lists a and b are identical , otherwise false ; If we reach here , then a and b are not NULL and their data is same , so move to next nodes in both lists ; If linked lists are identical , then ' a ' and ' b ' must be NULL at this point . ; Given a reference ( pointer to pointer ) to the head of a list and an int , push a new node on the front of the list . ; allocate node put in the data ; link the old list off the new node ; move the head to point to the new node ; Driver program to test above function ; The constructed linked lists are : a : 3 -> 2 -> 1 b : 3 -> 2 -> 1", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; bool areIdentical ( struct Node * a , struct Node * b ) { while ( a != NULL && b != NULL ) { if ( a -> data != b -> data ) return false ; a = a -> next ; b = b -> next ; } return ( a == NULL && b == NULL ) ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * a = NULL ; struct Node * b = NULL ; push ( & a , 1 ) ; push ( & a , 2 ) ; push ( & a , 3 ) ; push ( & b , 1 ) ; push ( & b , 2 ) ; push ( & b , 3 ) ; areIdentical ( a , b ) ? printf ( \" Identical \" ) : printf ( \" Not \u2581 identical \" ) ; return 0 ; }"}
{"text": "Identical Linked Lists | A recursive C function to check if two linked lists are identical or not ; If both lists are empty ; If both lists are not empty , then data of current nodes must match , and same should be recursively true for rest of the nodes . ; If we reach here , then one of the lists is empty and other is not", "code": "bool areIdentical ( struct Node * a , struct Node * b ) { if ( a == NULL && b == NULL ) return true ; if ( a != NULL && b != NULL ) return ( a -> data == b -> data ) && areIdentical ( a -> next , b -> next ) ; return false ; }"}
{"text": "Sort a linked list of 0 s , 1 s and 2 s | C Program to sort a linked list 0 s , 1 s or 2 s ; Link list node ; Function to sort a linked list of 0 s , 1 s and 2 s ; Initialize count of '0' , '1' and '2' as 0 ; count total number of '0' , '1' and '2' * count [ 0 ] will store total number of '0' s * count [ 1 ] will store total number of '1' s * count [ 2 ] will store total number of '2' s ; Let say count [ 0 ] = n1 , count [ 1 ] = n2 and count [ 2 ] = n3 * now start traversing list from head node , * 1 ) fill the list with 0 , till n1 > 0 * 2 ) fill the list with 1 , till n2 > 0 * 3 ) fill the list with 2 , till n3 > 0 ; Function to push a node ; allocate node put in the data ; link the old list off the new node ; move the head to point to the new node ; Function to print linked list ; Driver program to test above function ; Constructed Linked List is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 8 -> 9 -> null", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void sortList ( struct Node * head ) { int count [ 3 ] = { 0 , 0 , 0 } ; struct Node * ptr = head ; while ( ptr != NULL ) { count [ ptr -> data ] += 1 ; ptr = ptr -> next ; } int i = 0 ; ptr = head ; while ( ptr != NULL ) { if ( count [ i ] == 0 ) ++ i ; else { ptr -> data = i ; -- count [ i ] ; ptr = ptr -> next ; } } } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * node ) { while ( node != NULL ) { printf ( \" % d \u2581 \" , node -> data ) ; node = node -> next ; } printf ( \" n \" ) ; } int main ( void ) { struct Node * head = NULL ; push ( & head , 0 ) ; push ( & head , 1 ) ; push ( & head , 0 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; printf ( \" Linked \u2581 List \u2581 Before \u2581 Sorting STRNEWLINE \" ) ; printList ( head ) ; sortList ( head ) ; printf ( \" Linked \u2581 List \u2581 After \u2581 Sorting STRNEWLINE \" ) ; printList ( head ) ; return 0 ; }"}
{"text": "Flatten a multilevel linked list |", "code": "struct List { int data ; struct List * next ; struct List * child ; } ;"}
{"text": "Rearrange a linked list such that all even and odd positioned nodes are together | C program to rearrange a linked list in such a way that all odd positioned node are stored before all even positioned nodes ; Linked List Node ; A utility function to create a new node ; Rearranges given linked list such that all even positioned nodes are before odd positioned . Returns new head of linked List . ; Corner case ; Initialize first nodes of even and odd lists ; Remember the first node of even list so that we can connect the even list at the end of odd list . ; If there are no more nodes , then connect first node of even list to the last node of odd list ; Connecting odd nodes ; If there are NO more even nodes after current odd . ; Connecting even nodes ; A utility function to print a linked list ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } Node * rearrangeEvenOdd ( Node * head ) { if ( head == NULL ) return NULL ; Node * odd = head ; Node * even = head -> next ; Node * evenFirst = even ; while ( 1 ) { if ( ! odd || ! even || ! ( even -> next ) ) { odd -> next = evenFirst ; break ; } odd -> next = even -> next ; odd = even -> next ; if ( odd -> next == NULL ) { even -> next = NULL ; odd -> next = evenFirst ; break ; } even -> next = odd -> next ; even = odd -> next ; } return head ; } void printlist ( Node * node ) { while ( node != NULL ) { cout << node -> data << \" - > \" ; node = node -> next ; } cout << \" NULL \" << endl ; } int main ( void ) { Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; cout << \" Given \u2581 Linked \u2581 List STRNEWLINE \" ; printlist ( head ) ; head = rearrangeEvenOdd ( head ) ; cout << \" Modified Linked List \" ; printlist ( head ) ; return 0 ; }"}
{"text": "Delete last occurrence of an item from linked list | A C program to demonstrate deletion of last Node in singly linked list ; A linked list Node ; Function to delete the last occurrence ; If found key , update ; If the last occurrence is the last node ; If it is not the last node ; Utility function to create a new node with given key ; This function prints contents of linked list starting from the given Node ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void deleteLast ( struct Node * head , int x ) { struct Node * temp = head , * ptr = NULL ; while ( temp ) { if ( temp -> data == x ) ptr = temp ; temp = temp -> next ; } if ( ptr != NULL && ptr -> next == NULL ) { temp = head ; while ( temp -> next != ptr ) temp = temp -> next ; temp -> next = NULL ; } if ( ptr != NULL && ptr -> next != NULL ) { ptr -> data = ptr -> next -> data ; temp = ptr -> next ; ptr -> next = ptr -> next -> next ; free ( temp ) ; } } struct Node * newNode ( int x ) { struct Node * node = malloc ( sizeof ( struct Node * ) ) ; node -> data = x ; node -> next = NULL ; return node ; } void display ( struct Node * head ) { struct Node * temp = head ; if ( head == NULL ) { printf ( \" NULL STRNEWLINE \" ) ; return ; } while ( temp != NULL ) { printf ( \" % d \u2581 - - > \u2581 \" , temp -> data ) ; temp = temp -> next ; } printf ( \" NULL STRNEWLINE \" ) ; } int main ( ) { struct Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; head -> next -> next -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next -> next -> next = newNode ( 4 ) ; printf ( \" Created \u2581 Linked \u2581 list : \u2581 \" ) ; display ( head ) ; deleteLast ( head , 4 ) ; printf ( \" List \u2581 after \u2581 deletion \u2581 of \u2581 4 : \u2581 \" ) ; display ( head ) ; return 0 ; }"}
{"text": "Check whether the length of given linked list is Even or Odd | C program to check length of a given linklist ; Defining structure ; Function to check the length of linklist ; Push function ; Allocating node ; Info into node ; Next of new node to head ; head points to new node ; Driver function ; Adding elements to Linked List ; Checking for length of linklist", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; int LinkedListLength ( struct Node * head ) { while ( head && head -> next ) { head = head -> next -> next ; } if ( ! head ) return 0 ; return 1 ; } void push ( struct Node * * head , int info ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = info ; node -> next = ( * head ) ; ( * head ) = node ; } int main ( void ) { struct Node * head = NULL ; push ( & head , 4 ) ; push ( & head , 5 ) ; push ( & head , 7 ) ; push ( & head , 2 ) ; push ( & head , 9 ) ; push ( & head , 6 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 0 ) ; push ( & head , 5 ) ; push ( & head , 5 ) ; int check = LinkedListLength ( head ) ; if ( check == 0 ) { printf ( \" Even STRNEWLINE \" ) ; } else { printf ( \" Odd STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "Merge two sorted linked lists |  ; point to the last result pointer ; tricky : advance to point to the next \" . next \" field", "code": "struct Node * SortedMerge ( struct Node * a , struct Node * b ) { struct Node * result = NULL ; struct Node * * lastPtrRef = & result ; while ( 1 ) { if ( a == NULL ) { * lastPtrRef = b ; break ; } else if ( b == NULL ) { * lastPtrRef = a ; break ; } if ( a -> data <= b -> data ) { MoveNode ( lastPtrRef , & a ) ; } else { MoveNode ( lastPtrRef , & b ) ; } lastPtrRef = & ( ( * lastPtrRef ) -> next ) ; } return ( result ) ; }"}
{"text": "Make middle node head in a linked list | C program to make middle node as head of linked list . ; Link list node ; Function to get the middle and set at beginning of the linked list ; To traverse list nodes one by one ; To traverse list nodes by skipping one . ; To keep track of previous of middle ; for previous node of middle node ; move one node each time ; move two node each time ; set middle node at head ; To insert a node at the beginning of linked list . ; allocate node ; link the old list off the new node ; move the head to point to the new node ; A function to print a given linked list ; Driver function ; Create a list of 5 nodes", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void setMiddleHead ( struct Node * * head ) { if ( * head == NULL ) return ; struct Node * one_node = ( * head ) ; struct Node * two_node = ( * head ) ; struct Node * prev = NULL ; while ( two_node != NULL && two_node -> next != NULL ) { prev = one_node ; two_node = two_node -> next -> next ; one_node = one_node -> next ; } prev -> next = prev -> next -> next ; one_node -> next = ( * head ) ; ( * head ) = one_node ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * ptr ) { while ( ptr != NULL ) { printf ( \" % d \u2581 \" , ptr -> data ) ; ptr = ptr -> next ; } printf ( \" STRNEWLINE \" ) ; } int main ( ) { struct Node * head = NULL ; int i ; for ( i = 5 ; i > 0 ; i -- ) push ( & head , i ) ; printf ( \" \u2581 list \u2581 before : \u2581 \" ) ; printList ( head ) ; setMiddleHead ( & head ) ; printf ( \" \u2581 list \u2581 After : \u2581 \" ) ; printList ( head ) ; return 0 ; }"}
{"text": "Doubly Linked List | Set 1 ( Introduction and Insertion ) | Given a node as prev_node , insert a new node after the given node ; 1. check if the given prev_node is NULL ; 2. allocate new node 3. put in the data ; 4. Make next of new node as next of prev_node ; 5. Make the next of prev_node as new_node ; 6. Make prev_node as previous of new_node ; 7. Change previous of new_node 's next node", "code": "void insertAfter ( struct Node * prev_node , int new_data ) { if ( prev_node == NULL ) { printf ( \" the \u2581 given \u2581 previous \u2581 node \u2581 cannot \u2581 be \u2581 NULL \" ) ; return ; } struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = prev_node -> next ; prev_node -> next = new_node ; new_node -> prev = prev_node ; if ( new_node -> next != NULL ) new_node -> next -> prev = new_node ; }"}
{"text": "XOR Linked List \u00e2 \u20ac\u201c A Memory Efficient Doubly Linked List | Set 2 | C Implementation of Memory efficient Doubly Linked List ; Node structure of a memory efficient doubly linked list ; XOR of next and previous node ; returns XORed value of the node addresses ; Insert a node at the beginning of the XORed linked list and makes the newly inserted node as head ; Allocate memory for new node ; Since new node is being inserted at the beginning , npx of new node will always be XOR of current head and NULL ; If linked list is not empty , then npx of current head node will be XOR of new node and node next to current head ; * ( head_ref ) -> npx is XOR of NULL and next . So if we do XOR of it with NULL , we get next ; Change head ; prints contents of doubly linked list in forward direction ; print current node ; get address of next node : curr -> npx is next ^ prev , so curr -> npx ^ prev will be next ^ prev ^ prev which is next ; update prev and curr for next iteration ; Driver program to test above functions ; Create following Doubly Linked List head -- > 40 < -- > 30 < -- > 20 < -- > 10 ; print the created list", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <inttypes.h> NEW_LINE struct Node { int data ; struct Node * npx ; } ; struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; } void insert ( struct Node * * head_ref , int data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = data ; new_node -> npx = * head_ref ; if ( * head_ref != NULL ) { ( * head_ref ) -> npx = XOR ( new_node , ( * head_ref ) -> npx ) ; } * head_ref = new_node ; } void printList ( struct Node * head ) { struct Node * curr = head ; struct Node * prev = NULL ; struct Node * next ; printf ( \" Following \u2581 are \u2581 the \u2581 nodes \u2581 of \u2581 Linked \u2581 List : \u2581 STRNEWLINE \" ) ; while ( curr != NULL ) { printf ( \" % d \u2581 \" , curr -> data ) ; next = XOR ( prev , curr -> npx ) ; prev = curr ; curr = next ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 10 ) ; insert ( & head , 20 ) ; insert ( & head , 30 ) ; insert ( & head , 40 ) ; printList ( head ) ; return ( 0 ) ; }"}
{"text": "Print nodes at k distance from root |  ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above functions ; Constructed binary tree is 1 / \\ 2 3 / \\ / 4 5 8", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; void printKDistant ( struct node * root , int k ) { if ( root == NULL k < 0 ) return ; if ( k == 0 ) { printf ( \" % d \u2581 \" , root -> data ) ; return ; } printKDistant ( root -> left , k - 1 ) ; printKDistant ( root -> right , k - 1 ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 8 ) ; printKDistant ( root , 2 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Print Binary Tree in 2 | Program to print binary tree in 2D ; A binary tree node ; Helper function to allocates a new node ; Function to print binary tree in 2D It does reverse inorder traversal ; Base case ; Increase distance between levels ; Process right child first ; Print current node after space count ; Process left child ; Wrapper over print2DUtil ( ) ; Pass initial space count as 0 ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <malloc.h> NEW_LINE #define COUNT  10 NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } void print2DUtil ( struct Node * root , int space ) { if ( root == NULL ) return ; space += COUNT ; print2DUtil ( root -> right , space ) ; printf ( \" STRNEWLINE \" ) ; for ( int i = COUNT ; i < space ; i ++ ) printf ( \" \u2581 \" ) ; printf ( \" % d STRNEWLINE \" , root -> data ) ; print2DUtil ( root -> left , space ) ; } void print2D ( struct Node * root ) { print2DUtil ( root , 0 ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> left -> left = newNode ( 12 ) ; root -> right -> left -> right = newNode ( 13 ) ; root -> right -> right -> left = newNode ( 14 ) ; root -> right -> right -> right = newNode ( 15 ) ; print2D ( root ) ; return 0 ; }"}
{"text": "Print Left View of a Binary Tree | C program to print left view of Binary Tree ; A utility function to create a new Binary Tree node ; Recursive function to print left view of a binary tree . ; Base Case ; If this is the first node of its level ; Recur for left and right subtrees ; A wrapper over leftViewUtil ( ) ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; } void leftViewUtil ( struct node * root , int level , int * max_level ) { if ( root == NULL ) return ; if ( * max_level < level ) { printf ( \" % d TABSYMBOL \" , root -> data ) ; * max_level = level ; } leftViewUtil ( root -> left , level + 1 , max_level ) ; leftViewUtil ( root -> right , level + 1 , max_level ) ; } void leftView ( struct node * root ) { int max_level = 0 ; leftViewUtil ( root , 1 , & max_level ) ; } int main ( ) { struct node * root = newNode ( 12 ) ; root -> left = newNode ( 10 ) ; root -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 25 ) ; root -> right -> right = newNode ( 40 ) ; leftView ( root ) ; return 0 ; }"}
{"text": "Count number of rotated strings which have more number of vowels in the first half than second half | C implementation of the approach ; Function to return the count of rotated strings which have more number of vowels in the first half than the second half ; Compute the number of vowels in first - half ; Compute the number of vowels in second - half ; Check if first - half has more vowels ; Check for all possible rotations ; Return the answer ; Driver code ; Function call", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int cntRotations ( char s [ ] , int n ) { int lh = 0 , rh = 0 , i , ans = 0 ; for ( i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { lh ++ ; } for ( i = n / 2 ; i < n ; ++ i ) if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { rh ++ ; } if ( lh > rh ) ans ++ ; for ( i = 1 ; i < n ; ++ i ) { if ( s [ i - 1 ] == ' a ' s [ i - 1 ] == ' e ' s [ i - 1 ] == ' i ' s [ i - 1 ] == ' o ' s [ i - 1 ] == ' u ' ) { rh ++ ; lh -- ; } if ( s [ ( i - 1 + n / 2 ) % n ] == ' a ' || s [ ( i - 1 + n / 2 ) % n ] == ' e ' || s [ ( i - 1 + n / 2 ) % n ] == ' i ' || s [ ( i - 1 + n / 2 ) % n ] == ' o ' || s [ ( i - 1 + n / 2 ) % n ] == ' u ' ) { rh -- ; lh ++ ; } if ( lh > rh ) ans ++ ; } return ans ; } int main ( ) { char s [ ] = \" abecidft \" ; int n = strlen ( s ) ; printf ( \" % d \" , cntRotations ( s , n ) ) ; return 0 ; }"}
{"text": "Rotate Linked List block wise | C program to rotate a linked list block wise ; Link list node ; Recursive function to rotate one block ; Rotate Clockwise ; Rotate anti - Clockwise ; Function to rotate the linked list block wise ; If length is 0 or 1 return head ; if degree of rotation is 0 , return head ; Traverse upto last element of this block ; storing the first node of next block ; If nodes of this block are less than k . Rotate this block also ; Append the new head of next block to the tail of this block ; return head of updated Linked List ; Function to push a node ; Function to print linked list ; Driver program to test above function ; Start with the empty list ; create a list 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> NULL ; k is block size and d is number of rotations in every block .", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; struct Node * rotateHelper ( struct Node * blockHead , struct Node * blockTail , int d , struct Node * * tail , int k ) { if ( d == 0 ) return blockHead ; if ( d > 0 ) { struct Node * temp = blockHead ; for ( int i = 1 ; temp -> next -> next && i < k - 1 ; i ++ ) temp = temp -> next ; blockTail -> next = blockHead ; * tail = temp ; return rotateHelper ( blockTail , temp , d - 1 , tail , k ) ; } if ( d < 0 ) { blockTail -> next = blockHead ; * tail = blockHead ; return rotateHelper ( blockHead -> next , blockHead , d + 1 , tail , k ) ; } } struct Node * rotateByBlocks ( struct Node * head , int k , int d ) { if ( ! head ! head -> next ) return head ; if ( d == 0 ) return head ; struct Node * temp = head , * tail = NULL ; int i ; for ( i = 1 ; temp -> next && i < k ; i ++ ) temp = temp -> next ; struct Node * nextBlock = temp -> next ; if ( i < k ) head = rotateHelper ( head , temp , d % k , & tail , i ) ; else head = rotateHelper ( head , temp , d % k , & tail , k ) ; tail -> next = rotateByBlocks ( nextBlock , k , d % k ) ; return head ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * node ) { while ( node != NULL ) { printf ( \" % d \u2581 \" , node -> data ) ; node = node -> next ; } } int main ( ) { struct Node * head = NULL ; for ( int i = 9 ; i > 0 ; i -= 1 ) push ( & head , i ) ; printf ( \" Given \u2581 linked \u2581 list \u2581 STRNEWLINE \" ) ; printList ( head ) ; int k = 3 , d = 2 ; head = rotateByBlocks ( head , k , d ) ; printf ( \" Rotated by blocks Linked list \" printList ( head ) ; return ( 0 ) ; }"}
{"text": "Deletion at different positions in a Circular Linked List | Function to delete First node of Circular Linked List ; check if list doesn 't have any node  if not then return ; check if list have single node if yes then delete it and return ; traverse second node to first ; now previous is last node and first node ( firstNode ) link address put in last node ( previous ) link ; make second node as head node", "code": "void DeleteFirst ( struct Node * * head ) { struct Node * previous = * head , * firstNode = * head ; if ( * head == NULL ) { printf ( \" List is empty \" return ; } if ( previous -> next == previous ) { * head = NULL ; return ; } while ( previous -> next != * head ) { previous = previous -> next ; } previous -> next = firstNode -> next ; * head = previous -> next ; free ( firstNode ) ; return ; }"}
{"text": "Deletion at different positions in a Circular Linked List | Function delete last node of Circular Linked List ; check if list doesn 't have any node  if not then return ; check if list have single node if yes then delete it and return ; move first node to last previous", "code": "void DeleteLast ( struct Node * * head ) { struct Node * current = * head , * temp = * head , * previous ; if ( * head == NULL ) { printf ( \" List is empty \" return ; } if ( current -> next == current ) { * head = NULL ; return ; } while ( current -> next != * head ) { previous = current ; current = current -> next ; } previous -> next = current -> next ; * head = previous -> next ; free ( current ) ; return ; }"}
{"text": "Efficient method to store a Lower Triangular Matrix using Column | C program for the above approach ; Dimensions of the matrix ; Structure of a memory efficient matrix ; Function to set the values in the Matrix ; Function to store the values in the Matrix ; Function to display the elements of the matrix ; Traverse the matrix ; Function to generate an efficient matrix ; Declare efficient Matrix ; Initialize the Matrix ; Set the values in matrix ; Return the matrix ; Driver Code ; Given Input ; Function call to create a memory efficient matrix ; Function call to print the Matrix", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE const int N = 5 ; struct Matrix { int * A ; int size ; } ; void Set ( struct Matrix * m , int i , int j , int x ) { if ( i >= j ) m -> A [ ( ( m -> size ) * ( j - 1 ) - ( ( ( j - 2 ) * ( j - 1 ) ) / 2 ) + ( i - j ) ) ] = x ; } int Get ( struct Matrix m , int i , int j ) { if ( i >= j ) return m . A [ ( ( m . size ) * ( j - 1 ) - ( ( ( j - 2 ) * ( j - 1 ) ) / 2 ) + ( i - j ) ) ] ; else return 0 ; } void Display ( struct Matrix m ) { for ( int i = 1 ; i <= m . size ; i ++ ) { for ( int j = 1 ; j <= m . size ; j ++ ) { if ( i >= j ) printf ( \" % d \u2581 \" , m . A [ ( ( m . size ) * ( j - 1 ) - ( ( ( j - 2 ) * ( j - 1 ) ) / 2 ) + ( i - j ) ) ] ) ; else printf ( \"0 \u2581 \" ) ; } printf ( \" STRNEWLINE \" ) ; } } struct Matrix createMat ( int Mat [ N ] [ N ] ) { struct Matrix mat ; mat . size = N ; mat . A = ( int * ) malloc ( mat . size * ( mat . size + 1 ) / 2 * sizeof ( int ) ) ; for ( int i = 1 ; i <= mat . size ; i ++ ) { for ( int j = 1 ; j <= mat . size ; j ++ ) { Set ( & mat , i , j , Mat [ i - 1 ] [ j - 1 ] ) ; } } return mat ; } int main ( ) { int Mat [ 5 ] [ 5 ] = { { 1 , 0 , 0 , 0 , 0 } , { 1 , 2 , 0 , 0 , 0 } , { 1 , 2 , 3 , 0 , 0 } , { 1 , 2 , 3 , 4 , 0 } , { 1 , 2 , 3 , 4 , 5 } } ; struct Matrix mat = createMat ( Mat ) ; Display ( mat ) ; return 0 ; }"}
{"text": "Count subarrays having sum of elements at even and odd positions equal | C program for the above approach ; Function to count subarrays in which sum of elements at even and odd positions are equal ; Initialize variables ; Iterate over the array ; Check if position is even then add to sum then add it to sum ; Else subtract it to sum ; Increment the count if the sum equals 0 ; Print the count of subarrays ; Driver Code ; Given array arr [ ] ; Size of the array ; Function call", "code": "#include <stdio.h> NEW_LINE void countSubarrays ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ; else sum -= arr [ j ] ; if ( sum == 0 ) count ++ ; } } printf ( \" % d \" , count ) ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarrays ( arr , n ) ; return 0 ; }"}
{"text": "Tail Recursion | An example of tail recursive function ; The last executed statement is recursive call", "code": "void print ( int n ) { if ( n < 0 ) return ; cout << \" \u2581 \" << n ; print ( n - 1 ) ; }"}
{"text": "Print alternate elements of an array | C program to implement the above approach ; Function to print Alternate elements of the given array ; Print elements at odd positions ; If currIndex stores even index or odd position ; Driver Code", "code": "#include <stdio.h> NEW_LINE void printAlter ( int arr [ ] , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { printf ( \" % d \u2581 \" , arr [ currIndex ] ) ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAlter ( arr , N ) ; }"}
{"text": "Shuffle 2 n integers as a1 | C program for the above approach ; Function to reverse the array from the position ' start ' to position ' end ' ; Stores mid of start and end ; Traverse the array in the range [ start , end ] ; Stores arr [ start + i ] ; Update arr [ start + i ] ; Update arr [ end - i ] ; Utility function to shuffle the given array in the of form { a1 , b1 , a2 , b2 , ... . an , bn } ; Stores the length of the array ; If length of the array is 2 ; Stores mid of the { start , end } ; Divide array into two halves of even length ; Update mid ; Calculate the mid - points of both halves of the array ; Reverse the subarray made from mid1 to mid2 ; Reverse the subarray made from mid1 to mid ; Reverse the subarray made from mid to mid2 ; Recursively calls for both the halves of the array ; Function to shuffle the given array in the form of { a1 , b1 , a2 , b2 , ... . an , bn } ; Function Call ; Print the modified array ; Driver Code ; Given array ; Size of the array ; Shuffles the given array to the required permutation", "code": "#include <stdio.h> NEW_LINE void reverse ( int arr [ ] , int start , int end ) { int mid = ( end - start + 1 ) / 2 ; for ( int i = 0 ; i < mid ; i ++ ) { int temp = arr [ start + i ] ; arr [ start + i ] = arr [ end - i ] ; arr [ end - i ] = temp ; } return ; } void shuffleArrayUtil ( int arr [ ] , int start , int end ) { int i ; int l = end - start + 1 ; if ( l == 2 ) return ; int mid = start + l / 2 ; if ( l % 4 ) { mid -= 1 ; } int mid1 = start + ( mid - start ) / 2 ; int mid2 = mid + ( end + 1 - mid ) / 2 ; reverse ( arr , mid1 , mid2 - 1 ) ; reverse ( arr , mid1 , mid - 1 ) ; reverse ( arr , mid , mid2 - 1 ) ; shuffleArrayUtil ( arr , start , mid - 1 ) ; shuffleArrayUtil ( arr , mid , end ) ; } void shuffleArray ( int arr [ ] , int N , int start , int end ) { shuffleArrayUtil ( arr , start , end ) ; for ( int i = 0 ; i < N ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 2 , 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; shuffleArray ( arr , N , 0 , N - 1 ) ; return 0 ; }"}
{"text": "Check if two arrays can be made equal by reversing subarrays multiple times | C implementation to check if two arrays can be made equal ; Function to check if array B can be made equal to array A ; Sort both arrays ; Check both arrays equal or not ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE int sort ( int a [ ] , int n ) { int i , j , tmp ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] < a [ i ] ) { tmp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tmp ; } } } return 0 ; } int canMadeEqual ( int A [ ] , int B [ ] , int n ) { int i ; sort ( A , n ) ; sort ( B , n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != B [ i ] ) { return ( 0 ) ; } } return ( 1 ) ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int n ; int B [ ] = { 1 , 3 , 2 } ; n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( canMadeEqual ( A , B , n ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } return 0 ; }"}
{"text": "Bubble Sort for Linked List by Swapping nodes | C program to sort Linked List using Bubble Sort by swapping nodes ; structure for a node ; Function to swap the nodes ; Function to sort the list ; update the link after swapping ; break if the loop ended without any swap ; Function to print the list ; Function to insert a struct Node at the beginning of a linked list ; Driver Code ; start with empty linked list ; Create linked list from the array arr [ ] ; print list before sorting ; sort the linked list ; print list after sorting", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } Node ; struct Node * swap ( struct Node * ptr1 , struct Node * ptr2 ) { struct Node * tmp = ptr2 -> next ; ptr2 -> next = ptr1 ; ptr1 -> next = tmp ; return ptr2 ; } int bubbleSort ( struct Node * * head , int count ) { struct Node * * h ; int i , j , swapped ; for ( i = 0 ; i <= count ; i ++ ) { h = head ; swapped = 0 ; for ( j = 0 ; j < count - i - 1 ; j ++ ) { struct Node * p1 = * h ; struct Node * p2 = p1 -> next ; if ( p1 -> data > p2 -> data ) { * h = swap ( p1 , p2 ) ; swapped = 1 ; } h = & ( * h ) -> next ; } if ( swapped == 0 ) break ; } } void printList ( struct Node * n ) { while ( n != NULL ) { printf ( \" % d \u2581 - > \u2581 \" , n -> data ) ; n = n -> next ; } printf ( \" STRNEWLINE \" ) ; } void insertAtTheBegin ( struct Node * * start_ref , int data ) { struct Node * ptr1 = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; ptr1 -> data = data ; ptr1 -> next = * start_ref ; * start_ref = ptr1 ; } int main ( ) { int arr [ ] = { 78 , 20 , 10 , 32 , 1 , 5 } ; int list_size , i ; struct Node * start = NULL ; list_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( i = 0 ; i < list_size ; i ++ ) insertAtTheBegin ( & start , arr [ i ] ) ; printf ( \" Linked \u2581 list \u2581 before \u2581 sorting STRNEWLINE \" ) ; printList ( start ) ; bubbleSort ( & start , list_size ) ; printf ( \" Linked \u2581 list \u2581 after \u2581 sorting STRNEWLINE \" ) ; printList ( start ) ; return 0 ; }"}
{"text": "In | C ++ program in - place Merge Sort ; Merges two subarrays of arr [ ] . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ] Inplace Implementation ; If the direct merge is already sorted ; Two pointers to maintain start of both arrays to merge ; If element 1 is in right place ; Shift all the elements between element 1 element 2 , right by 1. ; Update all the pointers ; l is for left index and r is right index of the sub - array of arr to be sorted ; Same as ( l + r ) / 2 , but avoids overflow for large l and r ; Sort first and second halves ; Function to print an array ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE void merge ( int arr [ ] , int start , int mid , int end ) { int start2 = mid + 1 ; if ( arr [ mid ] <= arr [ start2 ] ) { return ; } while ( start <= mid && start2 <= end ) { if ( arr [ start ] <= arr [ start2 ] ) { start ++ ; } else { int value = arr [ start2 ] ; int index = start2 ; while ( index != start ) { arr [ index ] = arr [ index - 1 ] ; index -- ; } arr [ start ] = value ; start ++ ; mid ++ ; start2 ++ ; } } } void mergeSort ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } void printArray ( int A [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d \u2581 \" , A [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; mergeSort ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; return 0 ; }"}
{"text": "Dual pivot Quicksort | C program to implement dual pivot QuickSort ; lp means left pivot , and rp means right pivot . ; p is the left pivot , and q is the right pivot . ; if elements are less than the left pivot ; if elements are greater than or equal to the right pivot ; bring pivots to their appropriate positions . ; returning the indices of the pivots . * lp = j ; because we cannot return two elements from a function . ; Driver code", "code": "#include <stdio.h> NEW_LINE int partition ( int * arr , int low , int high , int * lp ) ; void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } void DualPivotQuickSort ( int * arr , int low , int high ) { if ( low < high ) { int lp , rp ; rp = partition ( arr , low , high , & lp ) ; DualPivotQuickSort ( arr , low , lp - 1 ) ; DualPivotQuickSort ( arr , lp + 1 , rp - 1 ) ; DualPivotQuickSort ( arr , rp + 1 , high ) ; } } int partition ( int * arr , int low , int high , int * lp ) { if ( arr [ low ] > arr [ high ] ) swap ( & arr [ low ] , & arr [ high ] ) ; int j = low + 1 ; int g = high - 1 , k = low + 1 , p = arr [ low ] , q = arr [ high ] ; while ( k <= g ) { if ( arr [ k ] < p ) { swap ( & arr [ k ] , & arr [ j ] ) ; j ++ ; } else if ( arr [ k ] >= q ) { while ( arr [ g ] > q && k < g ) g -- ; swap ( & arr [ k ] , & arr [ g ] ) ; g -- ; if ( arr [ k ] < p ) { swap ( & arr [ k ] , & arr [ j ] ) ; j ++ ; } } k ++ ; } j -- ; g ++ ; swap ( & arr [ low ] , & arr [ j ] ) ; swap ( & arr [ high ] , & arr [ g ] ) ; return g ; } int main ( ) { int arr [ ] = { 24 , 8 , 42 , 75 , 29 , 77 , 38 , 57 } ; DualPivotQuickSort ( arr , 0 , 7 ) ; printf ( \" Sorted \u2581 array : \u2581 \" ) ; for ( int i = 0 ; i < 8 ; i ++ ) printf ( \" % d \u2581 \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Construct a graph using N vertices whose shortest distance between K pair of vertices is 2 | C program to implement the above approach ; Function to construct the simple and connected graph such that the distance between exactly K pairs of vertices is 2 ; Stores maximum possible count of edges in a graph ; Base Case ; Stores count of edges in a graph ; Connect all vertices of pairs ( i , j ) ; Update ; Driver Code", "code": "#include <stdio.h> NEW_LINE void constGraphWithCon ( int N , int K ) { int Max = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; if ( K > Max ) { printf ( \" - 1\" ) ; return ; } int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { printf ( \" % d \u2581 % d STRNEWLINE \" , i , j ) ; count ++ ; if ( count == N * ( N - 1 ) / 2 - K ) break ; } if ( count == N * ( N - 1 ) / 2 - K ) break ; } } int main ( ) { int N = 5 , K = 3 ; constGraphWithCon ( N , K ) ; return 0 ; }"}
{"text": "Find N distinct numbers whose Bitwise XOR is equal to K | C program for the above approach ; Function to find N integers having Bitwise XOR equal to K ; Base Cases ; Assign values to P and Q ; Stores Bitwise XOR of the first ( N - 3 ) elements ; Print the first N - 3 elements ; Calculate Bitwise XOR of first ( N - 3 ) elements ; Driver Code ; Function Call", "code": "#include <stdio.h> NEW_LINE void findArray ( int N , int K ) { if ( N == 1 ) { printf ( \" % d \" , K ) ; return ; } if ( N == 2 ) { printf ( \" % d \u2581 % d \" , 0 , K ) ; return ; } int P = N - 2 ; int Q = N - 1 ; int VAL = 0 ; for ( int i = 1 ; i <= ( N - 3 ) ; i ++ ) { printf ( \" % d \u2581 \" , i ) ; VAL ^= i ; } if ( VAL == K ) { printf ( \" % d \u2581 % d \u2581 % d \" , P , Q , P ^ Q ) ; } else { printf ( \" % d \u2581 % d \u2581 % d \" , 0 , P , P ^ K ^ VAL ) ; } } int main ( ) { int N = 4 , X = 6 ; findArray ( N , X ) ; return 0 ; }"}
{"text": "Count of N digit Numbers whose sum of every K consecutive digits is equal | C program for the above approach ; Function to count the number of N - digit numbers such that sum of every k consecutive digits are equal ; Range of numbers ; Extract digits of the number ; Store the sum of first K digits ; Check for every k - consecutive digits ; If sum is not equal then break the loop ; Increment the count if it satisfy the given condition ; Driver code ; Given N and K ; Function call", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE int countDigitSum ( int N , int K ) { int l = ( int ) pow ( 10 , N - 1 ) , r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; int digits [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ; for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( int j = 1 ; j < N - K + 1 ; j ++ ) { int curr_sum = 0 ; for ( int m = j ; m < j + K ; m ++ ) curr_sum += digits [ m ] ; if ( sum != curr_sum ) { flag = 1 ; break ; } } if ( flag == 0 ) { count ++ ; } } return count ; } int main ( ) { int N = 2 , K = 1 ; printf ( \" % d \" , countDigitSum ( N , K ) ) ; return 0 ; }"}
{"text": "Convert string to integer without using any in | C program for the above approach ; Function to convert string to integer without using functions ; Initialize a variable ; Iterate till length of the string ; Subtract 48 from the current digit ; Print the answer ; Driver Code ; Given string of number ; Function Call", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void convert ( char s [ ] ) { int num = 0 ; int n = strlen ( s ) ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + ( s [ i ] - 48 ) ; printf ( \" % d \" , num ) ; } int main ( ) { char s [ ] = \"123\" ; convert ( s ) ; return 0 ; }"}
{"text": "Longest Arithmetic Progression | DP | The function returns true if there exist three elements in AP Assumption : set [ 0. . n - 1 ] is sorted . The code strictly implements the algorithm provided in the reference . ; One by fix every element as middle element ; Initialize i and k for the current j ; Find if there exist i and k that form AP with j as middle element", "code": "bool arithmeticThree ( int set [ ] , int n ) { for ( int j = 1 ; j < n - 1 ; j ++ ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] == 2 * set [ j ] ) return true ; ( set [ i ] + set [ k ] < 2 * set [ j ] ) ? k ++ : i -- ; } } return false ; }"}
{"text": "Maximum Sum Increasing Subsequence | DP | Dynamic Programming implementation of Maximum Sum Increasing Subsequence ( MSIS ) problem ; maxSumIS ( ) returns the maximum sum of increasing subsequence in arr [ ] of size n ; Initialize msis values for all indexes ; Compute maximum sum values in bottom up manner ; Pick maximum of all msis values ; Driver Code", "code": "#include <stdio.h> NEW_LINE int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; } int main ( ) { int arr [ ] = { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Sum \u2581 of \u2581 maximum \u2581 sum \u2581 increasing \u2581 \" \" subsequence \u2581 is \u2581 % d STRNEWLINE \" , maxSumIS ( arr , n ) ) ; return 0 ; }"}
{"text": "C / C ++ Program for Longest Increasing Subsequence | A Naive C recursive implementation of LIS problem ; To make use of recursive calls , this function must return two things : 1 ) Length of LIS ending with element arr [ n - 1 ] . We use max_ending_here for this purpose 2 ) Overall maximum as the LIS may end with an element before arr [ n - 1 ] max_ref is used this purpose . The value of LIS of full array of size n is stored in * max_ref which is our final result ; Base case ; ' max _ ending _ here ' is length of LIS ending with arr [ n - 1 ] ; Recursively get all LIS ending with arr [ 0 ] , arr [ 1 ] ... arr [ n - 2 ] . If arr [ i - 1 ] is smaller than arr [ n - 1 ] , and max ending with arr [ n - 1 ] needs to be updated , then update it ; Compare max_ending_here with the overall max . And update the overall max if needed ; Return length of LIS ending with arr [ n - 1 ] ; The wrapper function for _lis ( ) ; The max variable holds the result ; The function _lis ( ) stores its result in max ; returns max ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int _lis ( int arr [ ] , int n , int * max_ref ) { if ( n == 1 ) return 1 ; int res , max_ending_here = 1 ; for ( int i = 1 ; i < n ; i ++ ) { res = _lis ( arr , i , max_ref ) ; if ( arr [ i - 1 ] < arr [ n - 1 ] && res + 1 > max_ending_here ) max_ending_here = res + 1 ; } if ( * max_ref < max_ending_here ) * max_ref = max_ending_here ; return max_ending_here ; } int lis ( int arr [ ] , int n ) { int max = 1 ; _lis ( arr , n , & max ) ; return max ; } int main ( ) { int arr [ ] = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Length \u2581 of \u2581 lis \u2581 is \u2581 % d STRNEWLINE \" , lis ( arr , n ) ) ; return 0 ; }"}
{"text": "Overlapping Subproblems Property in Dynamic Programming | DP | a simple recursive program for Fibonacci numbers", "code": "int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }"}
{"text": "Count of number of given string in 2D character array | C code for finding count of string in a given 2D character array . ; utility function to search complete string from any given index of 2d char array ; through Backtrack searching in every directions ; Function to search the string in 2d array ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #include <stdlib.h> NEW_LINE #define ARRAY_SIZE ( a )  (sizeof(a) / sizeof(*a)) NEW_LINE int internalSearch ( char * needle , int row , int col , char * * hay , int row_max , int col_max ) { int found = 0 ; if ( row >= 0 && row <= row_max && col >= 0 && col <= col_max && * needle == hay [ row ] [ col ] ) { char match = * needle ++ ; hay [ row ] [ col ] = 0 ; if ( * needle == 0 ) { found = 1 ; } else { found += internalSearch ( needle , row , col + 1 , hay , row_max , col_max ) ; found += internalSearch ( needle , row , col - 1 , hay , row_max , col_max ) ; found += internalSearch ( needle , row + 1 , col , hay , row_max , col_max ) ; found += internalSearch ( needle , row - 1 , col , hay , row_max , col_max ) ; } hay [ row ] [ col ] = match ; } return found ; } int searchString ( char * needle , int row , int col , char * * str , int row_count , int col_count ) { int found = 0 ; int r , c ; for ( r = 0 ; r < row_count ; ++ r ) { for ( c = 0 ; c < col_count ; ++ c ) { found += internalSearch ( needle , r , c , str , row_count - 1 , col_count - 1 ) ; } } return found ; } int main ( void ) { char needle [ ] = \" MAGIC \" ; char * input [ ] = { \" BBABBM \" , \" CBMBBA \" , \" IBABBG \" , \" GOZBBI \" , \" ABBBBC \" , \" MCIGAM \" } ; char * str [ ARRAY_SIZE ( input ) ] ; int i ; for ( i = 0 ; i < ARRAY_SIZE ( input ) ; ++ i ) { str [ i ] = malloc ( strlen ( input [ i ] ) ) ; strcpy ( str [ i ] , input [ i ] ) ; } printf ( \" count : \u2581 % d STRNEWLINE \" , searchString ( needle , 0 , 0 , str , ARRAY_SIZE ( str ) , strlen ( str [ 0 ] ) ) ) ; return 0 ; }"}
{"text": "Check if given Parentheses expression is balanced or not | C program of the above approach ; Function to check if parentheses are balanced ; Initialising Variables ; Traversing the Expression ; It is a closing parenthesis ; This means there are more Closing parenthesis than opening ones ; If count is not zero , It means there are more opening parenthesis ; Driver code", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE bool isBalanced ( char exp [ ] ) { bool flag = true ; int count = 0 ; for ( int i = 0 ; exp [ i ] != ' \\0' ; i ++ ) { if ( exp [ i ] == ' ( ' ) { count ++ ; } else { count -- ; } if ( count < 0 ) { flag = false ; break ; } } if ( count != 0 ) { flag = false ; } return flag ; } int main ( ) { char exp1 [ ] = \" ( ( ( ) ) ) ( ) ( ) \" ; if ( isBalanced ( exp1 ) ) printf ( \" Balanced \u2581 STRNEWLINE \" ) ; else printf ( \" Not \u2581 Balanced \u2581 STRNEWLINE \" ) ; char exp2 [ ] = \" ( ) ) ( ( ( ) ) \" ; if ( isBalanced ( exp2 ) ) printf ( \" Balanced \u2581 STRNEWLINE \" ) ; else printf ( \" Not \u2581 Balanced \u2581 STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Shortest distance to every other character from given character | C implementation of above approach ; Function to return required vector of distances ; list to hold position of c in s ; length of string ; To hold size of list ; Iterate over string to create list ; max value of p2 ; Initialize the pointers ; Create result array ; Values at current pointers ; Current Index is before than p1 ; Current Index is between p1 and p2 ; Current Index is nearer to p1 ; Current Index is nearer to p2 ; Move pointer 1 step ahead ; Current index is after p2 ; Driver code", "code": "#include <stdio.h> NEW_LINE #define MAX_SIZE  100 NEW_LINE void shortestToChar ( char s [ ] , char c , int * res ) { int list [ MAX_SIZE ] ; int len = 0 ; int l = 0 ; while ( s [ len ] != ' \\0' ) { if ( s [ len ] == c ) { list [ l ] = len ; l ++ ; } len ++ ; } int p1 , p2 , v1 , v2 ; l = l - 1 ; p1 = 0 ; p2 = l > 0 ? 1 : 0 ; for ( int i = 0 ; i < len ; i ++ ) { v1 = list [ p1 ] ; v2 = list [ p2 ] ; if ( i <= v1 ) { res [ i ] = ( v1 - i ) ; } else if ( i <= v2 ) { if ( i - v1 < v2 - i ) { res [ i ] = ( i - v1 ) ; } else { res [ i ] = ( v2 - i ) ; p1 = p2 ; p2 = p2 < l ? ( p2 + 1 ) : p2 ; } } else { res [ i ] = ( i - v2 ) ; } } } int main ( ) { char s [ ] = \" geeksforgeeks \" ; char c = ' e ' ; int res [ MAX_SIZE ] ; shortestToChar ( s , c , res ) ; int i = 0 ; while ( s [ i ] != ' \\0' ) printf ( \" % d \u2581 \" , res [ i ++ ] ) ; return 0 ; }"}
{"text": "Reverse String according to the number of words | C program to reverse string according to the number of words ; Reverse the letters of the word ; Temporary variable to store character ; Swapping the first and last character ; This function forms the required string ; Checking the number of words present in string to reverse ; Reverse the letter of the words ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void reverse ( char str [ ] , int start , int end ) { char temp ; while ( start <= end ) { temp = str [ start ] ; str [ start ] = str [ end ] ; str [ end ] = temp ; start ++ ; end -- ; } } void reverseletter ( char str [ ] , int start , int end ) { int wstart , wend ; for ( wstart = wend = start ; wend < end ; wend ++ ) { if ( str [ wend ] == ' \u2581 ' ) continue ; while ( str [ wend ] != ' \u2581 ' && wend <= end ) wend ++ ; wend -- ; reverse ( str , wstart , wend ) ; } } int main ( ) { char str [ 1000 ] = \" Ashish \u2581 Yadav \u2581 Abhishek \u2581 Rajput \u2581 Sunil \u2581 Pundir \" ; reverseletter ( str , 0 , strlen ( str ) - 1 ) ; printf ( \" % s \" , str ) ; return 0 ; }"}
{"text": "Number of substrings with count of each character as k |", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; } bool have_same_frequency ( int freq [ ] , int k ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] != 0 && freq [ i ] != k ) { return false ; } } return true ; } int count_substrings ( char * s , int n , int k ) { int count = 0 ; int distinct = 0 ; bool have [ 26 ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) { have [ s [ i ] - ' a ' ] = true ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( have [ i ] ) { distinct ++ ; } } for ( int length = 1 ; length <= distinct ; length ++ ) { int window_length = length * k ; int freq [ 26 ] = { 0 } ; int window_start = 0 ; int window_end = window_start + window_length - 1 ; for ( int i = window_start ; i <= min ( window_end , n - 1 ) ; i ++ ) { freq [ s [ i ] - ' a ' ] ++ ; } while ( window_end < n ) { if ( have_same_frequency ( freq , k ) ) { count ++ ; } freq [ s [ window_start ] - ' a ' ] -- ; window_start ++ ; window_end ++ ; if ( window_end < n ) { freq [ s [ window_end ] - ' a ' ] ++ ; } } } return count ; } int main ( ) { char * s = \" aabbcc \" ; int k = 2 ; printf ( \" % d STRNEWLINE \" , count_substrings ( s , 6 , k ) ) ; s = \" aabbc \" ; k = 2 ; printf ( \" % d STRNEWLINE \" , count_substrings ( s , 5 , k ) ) ; return 0 ; }"}
{"text": "Toggle case of a string using Bitwise Operators | C program to get toggle case of a string ; tOGGLE cASE = swaps CAPS to lower case and lower case to CAPS ; Bitwise EXOR with 32 ; Driver Code", "code": "#include <stdio.h> NEW_LINE char * toggleCase ( char * a ) { for ( int i = 0 ; a [ i ] != ' \\0' ; i ++ ) { a [ i ] ^= 32 ; } return a ; } int main ( ) { char str [ ] = \" CheRrY \" ; printf ( \" Toggle \u2581 case : \u2581 % s STRNEWLINE \" , toggleCase ( str ) ) ; printf ( \" Original \u2581 string : \u2581 % s \" , toggleCase ( str ) ) ; return 0 ; }"}
{"text": "Write your own atoi ( ) |", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE int main ( ) { int val ; char strn1 [ ] = \"12546\" ; val = atoi ( strn1 ) ; printf ( \" String \u2581 value \u2581 = \u2581 % s STRNEWLINE \" , strn1 ) ; printf ( \" Integer \u2581 value \u2581 = \u2581 % d STRNEWLINE \" , val ) ; char strn2 [ ] = \" GeeksforGeeks \" ; val = atoi ( strn2 ) ; printf ( \" String \u2581 value \u2581 = \u2581 % s STRNEWLINE \" , strn2 ) ; printf ( \" Integer \u2581 value \u2581 = \u2581 % d STRNEWLINE \" , val ) ; return ( 0 ) ; }"}
{"text": "Write your own strcmp that ignores cases |  ; implementation of strcmp that ignores cases ; If characters are same or inverting the 6 th bit makes them same ; Compare the last ( or first mismatching in case of not same ) characters ; Set the 6 th bit in both , then compare ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int ic_strcmp ( char * s1 , char * s2 ) { int i ; for ( i = 0 ; s1 [ i ] && s2 [ i ] ; ++ i ) { if ( s1 [ i ] == s2 [ i ] || ( s1 [ i ] ^ 32 ) == s2 [ i ] ) continue ; else break ; } if ( s1 [ i ] == s2 [ i ] ) return 0 ; if ( ( s1 [ i ] 32 ) < ( s2 [ i ] 32 ) ) return -1 ; return 1 ; } int main ( void ) { printf ( \" ret : \u2581 % d STRNEWLINE \" , ic_strcmp ( \" Geeks \" , \" apple \" ) ) ; printf ( \" ret : \u2581 % d STRNEWLINE \" , ic_strcmp ( \" \" , \" ABCD \" ) ) ; printf ( \" ret : \u2581 % d STRNEWLINE \" , ic_strcmp ( \" ABCD \" , \" z \" ) ) ; printf ( \" ret : \u2581 % d STRNEWLINE \" , ic_strcmp ( \" ABCD \" , \" abcdEghe \" ) ) ; printf ( \" ret : \u2581 % d STRNEWLINE \" , ic_strcmp ( \" GeeksForGeeks \" , \" gEEksFORGeEKs \" ) ) ; printf ( \" ret : \u2581 % d STRNEWLINE \" , ic_strcmp ( \" GeeksForGeeks \" , \" geeksForGeeks \" ) ) ; return 0 ; }"}
{"text": "Check whether two strings are anagram of each other | C program to check if two strings are anagrams of each other ; function to check whether two strings are anagram of each other ; Create 2 count arrays and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; If both strings are of different length . Removing this condition will make the program fail for strings like \" aaca \" and \" aca \" ; Compare count arrays ; Driver code ; Function Call", "code": "#include <stdio.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE bool areAnagram ( char * str1 , char * str2 ) { int count1 [ NO_OF_CHARS ] = { 0 } ; int count2 [ NO_OF_CHARS ] = { 0 } ; int i ; for ( i = 0 ; str1 [ i ] && str2 [ i ] ; i ++ ) { count1 [ str1 [ i ] ] ++ ; count2 [ str2 [ i ] ] ++ ; } if ( str1 [ i ] str2 [ i ] ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; } int main ( ) { char str1 [ ] = \" geeksforgeeks \" ; char str2 [ ] = \" forgeeksgeeks \" ; if ( areAnagram ( str1 , str2 ) ) printf ( \" The \u2581 two \u2581 strings \u2581 are \u2581 anagram \u2581 of \u2581 each \u2581 other \" ) ; else printf ( \" The \u2581 two \u2581 strings \u2581 are \u2581 not \u2581 anagram \u2581 of \u2581 each \u2581 \" \" other \" ) ; return 0 ; }"}
{"text": "Heptacontagon Number | C program for above approach ; Finding the nth heptacontagon Number ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; } int main ( ) { int N = 3 ; printf ( \"3rd \u2581 heptacontagon \u2581 Number \u2581 is \u2581 = \u2581 % d \" , heptacontagonNum ( N ) ) ; return 0 ; }"}
{"text": "Compute maximum of two integers in C / C ++ using Bitwise Operators | C program for the above approach ; Function to find the largest number ; Perform the subtraction ; Right shift and Bitwise AND ; Find the maximum number ; Return the maximum value ; Driver Code ; Function Call", "code": "#include <stdio.h> NEW_LINE int findMax ( int a , int b ) { int z , i , max ; z = a - b ; i = ( z >> 31 ) & 1 ; max = a - ( i * z ) ; return max ; } int main ( ) { int A = 40 , B = 54 ; printf ( \" % d \" , findMax ( A , B ) ) ; return 0 ; }"}
{"text": "C / C ++ program for Armstrong Numbers | C program to find Armstrong number ; Function to calculate N raised to the power D ; Function to calculate the order of the number ; For each digit ; Function to check whether the given number is Armstrong number or not ; Calling order function ; For each digit ; If satisfies Armstrong condition ; Driver Code ; Given Number N ; Function Call", "code": "#include <stdio.h> NEW_LINE int power ( int N , unsigned int D ) { if ( D == 0 ) return 1 ; if ( D % 2 == 0 ) return power ( N , D / 2 ) * power ( N , D / 2 ) ; return N * power ( N , D / 2 ) * power ( N , D / 2 ) ; } int order ( int N ) { int r = 0 ; while ( N ) { r ++ ; N = N / 10 ; } return r ; } int isArmstrong ( int N ) { int D = order ( N ) ; int temp = N , sum = 0 ; while ( temp ) { int Ni = temp % 10 ; sum += power ( Ni , D ) ; temp = temp / 10 ; } if ( sum == N ) return 1 ; else return 0 ; } int main ( ) { int N = 153 ; if ( isArmstrong ( N ) == 1 ) printf ( \" True STRNEWLINE \" ) ; else printf ( \" False STRNEWLINE \" ) ; return 0 ; }"}
{"text": "C / C ++ Program to find Prime Numbers between given range | C program to find the prime numbers between a given interval ; Function for print prime number in given range ; Traverse each number in the interval with the help of for loop ; Skip 0 and 1 as they are neither prime nor composite ; flag variable to tell if i is prime or not ; Iterate to check if i is prime or not ; flag = 1 means i is prime and flag = 0 means i is not prime ; Driver Code ; Given Range ; Function Call", "code": "#include <stdio.h> NEW_LINE void primeInRange ( int L , int R ) { int i , j , flag ; for ( i = L ; i <= R ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) printf ( \" % d \u2581 \" , i ) ; } } int main ( ) { int L = 1 ; int R = 10 ; primeInRange ( L , R ) ; return 0 ; }"}
{"text": "Check whether count of odd and even factors of a number are equal | C code for the above approach ; Function to check condition ; Driver Code", "code": "#include <stdio.h> NEW_LINE #define lli  long long int NEW_LINE void isEqualFactors ( lli N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) printf ( \" YES STRNEWLINE \" ) ; else printf ( \" NO STRNEWLINE \" ) ; } int main ( ) { lli N = 10 ; isEqualFactors ( N ) ; N = 125 ; isEqualFactors ( N ) ; return 0 ; }"}
{"text": "Lynch | C implementation for the above approach ; Function to check the divisibility of the number by its digit . ; If the digit divides the number then return true else return false . ; Function to check if all digits of n divide it or not ; Taking the digit of the number into digit var . ; Function to check if N has all distinct digits ; Create an array of size 10 and initialize all elements as false . This array is used to check if a digit is already seen or not . ; Traverse through all digits of given number ; Find the last digit ; If digit is already seen , return false ; Mark this digit as seen ; Remove the last digit from number ; Function to check Lynch - Bell numbers ; Driver Code ; Given number N ; Function call", "code": "#include <stdio.h> NEW_LINE int checkDivisibility ( int n , int digit ) { return ( digit != 0 && n % digit == 0 ) ; } int isAllDigitsDivide ( int n ) { int temp = n ; while ( temp > 0 ) { int digit = temp % 10 ; if ( ! ( checkDivisibility ( n , digit ) ) ) return 0 ; temp /= 10 ; } return 1 ; } int isAllDigitsDistinct ( int n ) { int arr [ 10 ] , i , digit ; for ( i = 0 ; i < 10 ; i ++ ) arr [ i ] = 0 ; while ( n > 0 ) { digit = n % 10 ; if ( arr [ digit ] ) return 0 ; arr [ digit ] = 1 ; n = n / 10 ; } return 1 ; } int isLynchBell ( int n ) { return isAllDigitsDivide ( n ) && isAllDigitsDistinct ( n ) ; } int main ( ) { int N = 12 ; if ( isLynchBell ( N ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }"}
{"text": "Maximum Bitwise AND pair ( X , Y ) from given range such that X and Y can be same | C implementation to find the Maximum Bitwise AND pair ( X , Y ) from given range such that X and Y can be same ; Function to return the maximum bitwise AND ; Driver code", "code": "#include <stdio.h> NEW_LINE int maximumAND ( int L , int R ) { return R ; } int main ( ) { int l = 3 ; int r = 7 ; printf ( \" % d \" , maximumAND ( l , r ) ) ; return 0 ; }"}
{"text": "Average of Cubes of first N natural numbers | C program for the above approach ; Function to find average of cubes ; Store sum of cubes of numbers in the sum ; Calculate sum of cubes ; Return average ; Driver Code ; Given number ; Function Call", "code": "#include <stdio.h> NEW_LINE double findAverageOfCube ( int n ) { double sum = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; } int main ( ) { int n = 3 ; printf ( \" % lf \" , findAverageOfCube ( n ) ) ; return 0 ; }"}
{"text": "C / C ++ program to add N distances given in inch | C program for the above approach ; Struct defined for the inch - feet system ; Variable to store the inch - feet ; Function to find the sum of all N set of Inch Feet distances ; Variable to store sum ; Traverse the InchFeet array ; Find the total sum of feet and inch ; If inch sum is greater than 11 convert it into feet as 1 feet = 12 inch ; Find integral part of inch_sum ; Delete the integral part x ; Add x % 12 to inch_sum ; Add x / 12 to feet_sum ; Print the corresponding sum of feet_sum and inch_sum ; Driver Code ; Given set of inch - feet ; Function Call", "code": "#include \" stdio . h \" NEW_LINE struct InchFeet { int feet ; float inch ; } ; void findSum ( struct InchFeet arr [ ] , int N ) { int feet_sum = 0 ; float inch_sum = 0.0 ; int x ; for ( int i = 0 ; i < N ; i ++ ) { feet_sum += arr [ i ] . feet ; inch_sum += arr [ i ] . inch ; } if ( inch_sum >= 12 ) { x = ( int ) inch_sum ; inch_sum -= x ; inch_sum += x % 12 ; feet_sum += x / 12 ; } printf ( \" Feet \u2581 Sum : \u2581 % d STRNEWLINE \" , feet_sum ) ; printf ( \" Inch \u2581 Sum : \u2581 % .2f \" , inch_sum ) ; } int main ( ) { struct InchFeet arr [ ] = { { 10 , 3.7 } , { 10 , 5.5 } , { 6 , 8.0 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSum ( arr , N ) ; return 0 ; }"}
{"text": "Logarithm tricks for Competitive Programming | C implementation to check if the number is power of K ; Function to check if the number is power of K ; Logarithm function to calculate value ; Compare to the result1 or result2 both are equal ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE _Bool isPower ( int N , int K ) { int res1 = log ( N ) / log ( K ) ; double res2 = log ( N ) / log ( K ) ; return ( res1 == res2 ) ; } int main ( ) { int N = 8 ; int K = 2 ; if ( isPower ( N , K ) ) { printf ( \" Yes \" ) ; } else { printf ( \" No \" ) ; } return 0 ; }"}
{"text": "Program for finding the Integral of a given function using Boole 's Rule | C program to implement Boole 's Rule on the given function ; Function to return the value of f ( x ) for the given value of x ; Function to computes the integrand of y at the given intervals of x with step size h and the initial limit a and final limit b ; Number of intervals ; Computing the step size ; Substituing a = 0 , b = 4 and h = 1 ; Driver code", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE float y ( float x ) { return ( 1 / ( 1 + x ) ) ; } float BooleRule ( float a , float b ) { int n = 4 ; int h ; h = ( ( b - a ) / n ) ; float sum = 0 ; float bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ; sum = sum + bl ; return sum ; } int main ( ) { float lowlimit = 0 ; float upplimit = 4 ; printf ( \" f ( x ) \u2581 = \u2581 % .4f \" , BooleRule ( 0 , 4 ) ) ; return 0 ; }"}
{"text": "Finding Integreand using Weedle 's Rule | C program to Implement Weedle 's Rule ; A sample function f ( x ) = 1 / ( 1 + x ^ 2 ) ; Function to find the integral value of f ( x ) with step size h , with initial lower limit and upper limit a and b ; Find step size h ; To store the final sum ; Find sum using Weedle 's Formula ; Return the final sum ; Driver Code ; lower limit and upper limit ; Function Call", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE float y ( float x ) { float num = 1 ; float denom = 1.0 + x * x ; return num / denom ; } float WeedleRule ( float a , float b ) { double h = ( b - a ) / 6 ; float sum = 0 ; sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) ; return sum ; } int main ( ) { float a = 0 , b = 6 ; printf ( \" f ( x ) \u2581 = \u2581 % f \" , WeedleRule ( a , b ) ) ; return 0 ; }"}
{"text": "Runge | C program to implement Runge Kutta method ; A sample differential equation \" dy / dx \u2581 = \u2581 ( x \u2581 - \u2581 y ) /2\" ; Finds value of y for a given x using step size h and initial value y0 at x0 . ; Count number of iterations using step size or step height h ; Iterate for number of iterations ; Apply Runge Kutta Formulas to find next value of y ; Update next value of y ; Update next value of x ; Driver Code", "code": "#include <stdio.h> NEW_LINE float dydx ( float x , float y ) { return ( x + y - 2 ) ; } float rungeKutta ( float x0 , float y0 , float x , float h ) { int n = ( int ) ( ( x - x0 ) / h ) ; float k1 , k2 ; float y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; y = y + ( 1.0 / 6.0 ) * ( k1 + 2 * k2 ) ; x0 = x0 + h ; } return y ; } int main ( ) { float x0 = 0 , y = 1 , x = 2 , h = 0.2 ; printf ( \" y ( x ) \u2581 = \u2581 % f \" , rungeKutta ( x0 , y , x , h ) ) ; return 0 ; }"}
{"text": "Perimeter and Area of Varignon 's Parallelogram | C program to find the perimeter and area ; Function to find the perimeter ; Function to find the area ; Driver code", "code": "#include <stdio.h> NEW_LINE float per ( float a , float b ) { return ( a + b ) ; } float area ( float s ) { return ( s / 2 ) ; } int main ( ) { float a = 7 , b = 8 , s = 10 ; printf ( \" % f STRNEWLINE \" , per ( a , b ) ) ; printf ( \" % f \" , area ( s ) ) ; return 0 ; }"}
{"text": "Area of a leaf inside a square | C program to find the area of leaf inside a square ; Function to find area of leaf ; Driver code", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float area_leaf ( float a ) { return ( a * a * ( PI / 2 - 1 ) ) ; } int main ( ) { float a = 7 ; printf ( \" % f \" , area_leaf ( a ) ) ; return 0 ; }"}
{"text": "Length of rope tied around three equal circles touching each other | C program to find the length of rope ; Function to find the length of rope ; Driver code", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float length_rope ( float r ) { return ( ( 2 * PI * r ) + 6 * r ) ; } int main ( ) { float r = 7 ; printf ( \" % f \" , length_rope ( r ) ) ; return 0 ; }"}
{"text": "Area of Incircle of a Right Angled Triangle | C program to find the area of incircle of right angled triangle ; Function to find area of incircle ; Driver code", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float area_inscribed ( float P , float B , float H ) { return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) ; } int main ( ) { float P = 3 , B = 4 , H = 5 ; printf ( \" % f \" , area_inscribed ( P , B , H ) ) ; return 0 ; }"}
{"text": "Area of Circumcircle of a Right Angled Triangle | C program to find the area of Cicumscribed circle of right angled triangle ; Function to find area of circumscribed circle ; Driver code", "code": "#include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float area_circumscribed ( float c ) { return ( c * c * ( PI / 4 ) ) ; } int main ( ) { float c = 8 ; printf ( \" % f \" , area_circumscribed ( c ) ) ; return 0 ; }"}
{"text": "Program to calculate the Area and Perimeter of Incircle of an Equilateral Triangle | C program to find the area of Inscribed circle of equilateral triangle ; function to find area of inscribed circle ; function to find Perimeter of inscribed circle ; Driver code", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #define PI  3.14159265 NEW_LINE float area_inscribed ( float a ) { return ( a * a * ( PI / 12 ) ) ; } float perm_inscribed ( float a ) { return ( PI * ( a / sqrt ( 3 ) ) ) ; } int main ( ) { float a = 6 ; printf ( \" Area \u2581 of \u2581 inscribed \u2581 circle \u2581 is \u2581 : % f STRNEWLINE \" , area_inscribed ( a ) ) ; printf ( \" Perimeter \u2581 of \u2581 inscribed \u2581 circle \u2581 is \u2581 : % f \" , perm_inscribed ( a ) ) ; return 0 ; }"}
{"text": "Program to find the Area and Perimeter of a Semicircle | C program to find the Area and Perimeter of a Semicircle ; Function for calculating the area ; Formula for finding the area ; Function for calculating the perimeter ; Formula for finding the perimeter ; driver code ; Get the radius ; Find the area ; Find the perimeter", "code": "#include <stdio.h> NEW_LINE float area ( float r ) { return ( 0.5 ) * ( 3.14 ) * ( r * r ) ; } float perimeter ( float r ) { return ( 3.14 ) * ( r ) ; } int main ( ) { float r = 10 ; printf ( \" The \u2581 Area \u2581 of \u2581 Semicircle : \u2581 % f STRNEWLINE \" , area ( r ) ) ; printf ( \" The \u2581 Perimeter \u2581 of \u2581 Semicircle : \u2581 % f STRNEWLINE \" , perimeter ( r ) ) ; return 0 ; }"}
{"text": "Program to find equation of a plane passing through 3 points | C program to find equation of a plane passing through given 3 points . ; Function to find equation of plane . ; Driver Code", "code": "#include <stdio.h> NEW_LINE void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; printf ( \" equation \u2581 of \u2581 plane \u2581 is \u2581 % .2f \u2581 x \u2581 + \u2581 % .2f \" \" \u2581 y \u2581 + \u2581 % .2f \u2581 z \u2581 + \u2581 % .2f \u2581 = \u2581 0 . \" , a , b , c , d ) ; return ; } int main ( ) { float x1 = -1 ; float y1 = 2 ; float z1 = 1 ; float x2 = 0 ; float y2 = -3 ; float z2 = 2 ; float x3 = 1 ; float y3 = 1 ; float z3 = -4 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; return 0 ; }"}
{"text": "Perpendicular distance between a point and a Line in 2 D | C program to find the distance between a given point and a given line in 2 D . ; Function to find distance ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void shortest_distance ( float x1 , float y1 , float a , float b , float c ) { float d = fabs ( ( a * x1 + b * y1 + c ) ) / ( sqrt ( a * a + b * b ) ) ; printf ( \" Perpendicular \u2581 distance \u2581 is \u2581 % f STRNEWLINE \" , d ) ; return ; } int main ( ) { float x1 = 5 ; float y1 = 6 ; float a = -2 ; float b = 3 ; float c = 4 ; shortest_distance ( x1 , y1 , a , b , c ) ; return 0 ; }"}
{"text": "Program to determine the octant of the axial plane | C program to print octant of a given point . ; Function to print octant ; Driver Code", "code": "#include <stdio.h> NEW_LINE void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) printf ( \" Point \u2581 lies \u2581 in \u2581 1st \u2581 octant STRNEWLINE \" ) ; else if ( x < 0 && y >= 0 && z >= 0 ) printf ( \" Point \u2581 lies \u2581 in \u2581 2nd \u2581 octant STRNEWLINE \" ) ; else if ( x < 0 && y < 0 && z >= 0 ) printf ( \" Point \u2581 lies \u2581 in \u2581 3rd \u2581 octant STRNEWLINE \" ) ; else if ( x >= 0 && y < 0 && z >= 0 ) printf ( \" Point \u2581 lies \u2581 in \u2581 4th \u2581 octant STRNEWLINE \" ) ; else if ( x >= 0 && y >= 0 && z < 0 ) printf ( \" Point \u2581 lies \u2581 in \u2581 5th \u2581 octant STRNEWLINE \" ) ; else if ( x < 0 && y >= 0 && z < 0 ) printf ( \" Point \u2581 lies \u2581 in \u2581 6th \u2581 octant STRNEWLINE \" ) ; else if ( x < 0 && y < 0 && z < 0 ) printf ( \" Point \u2581 lies \u2581 in \u2581 7th \u2581 octant STRNEWLINE \" ) ; else if ( x >= 0 && y < 0 && z < 0 ) printf ( \" Point \u2581 lies \u2581 in \u2581 8th \u2581 octant STRNEWLINE \" ) ; } int main ( ) { float x = 2 , y = 3 , z = 4 ; octant ( x , y , z ) ; x = -4 , y = 2 , z = -8 ; octant ( x , y , z ) ; x = -6 , y = -2 , z = 8 ; octant ( x , y , z ) ; }"}
{"text": "Maximum area of quadrilateral | CPP program to find maximum are of a quadrilateral ; Calculating the semi - perimeter of the given quadrilateral ; Applying Brahmagupta 's formula to  get maximum area of quadrilateral ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; } int main ( ) { double a = 1 , b = 2 , c = 1 , d = 2 ; printf ( \" % .2f STRNEWLINE \" , maxArea ( a , b , c , d ) ) ; return 0 ; }"}
{"text": "Find Array obtained after adding terms of AP for Q queries | C program for the above approach ; Function to find array after performing the given query to the array elements ; Traverse the given query ; Traverse the given array ; Update the value of A [ i ] ; Update the value of curr ; Print the array elements ; Driver Code ; Function Call", "code": "#include <stdio.h> NEW_LINE void addAP ( int A [ ] , int Q , int operations [ 2 ] [ 4 ] ) { for ( int j = 0 ; j < 2 ; ++ j ) { int L = operations [ j ] [ 0 ] , R = operations [ j ] [ 1 ] , a = operations [ j ] [ 2 ] , d = operations [ j ] [ 3 ] ; int curr = a ; for ( int i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr ; curr += d ; } } for ( int i = 0 ; i < 4 ; ++ i ) printf ( \" % d \u2581 \" , A [ i ] ) ; } int main ( ) { int A [ ] = { 5 , 4 , 2 , 8 } ; int Q = 2 ; int Query [ 2 ] [ 4 ] = { { 1 , 2 , 1 , 3 } , { 1 , 4 , 4 , 1 } } ; addAP ( A , Q , Query ) ; return 0 ; }"}
{"text": "Estimating the value of Pi using Monte Carlo | Parallel Computing Method | C program for the above approach ; Function to find estimated value of PI using Monte Carlo algorithm ; Stores X and Y coordinates of a random point ; Stores distance of a random point from origin ; Stores number of points lying inside circle ; Stores number of points lying inside square ; Parallel calculation of random points lying inside a circle ; Initializes random points with a seed ; Finds random X co - ordinate ; Finds random X co - ordinate ; Finds the square of distance of point ( x , y ) from origin ; If d is less than or equal to 1 ; Increment pCircle by 1 ; Increment pSquare by 1 ; Stores the estimated value of PI ; Prints the value in pi ; Driver Code ; Input ; Function call", "code": "#include <omp.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <time.h> NEW_LINE void monteCarlo ( int N , int K ) { double x , y ; double d ; int pCircle = 0 ; int pSquare = 0 ; int i = 0 ; #pragma  omp parallel firstprivate(x, y, d, i) reduction(+ : pCircle, pSquare) num_threads(K) NEW_LINE { srand48 ( ( int ) time ( NULL ) ) ; for ( i = 0 ; i < N ; i ++ ) { x = ( double ) drand48 ( ) ; y = ( double ) drand48 ( ) ; d = ( ( x * x ) + ( y * y ) ) ; if ( d <= 1 ) { pCircle ++ ; } pSquare ++ ; } } double pi = 4.0 * ( ( double ) pCircle / ( double ) ( pSquare ) ) ; printf ( \" Final \u2581 Estimation \u2581 of \u2581 Pi \u2581 = \u2581 % f STRNEWLINE \" , pi ) ; } int main ( ) { int N = 100000 ; int K = 8 ; monteCarlo ( N , K ) ; }"}
{"text": "Efficient method to store a Lower Triangular Matrix using row | C program for the above approach ; Dimensions of a matrix ; Structure of the efficient matrix ; Function to set the values in the Matrix ; Function to store the values in the Matrix ; Function to display the elements of the matrix ; Traverse the matrix ; Function to generate an efficient matrix ; Declare efficient Matrix ; Initialize the Matrix ; Set the values in matrix ; Return the matrix ; Driver Code ; Stores the efficient matrix ; Print the Matrix", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE const int N = 5 ; struct Matrix { int * A ; int size ; } ; void Set ( struct Matrix * mat , int i , int j , int x ) { if ( i >= j ) mat -> A [ i * ( i - 1 ) / 2 + j - 1 ] = x ; } int Get ( struct Matrix mat , int i , int j ) { if ( i >= j ) { return mat . A [ i * ( i - 1 ) / 2 + j - 1 ] ; } else { return 0 ; } } void Display ( struct Matrix mat ) { int i , j ; for ( i = 1 ; i <= mat . size ; i ++ ) { for ( j = 1 ; j <= mat . size ; j ++ ) { if ( i >= j ) { printf ( \" % d \u2581 \" , mat . A [ i * ( i - 1 ) / 2 + j - 1 ] ) ; } else { printf ( \"0 \u2581 \" ) ; } } printf ( \" STRNEWLINE \" ) ; } } struct Matrix createMat ( int Mat [ N ] [ N ] ) { struct Matrix mat ; mat . size = N ; mat . A = ( int * ) malloc ( mat . size * ( mat . size + 1 ) / 2 * sizeof ( int ) ) ; int i , j ; for ( i = 1 ; i <= mat . size ; i ++ ) { for ( j = 1 ; j <= mat . size ; j ++ ) { Set ( & mat , i , j , Mat [ i - 1 ] [ j - 1 ] ) ; } } return mat ; } int main ( ) { int Mat [ 5 ] [ 5 ] = { { 1 , 0 , 0 , 0 , 0 } , { 1 , 2 , 0 , 0 , 0 } , { 1 , 2 , 3 , 0 , 0 } , { 1 , 2 , 3 , 4 , 0 } , { 1 , 2 , 3 , 4 , 5 } } ; struct Matrix mat = createMat ( Mat ) ; Display ( mat ) ; return 0 ; }"}
{"text": "Modulo Operator ( % ) in C / C ++ with Examples | Program to illustrate the working of the modulo operator ; To store two integer values ; To store the result of the modulo expression", "code": "#include <stdio.h> NEW_LINE int main ( void ) { int x , y ; int result ; x = -3 ; y = 4 ; result = x % y ; printf ( \" % d \" , result ) ; x = 4 ; y = -2 ; result = x % y ; printf ( \" % d \" , result ) ; x = -3 ; y = -4 ; result = x % y ; printf ( \" % d \" , result ) ; return 0 ; }"}
{"text": "Program to compute log a to any base b ( logb a ) | C program to find log ( a ) on any base b ; Driver code", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE int log_a_to_base_b ( int a , int b ) { return log ( a ) / log ( b ) ; } int main ( ) { int a = 3 ; int b = 2 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; a = 256 ; b = 4 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; return 0 ; }"}
{"text": "Program to compute log a to any base b ( logb a ) | C program to find log ( a ) on any base b using Recursion ; Recursive function to compute log a to the base b ; Driver code", "code": "#include <stdio.h> NEW_LINE int log_a_to_base_b ( int a , int b ) { return ( a > b - 1 ) ? 1 + log_a_to_base_b ( a / b , b ) : 0 ; } int main ( ) { int a = 3 ; int b = 2 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; a = 256 ; b = 4 ; printf ( \" % d STRNEWLINE \" , log_a_to_base_b ( a , b ) ) ; return 0 ; }"}
{"text": "Find Maximum and Minimum of two numbers using Absolute function | C program to find maximum and minimum using Absolute function ; Function to return maximum among the two numbers ; Function to return minimum among the two numbers ; Driver code ; Displaying the maximum value ; Displaying the minimum value", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int maximum ( int x , int y ) { return ( ( x + y + abs ( x - y ) ) / 2 ) ; } int minimum ( int x , int y ) { return ( ( x + y - abs ( x - y ) ) / 2 ) ; } void main ( ) { int x = 99 , y = 18 ; printf ( \" Maximum : \u2581 % d STRNEWLINE \" , maximum ( x , y ) ) ; printf ( \" Minimum : \u2581 % d STRNEWLINE \" , minimum ( x , y ) ) ; }"}
{"text": "Program to Calculate e ^ x by Recursion ( using Taylor Series ) | C implementation of the approach ; Recursive Function with static variables p and f ; Termination condition ; Recursive call ; Update the power of x ; Factorial ; Driver code", "code": "#include <stdio.h> NEW_LINE double e ( int x , int n ) { static double p = 1 , f = 1 ; double r ; if ( n == 0 ) return 1 ; r = e ( x , n - 1 ) ; p = p * x ; f = f * n ; return ( r + p / f ) ; } int main ( ) { int x = 4 , n = 15 ; printf ( \" % lf \u2581 STRNEWLINE \" , e ( x , n ) ) ; return 0 ; }"}
{"text": "Midpoint ellipse drawing algorithm | C program for implementing Mid - Point Ellipse Drawing Algorithm ; Initial decision parameter of region 1 ; For region 1 ; Print points based on 4 - way symmetry ; Checking and updating value of decision parameter based on algorithm ; Decision parameter of region 2 ; Plotting points of region 2 ; printing points based on 4 - way symmetry ; Checking and updating parameter value based on algorithm ; Driver code ; To draw a ellipse of major and minor radius 15 , 10 centred at ( 50 , 50 )", "code": "#include <stdio.h> NEW_LINE void midptellipse ( int rx , int ry , int xc , int yc ) { float dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ; d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25 * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ; while ( dx < dy ) { printf ( \" ( % f , \u2581 % f ) STRNEWLINE \" , x + xc , y + yc ) ; printf ( \" ( % f , \u2581 % f ) STRNEWLINE \" , - x + xc , y + yc ) ; printf ( \" ( % f , \u2581 % f ) STRNEWLINE \" , x + xc , - y + yc ) ; printf ( \" ( % f , \u2581 % f ) STRNEWLINE \" , - x + xc , - y + yc ) ; if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } } d2 = ( ( ry * ry ) * ( ( x + 0.5 ) * ( x + 0.5 ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ; while ( y >= 0 ) { printf ( \" ( % f , \u2581 % f ) STRNEWLINE \" , x + xc , y + yc ) ; printf ( \" ( % f , \u2581 % f ) STRNEWLINE \" , - x + xc , y + yc ) ; printf ( \" ( % f , \u2581 % f ) STRNEWLINE \" , x + xc , - y + yc ) ; printf ( \" ( % f , \u2581 % f ) STRNEWLINE \" , - x + xc , - y + yc ) ; if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } } int main ( ) { midptellipse ( 10 , 15 , 50 , 50 ) ; return 0 ; }"}
{"text": "Program to Convert Hexadecimal Number to Binary | C program to convert Hexadecimal number to Binary ; function to convert Hexadecimal to Binary Number ; driver code ; Get the Hexadecimal number ; Convert HexaDecimal to Binary", "code": "#include <stdio.h> NEW_LINE void HexToBin ( char * hexdec ) { long int i = 0 ; while ( hexdec [ i ] ) { switch ( hexdec [ i ] ) { case '0' : printf ( \"0000\" ) ; break ; case '1' : printf ( \"0001\" ) ; break ; case '2' : printf ( \"0010\" ) ; break ; case '3' : printf ( \"0011\" ) ; break ; case '4' : printf ( \"0100\" ) ; break ; case '5' : printf ( \"0101\" ) ; break ; case '6' : printf ( \"0110\" ) ; break ; case '7' : printf ( \"0111\" ) ; break ; case '8' : printf ( \"1000\" ) ; break ; case '9' : printf ( \"1001\" ) ; break ; case ' A ' : case ' a ' : printf ( \"1010\" ) ; break ; case ' B ' : case ' b ' : printf ( \"1011\" ) ; break ; case ' C ' : case ' c ' : printf ( \"1100\" ) ; break ; case ' D ' : case ' d ' : printf ( \"1101\" ) ; break ; case ' E ' : case ' e ' : printf ( \"1110\" ) ; break ; case ' F ' : case ' f ' : printf ( \"1111\" ) ; break ; default : printf ( \" Invalid hexadecimal digit % c \" , hexdec [ i ] ) ; } i ++ ; } } int main ( ) { char hexdec [ 100 ] = \"1AC5\" ; printf ( \" Equivalent Binary value is : \" HexToBin ( hexdec ) ; }"}
{"text": "How to access elements of a Square Matrix | C Program to read a square matrix and print the elements on secondary diagonal ; Get the square matrix ; Display the matrix ; Print the elements on secondary diagonal ; check for elements on secondary diagonal", "code": "#include <stdio.h> NEW_LINE int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } } printf ( \" The \u2581 matrix \u2581 is STRNEWLINE \" ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { printf ( \" % d TABSYMBOL \" , matrix [ row_index ] [ column_index ] ) ; } printf ( \" STRNEWLINE \" ) ; } printf ( \" Elements on Secondary diagonal : \" for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { if ( ( row_index + column_index ) == size - 1 ) printf ( \" % d , \u2581 \" , matrix [ row_index ] [ column_index ] ) ; } } return 0 ; }"}
{"text": "How to access elements of a Square Matrix | C Program to read a square matrix and print the elements above secondary diagonal ; Get the square matrix ; Display the matrix ; Print the elements above secondary diagonal ; check for elements above secondary diagonal", "code": "#include <stdio.h> NEW_LINE int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } } printf ( \" The \u2581 matrix \u2581 is STRNEWLINE \" ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { printf ( \" % d TABSYMBOL \" , matrix [ row_index ] [ column_index ] ) ; } printf ( \" STRNEWLINE \" ) ; } printf ( \" Elements above Secondary diagonal are : \" for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { if ( ( row_index + column_index ) < size - 1 ) printf ( \" % d , \u2581 \" , matrix [ row_index ] [ column_index ] ) ; } } return 0 ; }"}
{"text": "How to access elements of a Square Matrix | C Program to read a square matrix and print the Corner Elements ; Get the square matrix ; Display the matrix ; Print the Corner elements ; check for corner elements", "code": "#include <stdio.h> NEW_LINE int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } } printf ( \" The \u2581 matrix \u2581 is STRNEWLINE \" ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { printf ( \" % d TABSYMBOL \" , matrix [ row_index ] [ column_index ] ) ; } printf ( \" STRNEWLINE \" ) ; } printf ( \" Corner Elements are : \" for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { if ( ( row_index == 0 row_index == size - 1 ) && ( column_index == 0 column_index == size - 1 ) ) printf ( \" % d , \u2581 \" , matrix [ row_index ] [ column_index ] ) ; } } return 0 ; }"}
{"text": "Program to calculate distance between two points in 3 D | C program to find distance between two points in 3 D . ; function to print distance ; Driver Code ; function call for distance", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float d = sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) + pow ( z2 - z1 , 2 ) * 1.0 ) ; printf ( \" Distance \u2581 is \u2581 % f \" , d ) ; return ; } int main ( ) { float x1 = 2 ; float y1 = -5 ; float z1 = 7 ; float x2 = 3 ; float y2 = 4 ; float z2 = 5 ; distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ; return 0 ; }"}
{"text": "Find unique pairs such that each element is less than or equal to N | C program for finding the required pairs ; Finding the number of unique pairs ; Using the derived formula ; Printing the unique pairs ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int No_Of_Pairs ( int N ) { int i = 1 ; while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) i ++ ; return ( i - 1 ) ; } void print_pairs ( int pairs ) { int i = 1 , mul ; for ( i = 1 ; i <= pairs ; i ++ ) { mul = i * ( i + 1 ) ; printf ( \" Pair \u2581 no . \u2581 % d \u2581 - - > \u2581 ( % d , \u2581 % d ) STRNEWLINE \" , i , ( mul * i ) , mul * ( i + 1 ) ) ; } } int main ( ) { int N = 500 , pairs , mul , i = 1 ; pairs = No_Of_Pairs ( N ) ; printf ( \" No . \u2581 of \u2581 pairs \u2581 = \u2581 % d \u2581 STRNEWLINE \" , pairs ) ; print_pairs ( pairs ) ; return 0 ; }"}
{"text": "Divide a big number into two parts that differ by k | C program to Divide a Big Number into two parts ; Function to adds two Numbers represented as array of character . ; length of string ; initializing extra character position to 0 ; Adding each element of character and storing the carry . ; If remainder remains . ; Function to subtracts two numbers represented by string . ; Finding the length of the string . ; initializing extra character position to 0. ; Substrating each element of character . ; Function divides a number represented by character array a constant . ; Dividing each character element by constant . ; Function to reverses the character array . ; Reversing the array . ; Wrapper Function ; Reversing the character array . ; Adding the each element of both array and storing the sum in array a [ ] . ; Dividing the array a [ ] by 2. ; Reversing the character array to get output . ; Substracting each element of array i . e calculating a = a - b ; Reversing the character array to get output . ; Driven Program", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define MAX  100 NEW_LINE void add ( char v1 [ ] , char v2 [ ] ) { int i , d , c = 0 ; int l1 = strlen ( v1 ) ; int l2 = strlen ( v2 ) ; for ( i = l1 ; i < l2 ; i ++ ) v1 [ i ] = '0' ; for ( i = l2 ; i < l1 ; i ++ ) v2 [ i ] = '0' ; for ( i = 0 ; i < l1 i < l2 ; i ++ ) { d = ( v1 [ i ] - '0' ) + ( v2 [ i ] - '0' ) + c ; c = d / 10 ; d %= 10 ; v1 [ i ] = '0' + d ; } while ( c ) { v1 [ i ] = '0' + ( c % 10 ) ; c /= 10 ; i ++ ; } v1 [ i ] = ' \\0' ; v2 [ l2 ] = ' \\0' ; } void subs ( char v1 [ ] , char v2 [ ] ) { int i , d , c = 0 ; int l1 = strlen ( v1 ) ; int l2 = strlen ( v2 ) ; for ( i = l2 ; i < l1 ; i ++ ) v2 [ i ] = '0' ; for ( i = 0 ; i < l1 ; i ++ ) { d = ( v1 [ i ] - '0' - c ) - ( v2 [ i ] - '0' ) ; if ( d < 0 ) { d += 10 ; c = 1 ; } else c = 0 ; v1 [ i ] = '0' + d ; } v2 [ l2 ] = ' \\0' ; i = l1 - 1 ; while ( i > 0 && v1 [ i ] == '0' ) i -- ; v1 [ i + 1 ] = ' \\0' ; } int divi ( char v [ ] , int q ) { int i , l = strlen ( v ) ; int c = 0 , d ; for ( i = l - 1 ; i >= 0 ; i -- ) { d = c * 10 + ( v [ i ] - '0' ) ; c = d % q ; d /= q ; v [ i ] = '0' + d ; } i = l - 1 ; while ( i > 0 && v [ i ] == '0' ) i -- ; v [ i + 1 ] = ' \\0' ; return c ; } void rev ( char v [ ] ) { int l = strlen ( v ) ; int i ; char cc ; for ( i = 0 ; i < l - 1 - i ; i ++ ) { cc = v [ i ] ; v [ i ] = v [ l - 1 - i ] ; v [ l - i - 1 ] = cc ; } } void divideWithDiffK ( char a [ ] , char k [ ] ) { rev ( a ) ; rev ( k ) ; add ( a , k ) ; divi ( a , 2 ) ; rev ( a ) ; printf ( \" % s \u2581 \" , a ) ; rev ( a ) ; subs ( a , k ) ; rev ( a ) ; printf ( \" % s \" , a ) ; } int main ( ) { char a [ MAX ] = \"100\" , k [ MAX ] = \"20\" ; divideWithDiffK ( a , k ) ; return 0 ; }"}
{"text": "Area of a square from diagonal length | C Program to find the area of square when its diagonal is given . ; Returns area of square from given diagonal ; Driver function .", "code": "#include <stdio.h> NEW_LINE double findArea ( double d ) { return ( d * d ) / 2 ; } int main ( ) { double d = 10 ; printf ( \" % .2f \" , findArea ( d ) ) ; return 0 ; }"}
{"text": "Average of Squares of Natural Numbers | C program to calculate 1 ^ 2 + 2 ^ 2 + 3 ^ 2 + ... average of square number ; Function to calculate average of square number ; Driver code", "code": "#include <stdio.h> NEW_LINE float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; } int main ( ) { int n = 2 ; printf ( \" % f \" , AvgofSquareN ( n ) ) ; return 0 ; }"}
{"text": "Program to get the Sum of series : 1 | C program to get the sum of the series ; Function to get the series ; Sum of n - 1 terms starting from 2 nd term ; Driver Code", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE double Series ( double x , int n ) { double sum = 1 , term = 1 , fct , j , y = 2 , m ; int i ; for ( i = 1 ; i < n ; i ++ ) { fct = 1 ; for ( j = 1 ; j <= y ; j ++ ) { fct = fct * j ; } term = term * ( -1 ) ; m = term * pow ( x , y ) / fct ; sum = sum + m ; y += 2 ; } return sum ; } int main ( ) { double x = 9 ; int n = 10 ; printf ( \" % .4f \" , Series ( x , n ) ) ; return 0 ; }"}
{"text": "Find largest prime factor of a number | C Program to find largest prime factor of number ; A function to find largest prime factor ; Initialize the maximum prime factor variable with the lowest one ; Print the number of 2 s that divide n ; n >>= 1 ; equivalent to n /= 2 ; n must be odd at this point ; now we have to iterate only for integers who does not have prime factor 2 and 3 ; This condition is to handle the case when n is a prime number greater than 4 ; Driver program to test above function", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE long long maxPrimeFactors ( long long n ) { long long maxPrime = -1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; } while ( n % 3 == 0 ) { maxPrime = 3 ; n = n / 3 ; } for ( int i = 5 ; i <= sqrt ( n ) ; i += 6 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } while ( n % ( i + 2 ) == 0 ) { maxPrime = i + 2 ; n = n / ( i + 2 ) ; } } if ( n > 4 ) maxPrime = n ; return maxPrime ; } int main ( ) { long long n = 15 ; printf ( \" % lld STRNEWLINE \" , maxPrimeFactors ( n ) ) ; n = 25698751364526 ; printf ( \" % lld \" , maxPrimeFactors ( n ) ) ; return 0 ; }"}
{"text": "Sum of the Series 1 + x / 1 + x ^ 2 / 2 + x ^ 3 / 3 + . . + x ^ n / n | C program to find sum of series 1 + x ^ 2 / 2 + x ^ 3 / 3 + ... . + x ^ n / n ; C code to print the sum of the series ; Driver code", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; } int main ( ) { int x = 2 ; int n = 5 ; printf ( \" % .2f \" , sum ( x , n ) ) ; return 0 ; }"}
{"text": "Chiliagon Number | C program for above approach ; Finding the nth chiliagon Number ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd \u2581 chiliagon \u2581 Number \u2581 is \u2581 = \u2581 % d \" , chiliagonNum ( n ) ) ; return 0 ; }"}
{"text": "Pentacontagon number | C program for above approach ; Finding the nth pentacontagon Number ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd \u2581 pentacontagon \u2581 Number \u2581 is \u2581 = \u2581 % d \" , pentacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Array value by repeatedly replacing max 2 elements with their absolute difference | C ++ program to find the array value by repeatedly replacing max 2 elements with their absolute difference ; function that return last value of array ; Build a binary max_heap . ; For max 2 elements ; Iterate until queue is not empty ; if only 1 element is left ; return the last remaining value ; check that difference is non zero ; finally return 0 ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int lastElement ( vector < int > & arr ) { priority_queue < int > pq ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { pq . push ( arr [ i ] ) ; } int m1 , m2 ; while ( ! pq . empty ( ) ) { if ( pq . size ( ) == 1 ) return pq . top ( ) ; m1 = pq . top ( ) ; pq . pop ( ) ; m2 = pq . top ( ) ; pq . pop ( ) ; if ( m1 != m2 ) pq . push ( m1 - m2 ) ; } return 0 ; } int main ( ) { vector < int > arr = { 2 , 7 , 4 , 1 , 8 , 1 , 1 } ; cout << lastElement ( arr ) << endl ; return 0 ; }"}
{"text": "Logarithm tricks for Competitive Programming | C implementation count the number of digits in a number ; Function to count the number of digits in a number ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE int countDigit ( long long n ) { return ( floor ( log10 ( n ) + 1 ) ) ; } int main ( ) { double N = 80 ; printf ( \" % d \" , countDigit ( N ) ) ; return 0 ; }"}
{"text": "Program to find the sum of the series 1 + x + x ^ 2 + x ^ 3 + . . + x ^ n | C implementation to find the sum of series 1 + x ^ 2 + x ^ 3 + ... . + x ^ n ; Function to print the sum of the series ; First Term of series ; Loop to find the N terms of the series ; Driver Code", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; printf ( \"1 \u2581 \" ) ; for ( i = 1 ; i < n ; i ++ ) { total = total + multi ; printf ( \" % .1f \u2581 \" , multi ) ; multi = multi * x ; } printf ( \" STRNEWLINE \" ) ; return total ; } int main ( ) { int x = 2 ; int n = 5 ; printf ( \" % .2f \" , sum ( x , n ) ) ; return 0 ; }"}
{"text": "Find the remainder when N is divided by 4 using Bitwise AND operator | C implementation to find N modulo 4 using Bitwise AND operator ; Function to find the remainder ; Bitwise AND with 3 ; return x ; Driver code", "code": "#include <stdio.h> NEW_LINE int findRemainder ( int n ) { int x = n & 3 ; return x ; } int main ( ) { int N = 43 ; int ans = findRemainder ( N ) ; printf ( \" % d \" , ans ) ; return 0 ; }"}
{"text": "Program to print triangular number series till n | C Program to find Triangular Number Series ; Function to find triangular number ; For each iteration increase j by 1 and add it into k ; Increasing j by 1 ; Add value of j into k and update k ; Driven Function", "code": "#include <stdio.h> NEW_LINE void triangular_series ( int n ) { int i , j = 1 , k = 1 ; for ( i = 1 ; i <= n ; i ++ ) { printf ( \" \u2581 % d \u2581 \" , k ) ; j = j + 1 ; k = k + j ; } } int main ( ) { int n = 5 ; triangular_series ( n ) ; return 0 ; }"}
{"text": "Program to count digits in an integer ( 4 Different Methods ) | Recursive C program to count number of digits in a number ; Driver code", "code": "#include <stdio.h> NEW_LINE int countDigit ( long long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; } int main ( void ) { long long n = 345289467 ; printf ( \" Number \u2581 of \u2581 digits \u2581 : \u2581 % d \" , countDigit ( n ) ) ; return 0 ; }"}
{"text": "Check if a number is magic ( Recursive sum of digits is 1 ) | C program to check Whether the number is Magic or not . ; Accepting sample input ; Condition to check Magic number", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 1234 ; if ( x % 9 == 1 ) printf ( \" Magic \u2581 Number \" ) ; else printf ( \" Not \u2581 a \u2581 Magic \u2581 Number \" ) ; return 0 ; }"}
{"text": "Interesting facts about Fibonacci numbers | C program to demonstrate that Fibonacci numbers that are divisible by their indexes have indexes as either power of 5 or multiple of 12. ; storing Fibonacci numbers", "code": "#include <stdio.h> NEW_LINE #define MAX  100 NEW_LINE int main ( ) { long long int arr [ MAX ] ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] ; printf ( \" Fibonacci \u2581 numbers \u2581 divisible \u2581 by \u2581 \" \" their \u2581 indexes \u2581 are \u2581 : STRNEWLINE \" ) ; for ( int i = 1 ; i < MAX ; i ++ ) if ( arr [ i ] % i == 0 ) printf ( \" % d \u2581 \" , i ) ; }"}
{"text": "Maximum value of an integer for which factorial can be calculated on a machine | C program to find maximum value of an integer for which factorial can be calculated on your system ; when fact crosses its size , it gives negative value ; Driver Code", "code": "#include <stdio.h> NEW_LINE int findMaxValue ( ) { int res = 2 ; long long int fact = 2 ; while ( 1 ) { if ( fact < 0 ) break ; res ++ ; fact = fact * res ; } return res - 1 ; } int main ( ) { printf ( \" Maximum \u2581 value \u2581 of \u2581 integer \u2581 : \u2581 % d STRNEWLINE \" , findMaxValue ( ) ) ; return 0 ; }"}
{"text": "Given a number n , find the first k digits of n ^ n | C ++ program to generate first k digits of n ^ n ; function to calculate first k digits of n ^ n ; take log10 of n ^ n . log10 ( n ^ n ) = n * log10 ( n ) ; We now try to separate the decimal and integral part of the / product . The floor function returns the smallest integer less than or equal to the argument . So in this case , product - floor ( product ) will give us the decimal part of product ; we now exponentiate this back by raising 10 to the power of decimal part ; We now try to find the power of 10 by which we will have to multiply the decimal part to obtain our final answer ; driver function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long firstkdigits ( int n , int k ) { long double product = n * log10 ( n ) ; long double decimal_part = product - floor ( product ) ; decimal_part = pow ( 10 , decimal_part ) ; long long digits = pow ( 10 , k - 1 ) , i = 0 ; return decimal_part * digits ; } int main ( ) { int n = 1450 ; int k = 6 ; cout << firstkdigits ( n , k ) ; return 0 ; }"}
{"text": "Multiply large integers under large modulo | C program of finding modulo multiplication ; Returns ( a * b ) % mod ; Update a if it is more than or equal to mod ; If b is odd , add a with result ; Here we assume that doing 2 * a doesn 't cause overflow ; b >>= 1 ; b = b / 2 ; Driver program", "code": "#include <stdio.h> NEW_LINE long long moduloMultiplication ( long long a , long long b , long long mod ) { a %= mod ; while ( b ) { if ( b & 1 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; } return res ; } int main ( ) { long long a = 10123465234878998 ; long long b = 65746311545646431 ; long long m = 10005412336548794 ; printf ( \" % lld \" , moduloMultiplication ( a , b , m ) ) ; return 0 ; }"}
{"text": "Check if a number can be expressed as a sum of consecutive numbers |  ; Updating n with 2 n ; ( n & ( n - 1 ) ) = > Checking whether we can write 2 n as 2 ^ k if yes ( can 't represent 2n as 2^k) then answer 1  if no (can represent 2n as 2^k) then answer 0", "code": "#include <stdio.h> NEW_LINE long long int canBeSumofConsec ( long long int n ) { n = 2 * n ; return ( ( n & ( n - 1 ) ) != 0 ) ; } int main ( ) { long long int n = 10 ; printf ( \" % lld \" , canBeSumofConsec ( n ) ) ; }"}
{"text": "Combinatorial Game Theory | Set 2 ( Game of Nim ) | A C program to implement Game of Nim . The program assumes that both players are playing optimally ; A Structure to hold the two parameters of a move A move has two parameters - 1 ) pile_index = The index of pile from which stone is going to be removed 2 ) stones_removed = Number of stones removed from the pile indexed = pile_index ; A C function to output the current game state . ; A C function that returns True if game has ended and False if game is not yet over ; A C function to declare the winner of the game ; A C function to calculate the Nim - Sum at any point of the game . ; A C function to make moves of the Nim Game ; The player having the current turn is on a winning position . So he / she / it play optimally and tries to make Nim - Sum as 0 ; If this is not an illegal move then make this move . ; If you want to input yourself then remove the rand ( ) functions and modify the code to take inputs . But remember , you still won 't be able to change your  fate/prediction. ; Create an array to hold indices of non - empty piles ; A C function to play the Game of Nim ; Driver program to test above functions ; Test Case 1 ; We will predict the results before playing The COMPUTER starts first ; Let us play the game with COMPUTER starting first and check whether our prediction was right or not ; Test Case 2 int piles [ ] = { 3 , 4 , 7 } ; int n = sizeof ( piles ) / sizeof ( piles [ 0 ] ) ; We will predict the results before playing The HUMAN ( You ) starts first ; Let us play the game with COMPUTER starting first and check whether our prediction was right or not playGame ( piles , n , HUMAN ) ;", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <stdbool.h> NEW_LINE #define COMPUTER  1 NEW_LINE #define HUMAN  2 NEW_LINE struct move { int pile_index ; int stones_removed ; } ; void showPiles ( int piles [ ] , int n ) { int i ; printf ( \" Current \u2581 Game \u2581 Status \u2581 - > \u2581 \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d \u2581 \" , piles [ i ] ) ; printf ( \" STRNEWLINE \" ) ; return ; } bool gameOver ( int piles [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( piles [ i ] != 0 ) return ( false ) ; return ( true ) ; } void declareWinner ( int whoseTurn ) { if ( whoseTurn == COMPUTER ) printf ( \" HUMAN won \" else printf ( \" COMPUTER won \" return ; } int calculateNimSum ( int piles [ ] , int n ) { int i , nimsum = piles [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) nimsum = nimsum ^ piles [ i ] ; return ( nimsum ) ; } void makeMove ( int piles [ ] , int n , struct move * moves ) { int i , nim_sum = calculateNimSum ( piles , n ) ; if ( nim_sum != 0 ) { for ( i = 0 ; i < n ; i ++ ) { if ( ( piles [ i ] ^ nim_sum ) < piles [ i ] ) { ( * moves ) . pile_index = i ; ( * moves ) . stones_removed = piles [ i ] - ( piles [ i ] ^ nim_sum ) ; piles [ i ] = ( piles [ i ] ^ nim_sum ) ; break ; } } } else { int non_zero_indices [ n ] , count ; for ( i = 0 , count = 0 ; i < n ; i ++ ) if ( piles [ i ] > 0 ) non_zero_indices [ count ++ ] = i ; ( * moves ) . pile_index = ( rand ( ) % ( count ) ) ; ( * moves ) . stones_removed = 1 + ( rand ( ) % ( piles [ ( * moves ) . pile_index ] ) ) ; piles [ ( * moves ) . pile_index ] = piles [ ( * moves ) . pile_index ] - ( * moves ) . stones_removed ; if ( piles [ ( * moves ) . pile_index ] < 0 ) piles [ ( * moves ) . pile_index ] = 0 ; } return ; } void playGame ( int piles [ ] , int n , int whoseTurn ) { printf ( \" GAME STARTS \" struct move moves ; while ( gameOver ( piles , n ) == false ) { showPiles ( piles , n ) ; makeMove ( piles , n , & moves ) ; if ( whoseTurn == COMPUTER ) { printf ( \" COMPUTER \u2581 removes \u2581 % d \u2581 stones \u2581 from \u2581 pile \u2581 \" \" at \u2581 index \u2581 % d STRNEWLINE \" , moves . stones_removed , moves . pile_index ) ; whoseTurn = HUMAN ; } else { printf ( \" HUMAN \u2581 removes \u2581 % d \u2581 stones \u2581 from \u2581 pile \u2581 at \u2581 \" \" index \u2581 % d STRNEWLINE \" , moves . stones_removed , moves . pile_index ) ; whoseTurn = COMPUTER ; } } showPiles ( piles , n ) ; declareWinner ( whoseTurn ) ; return ; } void knowWinnerBeforePlaying ( int piles [ ] , int n , int whoseTurn ) { printf ( \" Prediction \u2581 before \u2581 playing \u2581 the \u2581 game \u2581 - > \u2581 \" ) ; if ( calculateNimSum ( piles , n ) != 0 ) { if ( whoseTurn == COMPUTER ) printf ( \" COMPUTER \u2581 will \u2581 win STRNEWLINE \" ) ; else printf ( \" HUMAN \u2581 will \u2581 win STRNEWLINE \" ) ; } else { if ( whoseTurn == COMPUTER ) printf ( \" HUMAN \u2581 will \u2581 win STRNEWLINE \" ) ; else printf ( \" COMPUTER \u2581 will \u2581 win STRNEWLINE \" ) ; } return ; } int main ( ) { int piles [ ] = { 3 , 4 , 5 } ; int n = sizeof ( piles ) / sizeof ( piles [ 0 ] ) ; knowWinnerBeforePlaying ( piles , n , COMPUTER ) ; playGame ( piles , n , COMPUTER ) ; knowWinnerBeforePlaying ( piles , n , COMPUTER ) ; return ( 0 ) ; }"}
{"text": "Program to find the Roots of Quadratic equation | C program to find roots of a quadratic equation ; Prints roots of quadratic equation ax * 2 + bx + x ; If a is 0 , then equation is not quadratic , but linear ; else d < 0 ; Driver code ; Function call", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void findRoots ( int a , int b , int c ) { if ( a == 0 ) { printf ( \" Invalid \" ) ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { printf ( \" Roots \u2581 are \u2581 real \u2581 and \u2581 different \u2581 STRNEWLINE \" ) ; printf ( \" % f % f \" , ( double ) ( - b + sqrt_val ) / ( 2 * a ) , ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ; } else if ( d == 0 ) { printf ( \" Roots \u2581 are \u2581 real \u2581 and \u2581 same \u2581 STRNEWLINE \" ) ; printf ( \" % f \" , - ( double ) b / ( 2 * a ) ) ; } { printf ( \" Roots \u2581 are \u2581 complex \u2581 STRNEWLINE \" ) ; printf ( \" % f \u2581 + \u2581 i % f % f - i % f \" , - ( double ) b / ( 2 * a ) , sqrt_val / ( 2 * a ) , - ( double ) b / ( 2 * a ) , sqrt_val / ( 2 * a ) ; } } int main ( ) { int a = 1 , b = -7 , c = 12 ; findRoots ( a , b , c ) ; return 0 ; }"}
{"text": "Convert from any base to decimal and vice versa | C program to convert a number from any base to decimal ; To return value of a char . For example , 2 is returned for '2' . 10 is returned for ' A ' , 11 for ' B ' ; Function to convert a number from given base ' b ' to decimal ; Initialize power of base ; Initialize result ; Decimal equivalent is str [ len - 1 ] * 1 + str [ len - 2 ] * base + str [ len - 3 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Driver code", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; } int toDeci ( char * str , int base ) { int len = strlen ( str ) ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { printf ( \" Invalid \u2581 Number \" ) ; return -1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; } int main ( ) { char str [ ] = \"11A \" ; int base = 16 ; printf ( \" Decimal \u2581 equivalent \u2581 of \u2581 % s \u2581 in \u2581 base \u2581 % d \u2581 is \u2581 \" \" \u2581 % d STRNEWLINE \" , str , base , toDeci ( str , base ) ) ; return 0 ; }"}
{"text": "Solving f ( n ) = ( 1 ) + ( 2 * 3 ) + ( 4 * 5 * 6 ) . . . n using Recursion | C Program to print the solution of the series f ( n ) = ( 1 ) + ( 2 * 3 ) + ( 4 * 5 * 6 ) . . . n using recursion ; Recursive function for finding sum of series calculated - number of terms till which sum of terms has been calculated current - number of terms for which sum has to becalculated N - Number of terms in the function to be calculated ; checking termination condition ; product of terms till current ; recursive call for adding terms next in the series ; Driver Code ; input number of terms in the series ; invoking the function to calculate the sum", "code": "#include <stdio.h> NEW_LINE int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; } int main ( ) { int N = 5 ; printf ( \" % d STRNEWLINE \" , seriesSum ( 1 , 1 , N ) ) ; return 0 ; }"}
{"text": "Fibonacci Coding | C program for Fibonacci Encoding of a positive integer n ; To limit on the largest Fibonacci number to be used ; Array to store fibonacci numbers . fib [ i ] is going to store ( i + 2 ) 'th Fibonacci number ; Stores values in fib and returns index of the largest fibonacci number smaller than n . ; Fib [ 0 ] stores 2 nd Fibonacci No . ; Fib [ 1 ] stores 3 rd Fibonacci No . ; Keep Generating remaining numbers while previously generated number is smaller ; Return index of the largest fibonacci number smaller than or equal to n . Note that the above loop stopped when fib [ i - 1 ] became larger . ; Returns pointer to the char string which corresponds to code for n ; allocate memory for codeword ; index of the largest Fibonacci f <= n ; Mark usage of Fibonacci f ( 1 bit ) ; Subtract f from n ; Move to Fibonacci just smaller than f ; Mark all Fibonacci > n as not used ( 0 bit ) , progress backwards ; additional '1' bit ; return pointer to codeword ; driver function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define N  30 NEW_LINE int fib [ N ] ; int largestFiboLessOrEqual ( int n ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; int i ; for ( i = 2 ; fib [ i - 1 ] <= n ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; return ( i - 2 ) ; } char * fibonacciEncoding ( int n ) { int index = largestFiboLessOrEqual ( n ) ; char * codeword = ( char * ) malloc ( sizeof ( char ) * ( index + 3 ) ) ; int i = index ; while ( n ) { codeword [ i ] = '1' ; n = n - fib [ i ] ; i = i - 1 ; while ( i >= 0 && fib [ i ] > n ) { codeword [ i ] = '0' ; i = i - 1 ; } } codeword [ index + 1 ] = '1' ; codeword [ index + 2 ] = ' \\0' ; return codeword ; } int main ( ) { int n = 143 ; printf ( \" Fibonacci \u2581 code \u2581 word \u2581 for \u2581 % d \u2581 is \u2581 % s STRNEWLINE \" , n , fibonacciEncoding ( n ) ) ; return 0 ; }"}
{"text": "Count number of squares in a rectangle | C program to count squares in a rectangle of size m x n ; Returns count of all squares in a rectangle of size m x n ; If n is smaller , swap m and n ; Now n is greater dimension , apply formula ; Driver Code", "code": "#include <stdio.h> NEW_LINE int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; } int main ( ) { int m = 4 , n = 3 ; printf ( \" Count \u2581 of \u2581 squares \u2581 is \u2581 % d \" , countSquares ( m , n ) ) ; }"}
{"text": "Segmented Sieve | This functions finds all primes smaller than ' limit ' using simple sieve of eratosthenes . ; Create a boolean array \" mark [ 0 . . limit - 1 ] \" and initialize all entries of it as true . A value in mark [ p ] will finally be false if ' p ' is Not a prime , else true . ; One by one traverse all numbers so that their multiples can be marked as composite . ; If p is not changed , then it is a prime ; Update all multiples of p ; Print all prime numbers and store them in prime", "code": "void simpleSieve ( int limit ) { bool mark [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) { mark [ i ] = true ; } for ( int p = 2 ; p * p < limit ; p ++ ) { if ( mark [ p ] == true ) { for ( int i = p * p ; i < limit ; i += p ) mark [ i ] = false ; } } for ( int p = 2 ; p < limit ; p ++ ) if ( mark [ p ] == true ) cout << p << \" \u2581 \" ; }"}
{"text": "Modular multiplicative inverse | Iterative C program to find modular inverse using extended Euclid algorithm ; Returns modulo inverse of a with respect to m using extended Euclid Algorithm Assumption : a and m are coprimes , i . e . , gcd ( a , m ) = 1 ; q is quotient ; m is remainder now , process same as Euclid 's algo ; Update y and x ; Make x positive ; Driver Code ; Function call", "code": "#include <stdio.h> NEW_LINE int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m , a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } int main ( ) { int a = 3 , m = 11 ; printf ( \" Modular \u2581 multiplicative \u2581 inverse \u2581 is \u2581 % d STRNEWLINE \" , modInverse ( a , m ) ) ; return 0 ; }"}
{"text": "Euler 's Totient Function | A simple C program to calculate Euler 's Totient Function ; Function to return gcd of a and b ; A simple method to evaluate Euler Totient Function ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int phi ( unsigned int n ) { unsigned int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; } int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) printf ( \" phi ( % d ) \u2581 = \u2581 % d STRNEWLINE \" , n , phi ( n ) ) ; return 0 ; }"}
{"text": "Euler 's Totient Function | C program to calculate Euler ' s \u2581 Totient \u2581 Function \u2581 using \u2581 Euler ' s product formula ; Consider all prime factors of n and for every prime factor p , multiply result with ( 1 - 1 / p ) ; Check if p is a prime factor . ; If yes , then update n and result ; If n has a prime factor greater than sqrt ( n ) ( There can be at - most one such prime factor ) ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int phi ( int n ) { for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; } int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) printf ( \" phi ( % d ) \u2581 = \u2581 % d STRNEWLINE \" , n , phi ( n ) ) ; return 0 ; }"}
{"text": "Program to print first n Fibonacci Numbers | Set 1 | C program to print first n Fibonacci numbers ; Function to print first n Fibonacci Numbers ; Driver Code", "code": "#include <stdio.h> NEW_LINE void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; printf ( \" % d \u2581 \" , f1 ) ; for ( i = 1 ; i < n ; i ++ ) { printf ( \" % d \u2581 \" , f2 ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } } int main ( ) { printFibonacciNumbers ( 7 ) ; return 0 ; }"}
{"text": "Program to find LCM of two numbers | C program to find LCM of two numbers ; Recursive function to return gcd of a and b ; Function to return LCM of two numbers ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; } int main ( ) { int a = 15 , b = 20 ; printf ( \" LCM \u2581 of \u2581 % d \u2581 and \u2581 % d \u2581 is \u2581 % d \u2581 \" , a , b , lcm ( a , b ) ) ; return 0 ; }"}
{"text": "Program to convert a given number to words | C program to print a given number in words . The program handles numbers from 0 to 9999 ; A function that prints given number in words ; Base cases ; The first string is not used , it is to make array indexing simple ; The first string is not used , it is to make array indexing simple ; The first two string are not used , they are to make array indexing simple ; Used for debugging purpose only ; For single digit number ; Iterate while num is not ' \\0' ; Code path for first 2 digits ; tens_power [ len - 3 ] ) ; here len can be 3 or 4 ; Code path for last 2 digits ; Need to explicitly handle 10 - 19. Sum of the two digits is used as index of \" two _ digits \" array of strings ; Need to explicitely handle 20 ; Rest of the two digit numbers i . e . , 21 to 99 ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE void convert_to_words ( char * num ) { int len = strlen ( if ( len == 0 ) { fprintf ( stderr , \" empty \u2581 string STRNEWLINE \" ) ; return ; } if ( len > 4 ) { fprintf ( stderr , \" Length \u2581 more \u2581 than \u2581 4 \u2581 is \u2581 not \u2581 supported STRNEWLINE \" ) ; return ; } char * single_digits [ ] = { \" zero \" , \" one \" , \" two \" , \" three \" , \" four \" , \" five \" , \" six \" , \" seven \" , \" eight \" , \" nine \" } ; char * two_digits [ ] = { \" \" , \" ten \" , \" eleven \" , \" twelve \" , \" thirteen \" , \" fourteen \" , \" fifteen \" , \" sixteen \" , \" seventeen \" , \" eighteen \" , \" nineteen \" } ; char * tens_multiple [ ] = { \" \" , \" \" , \" twenty \" , \" thirty \" , \" forty \" , \" fifty \" , \" sixty \" , \" seventy \" , \" eighty \" , \" ninety \" } ; char * tens_power [ ] = { \" hundred \" , \" thousand \" } ; printf ( \" % s : \" , num ) ; if ( len == 1 ) { printf ( \" % s STRNEWLINE \" , single_digits [ * num - '0' ] ) ; return ; } while ( * num != ' \\0' ) { if ( len >= 3 ) { if ( * num - '0' != 0 ) { printf ( \" % s \u2581 \" , single_digits [ * num - '0' ] ) ; printf ( \" % s \u2581 \" , } -- len ; } else { if ( * num == '1' ) { int sum = * num - '0' + * ( num + 1 ) - '0' ; printf ( \" % s STRNEWLINE \" , two_digits [ sum ] ) ; return ; } else if ( * num == '2' && * ( num + 1 ) == '0' ) { printf ( \" twenty STRNEWLINE \" ) ; return ; } else { int i = * num - '0' ; printf ( \" % s \u2581 \" , i ? tens_multiple [ i ] : \" \" ) ; ++ num ; if ( * num != '0' ) printf ( \" % s \u2581 \" , single_digits [ * num - '0' ] ) ; } } ++ num ; } } int main ( void ) { convert_to_words ( \"9923\" ) ; convert_to_words ( \"523\" ) ; convert_to_words ( \"89\" ) ; convert_to_words ( \"8\" ) ; return 0 ; }"}
{"text": "To find sum of two numbers without using any operator |  ; Driver code", "code": "#include <stdio.h> NEW_LINE int add ( int x , int y ) { return printf ( \" % * c % * c \" , x , ' \u2581 ' , y , ' \u2581 ' ) ; } int main ( ) { printf ( \" Sum \u2581 = \u2581 % d \" , add ( 3 , 4 ) ) ; return 0 ; }"}
{"text": "Check if a number is multiple of 5 without using / and % operators | Assuming that integer takes 4 bytes , there can be maximum 10 digits in a integer ; Check the last character of string ; Driver Code", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE # define MAX  11 NEW_LINE bool isMultipleof5 ( int n ) { char str [ MAX ] ; int len = strlen ( str ) ; if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; } int main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) printf ( \" % d \u2581 is \u2581 multiple \u2581 of \u2581 5 STRNEWLINE \" , n ) ; else printf ( \" % d \u2581 is \u2581 not \u2581 a \u2581 multiple \u2581 of \u2581 5 STRNEWLINE \" , n ) ; return 0 ; }"}
{"text": "XOR Linked List | C program to implement the above approach ; Structure of a node in XOR linked list ; Stores data value of a node ; Stores XOR of previous pointer and next pointer ; Function to find the XOR of address of two nodes ; Function to insert a node with given value at given position ; If XOR linked list is empty ; Initialize a new Node ; Stores data value in the node ; Stores XOR of previous and next pointer ; Update pointer of head node ; If the XOR linked list is not empty ; Stores the address of current node ; Stores the address of previous node ; Initialize a new Node ; Update curr node address ; Update new node address ; Update head ; Update data value of current node ; Function to print elements of the XOR Linked List ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Traverse XOR linked list ; Print current node ; Forward traversal ; Update prev ; Update curr ; Reverse the linked list in group of K ; Stores head node ; If the XOR linked list is empty ; Stores count of nodes reversed in current group ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Reverse nodes in current group ; Forward traversal ; Update prev ; Update curr ; Update count ; Disconnect prev node from the next node ; Disconnect curr from previous node ; If the count of remaining nodes is less than K ; Update len ; Recursively process the next nodes ; Connect the head pointer with the prev ; Connect prev with the head ; Driver Code ; Create following XOR Linked List head -- > 7 < a > 6 < a > 8 < a > 11 < a > 3 < a > 1 < a > 2 < a > 0 ; Function Call ; Print the reversed list", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * nxp ; } ; struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; } struct Node * insert ( struct Node * * head , int value ) { if ( * head == NULL ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = value ; node -> nxp = XOR ( NULL , NULL ) ; * head = node ; } else { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ; node -> nxp = XOR ( NULL , curr ) ; * head = node ; node -> data = value ; } return * head ; } void printList ( struct Node * * head ) { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * next ; while ( curr != NULL ) { printf ( \" % d \u2581 \" , curr -> data ) ; next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; } } struct Node * RevInGrp ( struct Node * * head , int K , int len ) { struct Node * curr = * head ; if ( curr == NULL ) return NULL ; int count = 0 ; struct Node * prev = NULL ; struct Node * next ; while ( count < K && count < len ) { next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; count ++ ; } prev -> nxp = XOR ( NULL , XOR ( prev -> nxp , curr ) ) ; if ( curr != NULL ) curr -> nxp = XOR ( XOR ( curr -> nxp , prev ) , NULL ) ; if ( len < K ) { return prev ; } else { len -= K ; struct Node * dummy = RevInGrp ( & curr , K , len ) ; ( * head ) -> nxp = XOR ( XOR ( NULL , ( * head ) -> nxp ) , dummy ) ; if ( dummy != NULL ) dummy -> nxp = XOR ( XOR ( dummy -> nxp , NULL ) , * head ) ; return prev ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 0 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; insert ( & head , 3 ) ; insert ( & head , 11 ) ; insert ( & head , 8 ) ; insert ( & head , 6 ) ; insert ( & head , 7 ) ; head = RevInGrp ( & head , 3 , 8 ) ; printList ( & head ) ; return ( 0 ) ; }"}
{"text": "XOR Linked List | C program for the above approach ; Structure of a node in XOR linked list ; Stores data value of a node ; Stores XOR of previous pointer and next pointer ; Function to find the XOR of two nodes ; Function to insert a node with given value at beginning position ; If XOR linked list is empty ; Initialize a new Node ; Stores data value in the node ; Stores XOR of previous and next pointer ; Update pointer of head node ; If the XOR linked list is not empty ; Stores the address of current node ; Stores the address of previous node ; Initialize a new Node ; Update curr node address ; Update new node address ; Update head ; Update data value of current node ; Function to print elements of the XOR Linked List ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Traverse XOR linked list ; Print current node ; Forward traversal ; Update prev ; Update curr ; Function to reverse the XOR linked list ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Forward traversal ; Update prev ; Update curr ; Update the head pointer ; Driver Code ; Create following XOR Linked List head -- > 40 < -- > 30 < -- > 20 < -- > 10 ; Reverse the XOR Linked List to give head -- > 10 < -- > 20 < -- > 30 < -- > 40", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * nxp ; } ; struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; } struct Node * insert ( struct Node * * head , int value ) { if ( * head == NULL ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = value ; node -> nxp = XOR ( NULL , NULL ) ; * head = node ; } else { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ; node -> nxp = XOR ( NULL , curr ) ; * head = node ; node -> data = value ; } return * head ; } void printList ( struct Node * * head ) { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * next ; while ( curr != NULL ) { printf ( \" % d \u2581 \" , curr -> data ) ; next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; } printf ( \" STRNEWLINE \" ) ; } struct Node * reverse ( struct Node * * head ) { struct Node * curr = * head ; if ( curr == NULL ) return NULL ; else { struct Node * prev = NULL ; struct Node * next ; while ( XOR ( prev , curr -> nxp ) != NULL ) { next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; } * head = curr ; return * head ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 10 ) ; insert ( & head , 20 ) ; insert ( & head , 30 ) ; insert ( & head , 40 ) ; printf ( \" XOR \u2581 linked \u2581 list : \u2581 \" ) ; printList ( & head ) ; reverse ( & head ) ; printf ( \" Reversed \u2581 XOR \u2581 linked \u2581 list : \u2581 \" ) ; printList ( & head ) ; return ( 0 ) ; }"}
{"text": "XOR Linked List | C program to implement the above approach ; Structure of a node in XOR linked list ; Stores data value of a node ; Stores XOR of previous pointer and next pointer ; Function to find the XOR of two nodes ; Function to insert a node with given value at given position ; If XOR linked list is empty ; Initialize a new Node ; Stores data value in the node ; Stores XOR of previous and next pointer ; Update pointer of head node ; If the XOR linked list is not empty ; Stores the address of current node ; Stores the address of previous node ; Initialize a new Node ; Update curr node address ; Update new node address ; Update head ; Update data value of current node ; Function to print elements of the XOR Linked List ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Traverse XOR linked list ; Print current node ; Forward traversal ; Update prev ; Update curr ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Forward traversal ; Update prev ; Update curr ; Forward traversal ; Update prev ; Update curr ; Driver Code ; Create following XOR Linked List head -- > 7 a > 6 a > 8 a > 11 a > 3 a > 1 a > 2 a > 0", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * nxp ; } ; struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; } struct Node * insert ( struct Node * * head , int value ) { if ( * head == NULL ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = value ; node -> nxp = XOR ( NULL , NULL ) ; * head = node ; } else { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ; node -> nxp = XOR ( NULL , curr ) ; * head = node ; node -> data = value ; } return * head ; } void printList ( struct Node * * head ) { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * next ; while ( curr != NULL ) { printf ( \" % d \u2581 \" , curr -> data ) ; next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; } } struct Node * NthNode ( struct Node * * head , int N ) { int count = 0 ; struct Node * curr = * head ; struct Node * curr1 = * head ; struct Node * prev = NULL ; struct Node * prev1 = NULL ; struct Node * next ; struct Node * next1 ; while ( count < N && curr != NULL ) { next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; count ++ ; } if ( curr == NULL && count < N ) { printf ( \" Wrong \u2581 Input \" ) ; return ( uintptr_t ) 0 ; } else { while ( curr != NULL ) { next = XOR ( prev , curr -> nxp ) ; next1 = XOR ( prev1 , curr1 -> nxp ) ; prev = curr ; prev1 = curr1 ; curr = next ; curr1 = next1 ; } printf ( \" % d \" , curr1 -> data ) ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 0 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; insert ( & head , 3 ) ; insert ( & head , 11 ) ; insert ( & head , 8 ) ; insert ( & head , 6 ) ; insert ( & head , 7 ) ; NthNode ( & head , 3 ) ; return ( 0 ) ; }"}
{"text": "XOR Linked List | C program to implement the above approach ; Structure of a node in XOR linked list ; Stores data value of a node ; Stores XOR of previous pointer and next pointer ; Function to find the XOR of two nodes ; Function to insert a node with given value at given position ; If XOR linked list is empty ; Initialize a new Node ; Stores data value in the node ; Stores XOR of previous and next pointer ; Update pointer of head node ; If the XOR linked list is not empty ; Stores the address of current node ; Stores the address of previous node ; Initialize a new Node ; Update curr node address ; Update new node address ; Update head ; Update data value of current node ; Function to print the middle node ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Traverse XOR linked list ; Forward traversal ; Update prev ; Update curr ; If the length of the linked list is odd ; If the length of the linked list is even ; Driver Code ; Create following XOR Linked List head -- > 4 a > 7 a > 5", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * nxp ; } ; struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; } struct Node * insert ( struct Node * * head , int value ) { if ( * head == NULL ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = value ; node -> nxp = XOR ( NULL , NULL ) ; * head = node ; } else { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ; node -> nxp = XOR ( NULL , curr ) ; * head = node ; node -> data = value ; } return * head ; } int printMiddle ( struct Node * * head , int len ) { int count = 0 ; struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * next ; int middle = ( int ) len / 2 ; while ( count != middle ) { next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; count ++ ; } if ( len & 1 ) { printf ( \" % d \" , curr -> data ) ; } else { printf ( \" % d \u2581 % d \" , prev -> data , curr -> data ) ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 4 ) ; insert ( & head , 7 ) ; insert ( & head , 5 ) ; printMiddle ( & head , 3 ) ; return ( 0 ) ; }"}
{"text": "XOR Linked List | C ++ program to implement the above approach ; Structure of a node in XOR linked list ; Stores data value of a node ; Stores XOR of previous pointer and next pointer ; Function to find the XOR of two nodes ; Function to insert a node with given value at given position ; If XOR linked list is empty ; If given position is equal to 1 ; Initialize a new Node ; Stores data value in the node ; Stores XOR of previous and next pointer ; Update pointer of head node ; If required position was not found ; If the XOR linked list is not empty ; Stores position of a node in the XOR linked list ; Stores the address of current node ; Stores the address of previous node ; Stores the XOR of next node and previous node ; Traverse the XOR linked list ; Update prev ; Update curr ; Update next ; Update Pos ; If the position of the current node is equal to the given position ; Initialize a new Node ; Stores pointer to previous Node as ( prev ^ next ^ next ) = prev ; Stores XOR of prev and new node ; Connecting new node with next ; Update pointer of next ; Connect node with curr and next curr < -- node -- > next ; Insertion node at beginning ; Initialize a new Node ; Update curr node address ; Update new node address ; Update head ; Update data value of current node ; Function to print elements of the XOR Linked List ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Traverse XOR linked list ; Print current node ; Forward traversal ; Update prev ; Update curr ; Driver Code ; Create following XOR Linked List head -- > 20 < -- > 40 < -- > 10 < -- > 30 ; Print the new list", "code": "#include <inttypes.h> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * nxp ; } ; struct Node * XOR ( struct Node * a , struct Node * b ) { return ( struct Node * ) ( ( uintptr_t ) ( a ) ^ ( uintptr_t ) ( b ) ) ; } struct Node * insert ( struct Node * * head , int value , int position ) { if ( * head == NULL ) { if ( position == 1 ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = value ; node -> nxp = XOR ( NULL , NULL ) ; * head = node ; } else { printf ( \" Invalid \u2581 Position STRNEWLINE \" ) ; } } else { int Pos = 1 ; struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * next = XOR ( prev , curr -> nxp ) ; while ( next != NULL && Pos < position - 1 ) { prev = curr ; curr = next ; next = XOR ( prev , curr -> nxp ) ; Pos ++ ; } if ( Pos == position - 1 ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * temp = XOR ( curr -> nxp , next ) ; curr -> nxp = XOR ( temp , node ) ; if ( next != NULL ) { next -> nxp = XOR ( node , XOR ( next -> nxp , curr ) ) ; } node -> nxp = XOR ( curr , next ) ; node -> data = value ; } else if ( position == 1 ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; curr -> nxp = XOR ( node , XOR ( NULL , curr -> nxp ) ) ; node -> nxp = XOR ( NULL , curr ) ; * head = node ; node -> data = value ; } else { printf ( \" Invalid \u2581 Position STRNEWLINE \" ) ; } } return * head ; } void printList ( struct Node * * head ) { struct Node * curr = * head ; struct Node * prev = NULL ; struct Node * next ; while ( curr != NULL ) { printf ( \" % d \u2581 \" , curr -> data ) ; next = XOR ( prev , curr -> nxp ) ; prev = curr ; curr = next ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 10 , 1 ) ; insert ( & head , 20 , 1 ) ; insert ( & head , 30 , 3 ) ; insert ( & head , 40 , 2 ) ; printList ( & head ) ; return ( 0 ) ; }"}
{"text": "Program to toggle K | C program to toggle K - th bit of a number N ; Function to toggle the kth bit of n ; Driver code", "code": "#include <stdio.h> NEW_LINE int toggleBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; } int main ( ) { int n = 5 , k = 2 ; printf ( \" % d STRNEWLINE \" , toggleBit ( n , k ) ) ; return 0 ; }"}
{"text": "Program to clear K | C program to clear K - th bit of a number N ; Function to clear the kth bit of n ; Driver code", "code": "#include <stdio.h> NEW_LINE int clearBit ( int n , int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; } int main ( ) { int n = 5 , k = 1 ; printf ( \" % d STRNEWLINE \" , clearBit ( n , k ) ) ; return 0 ; }"}
{"text": "Left Shift and Right Shift Operators in C / C ++ | C ++ Program to demonstrate use of right shift operator ; a = 5 ( 00000101 ) , b = 9 ( 00001001 ) ; The result is 00000010 ; The result is 00000100", "code": "#include <stdio.h> NEW_LINE using namespace std ; int main ( ) { unsigned char a = 5 , b = 9 ; printf ( \" a > > 1 \u2581 = \u2581 % d STRNEWLINE \" , a >> 1 ) ; printf ( \" b > > 1 \u2581 = \u2581 % d STRNEWLINE \" , b >> 1 ) ; return 0 ; }"}
{"text": "Left Shift and Right Shift Operators in C / C ++ |  ; shift y by 61 bits left", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 19 ; unsigned long long y = 19 ; printf ( \" x \u2581 < < \u2581 1 \u2581 = \u2581 % d STRNEWLINE \" , x << 1 ) ; printf ( \" x \u2581 > > \u2581 1 \u2581 = \u2581 % d STRNEWLINE \" , x >> 1 ) ; printf ( \" y \u2581 < < \u2581 61 \u2581 = \u2581 % lld STRNEWLINE \" , y << 61 ) ; return 0 ; }"}
{"text": "Left Shift and Right Shift Operators in C / C ++ |", "code": "#include <stdio.h> NEW_LINE int main ( ) { int i = 3 ; printf ( \" pow ( 2 , \u2581 % d ) \u2581 = \u2581 % d STRNEWLINE \" , i , 1 << i ) ; i = 4 ; printf ( \" pow ( 2 , \u2581 % d ) \u2581 = \u2581 % d STRNEWLINE \" , i , 1 << i ) ; return 0 ; }"}
{"text": "Bitwise recursive addition of two integers | C program to do recursive addition of two integers ; If bitwise & is 0 , then there is not going to be any carry . Hence result of XOR is addition . ; Driver code", "code": "#include <stdio.h> NEW_LINE int add ( int x , int y ) { int keep = ( x & y ) << 1 ; int res = x ^ y ; if ( keep == 0 ) return res ; add ( keep , res ) ; } int main ( ) { printf ( \" % d \" , add ( 15 , 38 ) ) ; return 0 ; }"}
{"text": "Count total bits in a number | C program to find total bit in given number ; log function in base 2 take only integer part ; Driven program", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE unsigned countBits ( unsigned int number ) { return ( int ) log2 ( number ) + 1 ; } int main ( ) { unsigned int num = 65 ; printf ( \" % d STRNEWLINE \" , countBits ( num ) ) ; return 0 ; }"}
{"text": "Find the n | Efficient C program to find n - th palindrome ; Construct the nth binary palindrome with the given group number , aux_number and operation type ; No need to insert any bit in the middle ; Length of the final binary representation ; Fill first and last bit as 1 ; Start filling the a [ ] from middle , with the aux_num binary representation ; Get the auxiliary number 's ith bit and  fill around middle ; Insert bit 0 in the middle ; Length of the final binary representation ; Fill first and last bit as 1 ; Start filling the a [ ] from middle , with the aux_num binary representation ; Get the auxiliary number 's ith bit and fill  around middle ; else Insert bit 1 in the middle ; Length of the final binary representation ; Fill first and last bit as 1 ; Start filling the a [ ] from middle , with the aux_num binary representation ; Get the auxiliary number 's ith bit and fill  around middle ; Convert the number to decimal from binary ; Will return the nth binary palindrome number ; Add number of elements in all the groups , until the group of the nth number is found ; Total number of elements until this group ; Element 's offset position in the group ; Finding which bit to be placed in the middle and finding the number , which we will fill from the middle in both directions ; We need to fill this auxiliary number in binary form the middle in both directions ; op = 0 ; Need to Insert 0 at middle ; op = 1 ; Need to Insert 1 at middle ; Driver code ; Function Call", "code": "#include <stdio.h> NEW_LINE #define INT_SIZE  32 NEW_LINE int constructNthNumber ( int group_no , int aux_num , int op ) { int a [ INT_SIZE ] = { 0 } ; int num = 0 , len_f ; int i = 0 ; if ( op == 2 ) { len_f = 2 * group_no ; a [ len_f - 1 ] = a [ 0 ] = 1 ; while ( aux_num ) { a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ; while ( aux_num ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ; while ( aux_num ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; } int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ; while ( count_temp < n ) { group_no ++ ; count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; } group_offset = n - count_upto_group - 1 ; if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) { aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 ) else aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; } int main ( ) { int n = 9 ; printf ( \" % d \" , getNthNumber ( n ) ) ; return 0 ; }"}
{"text": "Toggle all the bits of a number except k | C program to toggle all bits except kth bit ; Returns a number with all bit toggled in n except k - th bit ; 1 ) Toggle k - th bit by doing n ^ ( 1 << k ) 2 ) Toggle all bits of the modified number ; Driver code", "code": "#include <stdio.h> NEW_LINE unsigned int toggleAllExceptK ( unsigned int n , unsigned int k ) { return ~ ( n ^ ( 1 << k ) ) ; } int main ( ) { unsigned int n = 4294967295 ; unsigned int k = 0 ; printf ( \" % u \" , toggleAllExceptK ( n , k ) ) ; return 0 ; }"}
{"text": "Operators in C | Set 2 ( Relational and Logical Operators ) | C program to demonstrate working of relational operators ; greater than example ; greater than equal to ; less than example ; lesser than equal to ; equal to ; not equal to", "code": "#include <stdio.h> NEW_LINE int main ( ) { int a = 10 , b = 4 ; if ( a > b ) printf ( \" a \u2581 is \u2581 greater \u2581 than \u2581 b STRNEWLINE \" ) ; else printf ( \" a \u2581 is \u2581 less \u2581 than \u2581 or \u2581 equal \u2581 to \u2581 b STRNEWLINE \" ) ; if ( a >= b ) printf ( \" a \u2581 is \u2581 greater \u2581 than \u2581 or \u2581 equal \u2581 to \u2581 b STRNEWLINE \" ) ; else printf ( \" a \u2581 is \u2581 lesser \u2581 than \u2581 b STRNEWLINE \" ) ; if ( a < b ) printf ( \" a \u2581 is \u2581 less \u2581 than \u2581 b STRNEWLINE \" ) ; else printf ( \" a \u2581 is \u2581 greater \u2581 than \u2581 or \u2581 equal \u2581 to \u2581 b STRNEWLINE \" ) ; if ( a <= b ) printf ( \" a \u2581 is \u2581 lesser \u2581 than \u2581 or \u2581 equal \u2581 to \u2581 b STRNEWLINE \" ) ; else printf ( \" a \u2581 is \u2581 greater \u2581 than \u2581 b STRNEWLINE \" ) ; if ( a == b ) printf ( \" a \u2581 is \u2581 equal \u2581 to \u2581 b STRNEWLINE \" ) ; else printf ( \" a \u2581 and \u2581 b \u2581 are \u2581 not \u2581 equal STRNEWLINE \" ) ; if ( a != b ) printf ( \" a \u2581 is \u2581 not \u2581 equal \u2581 to \u2581 b STRNEWLINE \" ) ; else printf ( \" a \u2581 is \u2581 equal \u2581 b STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Operators in C | Set 2 ( Relational and Logical Operators ) | C program to demonstrate working of logical operators ; logical AND example ; logical OR example ; logical NOT example", "code": "#include <stdio.h> NEW_LINE int main ( ) { int a = 10 , b = 4 , c = 10 , d = 20 ; if ( a > b && c == d ) printf ( \" a \u2581 is \u2581 greater \u2581 than \u2581 b \u2581 AND \u2581 c \u2581 is \u2581 equal \u2581 to \u2581 d STRNEWLINE \" ) ; else printf ( \" AND \u2581 condition \u2581 not \u2581 satisfied STRNEWLINE \" ) ; if ( a > b c == d ) printf ( \" a \u2581 is \u2581 greater \u2581 than \u2581 b \u2581 OR \u2581 c \u2581 is \u2581 equal \u2581 to \u2581 d STRNEWLINE \" ) ; else printf ( \" Neither \u2581 a \u2581 is \u2581 greater \u2581 than \u2581 b \u2581 nor \u2581 c \u2581 is \u2581 equal \u2581 \" \" \u2581 to \u2581 d STRNEWLINE \" ) ; if ( ! a ) printf ( \" a \u2581 is \u2581 zero STRNEWLINE \" ) ; else printf ( \" a \u2581 is \u2581 not \u2581 zero \" ) ; return 0 ; }"}
{"text": "Operators in C | Set 2 ( Relational and Logical Operators ) |", "code": "#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE int main ( ) { int a = 10 , b = 4 ; bool res = ( ( a != b ) || printf ( \" GeeksQuiz \" ) ) ; return 0 ; }"}
{"text": "How to swap two bits in a given integer ? | C program to swap bits in an integer ; This function swaps bit at positions p1 and p2 in an integer n ; Move p1 'th to rightmost side  ; Move p2 'th to rightmost side  ; XOR the two bits ; Put the xor bit back to their original positions ; XOR ' x ' with the original number so that the two sets are swapped ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int swapBits ( unsigned int n , unsigned int p1 , unsigned int p2 ) { unsigned int bit1 = ( n >> p1 ) & 1 ; unsigned int bit2 = ( n >> p2 ) & 1 ; unsigned int x = ( bit1 ^ bit2 ) ; x = ( x << p1 ) | ( x << p2 ) ; unsigned int result = n ^ x ; } int main ( ) { int res = swapBits ( 28 , 0 , 3 ) ; printf ( \" Result \u2581 = \u2581 % d \u2581 \" , res ) ; return 0 ; }"}
{"text": "Write a function that returns 2 for input 1 and returns 1 for 2 |", "code": "int invert ( int x ) { if ( x == 1 ) return 2 ; else return 1 ; }"}
{"text": "Write a function that returns 2 for input 1 and returns 1 for 2 |", "code": "int invertSub ( int x ) { return ( 3 - x ) ; }"}
{"text": "Bitwise Operators in C / C ++ |  ; Function to return the only odd occurring element ; Driver Method", "code": "#include <stdio.h> NEW_LINE int findOdd ( int arr [ ] , int n ) { int res = 0 , i ; for ( i = 0 ; i < n ; i ++ ) res ^= arr [ i ] ; return res ; } int main ( void ) { int arr [ ] = { 12 , 12 , 14 , 90 , 14 , 14 , 14 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" The \u2581 odd \u2581 occurring \u2581 element \u2581 is \u2581 % d \u2581 \" , findOdd ( arr , n ) ) ; return 0 ; }"}
{"text": "Bitwise Operators in C / C ++ |", "code": "#include <stdio.h> NEW_LINE int main ( ) { int x = 2 , y = 5 ; ( x & y ) ? printf ( \" True \u2581 \" ) : printf ( \" False \u2581 \" ) ; ( x && y ) ? printf ( \" True \u2581 \" ) : printf ( \" False \u2581 \" ) ; return 0 ; }"}
{"text": "Hamming code Implementation in C / C ++ | C program for the above approach ; Store input bits ; Store hamming code ; Function to calculate bit for ith position ; Traverse to store Hamming Code ; If current boit is 1 ; Update i ; Function to calculate hamming code ; Find msg bits having set bit at x 'th position of number ; Traverse the msgBits ; Update the code ; Update the code [ i ] to the input character at index j ; Traverse and update the hamming code ; Find current position ; Find value at current position ; Update the code ; Print the Hamming Code ; Driver Code ; Given input message Bit ; Function Call", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE int input [ 32 ] ; int code [ 32 ] ; int ham_calc ( int , int ) ; void solve ( int input [ ] , int ) ; int ham_calc ( int position , int c_l ) { int count = 0 , i , j ; i = position - 1 ; while ( i < c_l ) { for ( j = i ; j < i + position ; j ++ ) { if ( code [ j ] == 1 ) count ++ ; } i = i + 2 * position ; } if ( count % 2 == 0 ) return 0 ; else return 1 ; } void solve ( int input [ ] , int n ) { int i , p_n = 0 , c_l , j , k ; i = 0 ; while ( n > ( int ) pow ( 2 , i ) - ( i + 1 ) ) { p_n ++ ; i ++ ; } c_l = p_n + n ; j = k = 0 ; for ( i = 0 ; i < c_l ; i ++ ) { if ( i == ( ( int ) pow ( 2 , k ) - 1 ) ) { code [ i ] = 0 ; k ++ ; } else { code [ i ] = input [ j ] ; j ++ ; } } for ( i = 0 ; i < p_n ; i ++ ) { int position = ( int ) pow ( 2 , i ) ; int value = ham_calc ( position , c_l ) ; code [ position - 1 ] = value ; } printf ( \" The generated Code Word is : \" for ( i = 0 ; i < c_l ; i ++ ) { printf ( \" % d \" , code [ i ] ) ; } } void main ( ) { input [ 0 ] = 0 ; input [ 1 ] = 1 ; input [ 2 ] = 1 ; input [ 3 ] = 1 ; int N = 4 ; solve ( input , N ) ; }"}
{"text": "First non | CPP program to find first non - repeating character using 1D array and one traversal . ; The function returns index of the first non - repeating character in a string . If all characters are repeating then returns INT_MAX ; Initialize all characters as absent . ; After below loop , the value of arr [ x ] is going to be index of of x if x appears only once . Else the value is going to be either - 1 or - 2. ; If this character occurs only once and appears before the current result , then update the result ; Driver program to test above function", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE #include <math.h> NEW_LINE #define NO_OF_CHARS  256 NEW_LINE int firstNonRepeating ( char * str ) { int arr [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = -1 ; for ( int i = 0 ; str [ i ] ; i ++ ) { if ( arr [ str [ i ] ] == -1 ) arr [ str [ i ] ] = i ; else arr [ str [ i ] ] = -2 ; } int res = INT_MAX ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = min ( res , arr [ i ] ) ; return res ; } int main ( ) { char str [ ] = \" geeksforgeeks \" ; int index = firstNonRepeating ( str ) ; if ( index == INT_MAX ) printf ( \" Either \u2581 all \u2581 characters \u2581 are \u2581 \" \" repeating \u2581 or \u2581 string \u2581 is \u2581 empty \" ) ; else printf ( \" First \u2581 non - repeating \u2581 character \" \" \u2581 is \u2581 % c \" , str [ index ] ) ; return 0 ; }"}
{"text": "Triacontagon Number | C program for above approach ; Finding the nth triacontagonal Number ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int triacontagonalNum ( int n ) { return ( 28 * n * n - 26 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd \u2581 triacontagonal \u2581 Number \u2581 is \u2581 = \u2581 % d \" , triacontagonalNum ( n ) ) ; return 0 ; }"}
{"text": "Hexacontagon Number | C program for above approach ; Finding the nth hexacontagon Number ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int hexacontagonNum ( int n ) { return ( 58 * n * n - 56 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd \u2581 hexacontagon \u2581 Number \u2581 is \u2581 = \u2581 % d \" , hexacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Enneacontagon Number | C program for above approach ; Finding the nth enneacontagon Number ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int enneacontagonNum ( int n ) { return ( 88 * n * n - 86 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd \u2581 enneacontagon \u2581 Number \u2581 is \u2581 = \u2581 % d \" , enneacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Triacontakaidigon Number | C program for above approach ; Finding the nth triacontakaidigon Number ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int triacontakaidigonNum ( int n ) { return ( 30 * n * n - 28 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd \u2581 triacontakaidigon \u2581 Number \u2581 is \u2581 = \u2581 % d \" , triacontakaidigonNum ( n ) ) ; return 0 ; }"}
{"text": "Icosihexagonal Number | C program for above approach ; Finding the nth Icosihexagonal Number ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int IcosihexagonalNum ( int n ) { return ( 24 * n * n - 22 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd \u2581 Icosihexagonal \u2581 Number \u2581 is \u2581 = \u2581 % d \" , IcosihexagonalNum ( n ) ) ; return 0 ; }"}
{"text": "Icosikaioctagon or Icosioctagon Number | C program for above approach ; Finding the nth icosikaioctagonal Number ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd \u2581 icosikaioctagonal \u2581 Number \u2581 is \u2581 = \u2581 % d \" , icosikaioctagonalNum ( n ) ) ; return 0 ; }"}
{"text": "Octacontagon Number | C program for above approach ; Finding the nth octacontagon Number ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd \u2581 octacontagon \u2581 Number \u2581 is \u2581 = \u2581 % d \" , octacontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Hectagon Number | C program for above approach ; Finding the nth hectagon Number ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd \u2581 hectagon \u2581 Number \u2581 is \u2581 = \u2581 % d \" , hectagonNum ( n ) ) ; return 0 ; }"}
{"text": "Tetracontagon Number | C program for above approach ; Finding the nth tetracontagon Number ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; } int main ( ) { int n = 3 ; printf ( \"3rd \u2581 tetracontagon \u2581 Number \u2581 is \u2581 = \u2581 % d \" , tetracontagonNum ( n ) ) ; return 0 ; }"}
{"text": "Search an element in a reverse sorted array | C program for the above approach ; Function to search if element X is present in reverse sorted array ; Store the first index of the subarray in which X lies ; Store the last index of the subarray in which X lies ; Store the middle index of the subarray ; Check if value at middle index of the subarray equal to X ; Element is found ; If X is smaller than the value at middle index of the subarray ; Search in right half of subarray ; Search in left half of subarray ; If X not found ; Driver Code", "code": "#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int N , int X ) { int start = 0 ; int end = N ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( X == arr [ mid ] ) { return mid ; } else if ( X < arr [ mid ] ) { start = mid + 1 ; } else { end = mid - 1 ; } } return -1 ; } int main ( ) { int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 4 ; int res = binarySearch ( arr , N , X ) ; printf ( \" \u2581 % d \u2581 \" , res ) ; return 0 ; }"}
{"text": "Pancake sorting | C program to sort array using pancake sort ; Reverses arr [ 0. . i ] ; Returns index of the maximum element in arr [ 0. . n - 1 ] ; The main function that sorts given array using flip operations ; Start from the complete array and one by one reduce current size by one ; Find index of the maximum element in arr [ 0. . curr_size - 1 ] ; Move the maximum element to end of current array if it 's not already  at the end ; To move at the end , first move maximum number to beginning ; Now move the maximum number to end by reversing current array ; A utility function to print n array of size n ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } } int findMax ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; } void pancakeSort ( int * arr , int n ) { for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) { int mi = findMax ( arr , curr_size ) ; if ( mi != curr_size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_size - 1 ) ; } } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) printf ( \" % d \u2581 \" , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 23 , 10 , 20 , 11 , 12 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pancakeSort ( arr , n ) ; puts ( \" Sorted \u2581 Array \u2581 \" ) ; printArray ( arr , n ) ; return 0 ; }"}
